//
// AUTO-GENERATED FILE, DO NOT MODIFY!
//
// @dart=2.12

// ignore_for_file: unused_element, unused_import
// ignore_for_file: always_put_required_named_parameters_first
// ignore_for_file: constant_identifier_names
// ignore_for_file: lines_longer_than_80_chars

part of openapi.api;

class DefaultApi {
  DefaultApi([ApiClient? apiClient])
      : apiClient = apiClient ?? defaultApiClient;

  final ApiClient apiClient;

  /// Allows to perform multiple index/update/delete operations in a single request.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [Object] body (required):
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
  ///
  /// * [RefreshEnum] refresh:
  ///   If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] type:
  ///   Default document type for items which don't provide one.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or default list of fields to return, can be overridden on each sub-request.
  ///
  /// * [List<String>] sourceExcludes:
  ///   Default list of fields to exclude from the returned _source field, can be overridden on each sub-request.
  ///
  /// * [List<String>] sourceIncludes:
  ///   Default list of fields to extract and return from the _source field, can be overridden on each sub-request.
  ///
  /// * [String] pipeline:
  ///   The pipeline id to preprocess incoming documents with.
  ///
  /// * [bool] requireAlias:
  ///   Sets require_alias for all incoming documents.
  Future<Response> bulkPostWithHttpInfo(
    Object body, {
    String? waitForActiveShards,
    RefreshEnum? refresh,
    String? routing,
    String? timeout,
    String? type,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    String? pipeline,
    bool? requireAlias,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_bulk';

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (waitForActiveShards != null) {
      queryParams.addAll(
          _queryParams('', 'wait_for_active_shards', waitForActiveShards));
    }
    if (refresh != null) {
      queryParams.addAll(_queryParams('', 'refresh', refresh));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (type != null) {
      queryParams.addAll(_queryParams('', 'type', type));
    }
    if (source_ != null) {
      queryParams.addAll(_queryParams('multi', '_source', source_));
    }
    if (sourceExcludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_excludes', sourceExcludes));
    }
    if (sourceIncludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_includes', sourceIncludes));
    }
    if (pipeline != null) {
      queryParams.addAll(_queryParams('', 'pipeline', pipeline));
    }
    if (requireAlias != null) {
      queryParams.addAll(_queryParams('', 'require_alias', requireAlias));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to perform multiple index/update/delete operations in a single request.
  ///
  /// Parameters:
  ///
  /// * [Object] body (required):
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
  ///
  /// * [RefreshEnum] refresh:
  ///   If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] type:
  ///   Default document type for items which don't provide one.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or default list of fields to return, can be overridden on each sub-request.
  ///
  /// * [List<String>] sourceExcludes:
  ///   Default list of fields to exclude from the returned _source field, can be overridden on each sub-request.
  ///
  /// * [List<String>] sourceIncludes:
  ///   Default list of fields to extract and return from the _source field, can be overridden on each sub-request.
  ///
  /// * [String] pipeline:
  ///   The pipeline id to preprocess incoming documents with.
  ///
  /// * [bool] requireAlias:
  ///   Sets require_alias for all incoming documents.
  Future<void> bulkPost(
    Object body, {
    String? waitForActiveShards,
    RefreshEnum? refresh,
    String? routing,
    String? timeout,
    String? type,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    String? pipeline,
    bool? requireAlias,
  }) async {
    final response = await bulkPostWithHttpInfo(
      body,
      waitForActiveShards: waitForActiveShards,
      refresh: refresh,
      routing: routing,
      timeout: timeout,
      type: type,
      source_: source_,
      sourceExcludes: sourceExcludes,
      sourceIncludes: sourceIncludes,
      pipeline: pipeline,
      requireAlias: requireAlias,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to perform multiple index/update/delete operations in a single request.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Default index for items which don't provide one.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
  ///
  /// * [RefreshEnum] refresh:
  ///   If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] type:
  ///   Default document type for items which don't provide one.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or default list of fields to return, can be overridden on each sub-request.
  ///
  /// * [List<String>] sourceExcludes:
  ///   Default list of fields to exclude from the returned _source field, can be overridden on each sub-request.
  ///
  /// * [List<String>] sourceIncludes:
  ///   Default list of fields to extract and return from the _source field, can be overridden on each sub-request.
  ///
  /// * [String] pipeline:
  ///   The pipeline id to preprocess incoming documents with.
  ///
  /// * [bool] requireAlias:
  ///   Sets require_alias for all incoming documents.
  Future<Response> bulkPostWithIndexWithHttpInfo(
    String index,
    Object body, {
    String? waitForActiveShards,
    RefreshEnum? refresh,
    String? routing,
    String? timeout,
    String? type,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    String? pipeline,
    bool? requireAlias,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_bulk'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (waitForActiveShards != null) {
      queryParams.addAll(
          _queryParams('', 'wait_for_active_shards', waitForActiveShards));
    }
    if (refresh != null) {
      queryParams.addAll(_queryParams('', 'refresh', refresh));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (type != null) {
      queryParams.addAll(_queryParams('', 'type', type));
    }
    if (source_ != null) {
      queryParams.addAll(_queryParams('multi', '_source', source_));
    }
    if (sourceExcludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_excludes', sourceExcludes));
    }
    if (sourceIncludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_includes', sourceIncludes));
    }
    if (pipeline != null) {
      queryParams.addAll(_queryParams('', 'pipeline', pipeline));
    }
    if (requireAlias != null) {
      queryParams.addAll(_queryParams('', 'require_alias', requireAlias));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to perform multiple index/update/delete operations in a single request.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Default index for items which don't provide one.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
  ///
  /// * [RefreshEnum] refresh:
  ///   If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] type:
  ///   Default document type for items which don't provide one.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or default list of fields to return, can be overridden on each sub-request.
  ///
  /// * [List<String>] sourceExcludes:
  ///   Default list of fields to exclude from the returned _source field, can be overridden on each sub-request.
  ///
  /// * [List<String>] sourceIncludes:
  ///   Default list of fields to extract and return from the _source field, can be overridden on each sub-request.
  ///
  /// * [String] pipeline:
  ///   The pipeline id to preprocess incoming documents with.
  ///
  /// * [bool] requireAlias:
  ///   Sets require_alias for all incoming documents.
  Future<void> bulkPostWithIndex(
    String index,
    Object body, {
    String? waitForActiveShards,
    RefreshEnum? refresh,
    String? routing,
    String? timeout,
    String? type,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    String? pipeline,
    bool? requireAlias,
  }) async {
    final response = await bulkPostWithIndexWithHttpInfo(
      index,
      body,
      waitForActiveShards: waitForActiveShards,
      refresh: refresh,
      routing: routing,
      timeout: timeout,
      type: type,
      source_: source_,
      sourceExcludes: sourceExcludes,
      sourceIncludes: sourceIncludes,
      pipeline: pipeline,
      requireAlias: requireAlias,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to perform multiple index/update/delete operations in a single request.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [Object] body (required):
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
  ///
  /// * [RefreshEnum] refresh:
  ///   If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] type:
  ///   Default document type for items which don't provide one.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or default list of fields to return, can be overridden on each sub-request.
  ///
  /// * [List<String>] sourceExcludes:
  ///   Default list of fields to exclude from the returned _source field, can be overridden on each sub-request.
  ///
  /// * [List<String>] sourceIncludes:
  ///   Default list of fields to extract and return from the _source field, can be overridden on each sub-request.
  ///
  /// * [String] pipeline:
  ///   The pipeline id to preprocess incoming documents with.
  ///
  /// * [bool] requireAlias:
  ///   Sets require_alias for all incoming documents.
  Future<Response> bulkPutWithHttpInfo(
    Object body, {
    String? waitForActiveShards,
    RefreshEnum? refresh,
    String? routing,
    String? timeout,
    String? type,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    String? pipeline,
    bool? requireAlias,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_bulk';

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (waitForActiveShards != null) {
      queryParams.addAll(
          _queryParams('', 'wait_for_active_shards', waitForActiveShards));
    }
    if (refresh != null) {
      queryParams.addAll(_queryParams('', 'refresh', refresh));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (type != null) {
      queryParams.addAll(_queryParams('', 'type', type));
    }
    if (source_ != null) {
      queryParams.addAll(_queryParams('multi', '_source', source_));
    }
    if (sourceExcludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_excludes', sourceExcludes));
    }
    if (sourceIncludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_includes', sourceIncludes));
    }
    if (pipeline != null) {
      queryParams.addAll(_queryParams('', 'pipeline', pipeline));
    }
    if (requireAlias != null) {
      queryParams.addAll(_queryParams('', 'require_alias', requireAlias));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to perform multiple index/update/delete operations in a single request.
  ///
  /// Parameters:
  ///
  /// * [Object] body (required):
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
  ///
  /// * [RefreshEnum] refresh:
  ///   If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] type:
  ///   Default document type for items which don't provide one.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or default list of fields to return, can be overridden on each sub-request.
  ///
  /// * [List<String>] sourceExcludes:
  ///   Default list of fields to exclude from the returned _source field, can be overridden on each sub-request.
  ///
  /// * [List<String>] sourceIncludes:
  ///   Default list of fields to extract and return from the _source field, can be overridden on each sub-request.
  ///
  /// * [String] pipeline:
  ///   The pipeline id to preprocess incoming documents with.
  ///
  /// * [bool] requireAlias:
  ///   Sets require_alias for all incoming documents.
  Future<void> bulkPut(
    Object body, {
    String? waitForActiveShards,
    RefreshEnum? refresh,
    String? routing,
    String? timeout,
    String? type,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    String? pipeline,
    bool? requireAlias,
  }) async {
    final response = await bulkPutWithHttpInfo(
      body,
      waitForActiveShards: waitForActiveShards,
      refresh: refresh,
      routing: routing,
      timeout: timeout,
      type: type,
      source_: source_,
      sourceExcludes: sourceExcludes,
      sourceIncludes: sourceIncludes,
      pipeline: pipeline,
      requireAlias: requireAlias,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to perform multiple index/update/delete operations in a single request.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Default index for items which don't provide one.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
  ///
  /// * [RefreshEnum] refresh:
  ///   If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] type:
  ///   Default document type for items which don't provide one.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or default list of fields to return, can be overridden on each sub-request.
  ///
  /// * [List<String>] sourceExcludes:
  ///   Default list of fields to exclude from the returned _source field, can be overridden on each sub-request.
  ///
  /// * [List<String>] sourceIncludes:
  ///   Default list of fields to extract and return from the _source field, can be overridden on each sub-request.
  ///
  /// * [String] pipeline:
  ///   The pipeline id to preprocess incoming documents with.
  ///
  /// * [bool] requireAlias:
  ///   Sets require_alias for all incoming documents.
  Future<Response> bulkPutWithIndexWithHttpInfo(
    String index,
    Object body, {
    String? waitForActiveShards,
    RefreshEnum? refresh,
    String? routing,
    String? timeout,
    String? type,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    String? pipeline,
    bool? requireAlias,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_bulk'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (waitForActiveShards != null) {
      queryParams.addAll(
          _queryParams('', 'wait_for_active_shards', waitForActiveShards));
    }
    if (refresh != null) {
      queryParams.addAll(_queryParams('', 'refresh', refresh));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (type != null) {
      queryParams.addAll(_queryParams('', 'type', type));
    }
    if (source_ != null) {
      queryParams.addAll(_queryParams('multi', '_source', source_));
    }
    if (sourceExcludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_excludes', sourceExcludes));
    }
    if (sourceIncludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_includes', sourceIncludes));
    }
    if (pipeline != null) {
      queryParams.addAll(_queryParams('', 'pipeline', pipeline));
    }
    if (requireAlias != null) {
      queryParams.addAll(_queryParams('', 'require_alias', requireAlias));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to perform multiple index/update/delete operations in a single request.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Default index for items which don't provide one.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
  ///
  /// * [RefreshEnum] refresh:
  ///   If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] type:
  ///   Default document type for items which don't provide one.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or default list of fields to return, can be overridden on each sub-request.
  ///
  /// * [List<String>] sourceExcludes:
  ///   Default list of fields to exclude from the returned _source field, can be overridden on each sub-request.
  ///
  /// * [List<String>] sourceIncludes:
  ///   Default list of fields to extract and return from the _source field, can be overridden on each sub-request.
  ///
  /// * [String] pipeline:
  ///   The pipeline id to preprocess incoming documents with.
  ///
  /// * [bool] requireAlias:
  ///   Sets require_alias for all incoming documents.
  Future<void> bulkPutWithIndex(
    String index,
    Object body, {
    String? waitForActiveShards,
    RefreshEnum? refresh,
    String? routing,
    String? timeout,
    String? type,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    String? pipeline,
    bool? requireAlias,
  }) async {
    final response = await bulkPutWithIndexWithHttpInfo(
      index,
      body,
      waitForActiveShards: waitForActiveShards,
      refresh: refresh,
      routing: routing,
      timeout: timeout,
      type: type,
      source_: source_,
      sourceExcludes: sourceExcludes,
      sourceIncludes: sourceIncludes,
      pipeline: pipeline,
      requireAlias: requireAlias,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns a document.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Document ID.
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [List<String>] storedFields:
  ///   Comma-separated list of stored fields to return.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [bool] realtime:
  ///   Specify whether to perform the operation in realtime or search mode.
  ///
  /// * [bool] refresh:
  ///   Refresh the shard containing the document before performing the operation.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  Future<Response> callGetWithHttpInfo(
    String id,
    String index, {
    List<String>? storedFields,
    String? preference,
    bool? realtime,
    bool? refresh,
    String? routing,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    int? version,
    VersionType? versionType,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_doc/{id}'
        .replaceAll('{id}', id)
        .replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (storedFields != null) {
      queryParams.addAll(_queryParams('multi', 'stored_fields', storedFields));
    }
    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (realtime != null) {
      queryParams.addAll(_queryParams('', 'realtime', realtime));
    }
    if (refresh != null) {
      queryParams.addAll(_queryParams('', 'refresh', refresh));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (source_ != null) {
      queryParams.addAll(_queryParams('multi', '_source', source_));
    }
    if (sourceExcludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_excludes', sourceExcludes));
    }
    if (sourceIncludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_includes', sourceIncludes));
    }
    if (version != null) {
      queryParams.addAll(_queryParams('', 'version', version));
    }
    if (versionType != null) {
      queryParams.addAll(_queryParams('', 'version_type', versionType));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns a document.
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Document ID.
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [List<String>] storedFields:
  ///   Comma-separated list of stored fields to return.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [bool] realtime:
  ///   Specify whether to perform the operation in realtime or search mode.
  ///
  /// * [bool] refresh:
  ///   Refresh the shard containing the document before performing the operation.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  Future<GetResponseContent?> callGet(
    String id,
    String index, {
    List<String>? storedFields,
    String? preference,
    bool? realtime,
    bool? refresh,
    String? routing,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    int? version,
    VersionType? versionType,
  }) async {
    final response = await callGetWithHttpInfo(
      id,
      index,
      storedFields: storedFields,
      preference: preference,
      realtime: realtime,
      refresh: refresh,
      routing: routing,
      source_: source_,
      sourceExcludes: sourceExcludes,
      sourceIncludes: sourceIncludes,
      version: version,
      versionType: versionType,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'GetResponseContent',
      ) as GetResponseContent;
    }
    return null;
  }

  /// Shows information about currently configured aliases to indices including filter and routing infos.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<Response> catAliasesWithHttpInfo({
    String? format,
    bool? local,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
    ExpandWildcards? expandWildcards,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/aliases';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Shows information about currently configured aliases to indices including filter and routing infos.
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<void> catAliases({
    String? format,
    bool? local,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
    ExpandWildcards? expandWildcards,
  }) async {
    final response = await catAliasesWithHttpInfo(
      format: format,
      local: local,
      h: h,
      help: help,
      s: s,
      v: v,
      expandWildcards: expandWildcards,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Shows information about currently configured aliases to indices including filter and routing infos.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   Comma-separated list of alias names.
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<Response> catAliasesWithNameWithHttpInfo(
    String name, {
    String? format,
    bool? local,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
    ExpandWildcards? expandWildcards,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/aliases/{name}'.replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Shows information about currently configured aliases to indices including filter and routing infos.
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   Comma-separated list of alias names.
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<void> catAliasesWithName(
    String name, {
    String? format,
    bool? local,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
    ExpandWildcards? expandWildcards,
  }) async {
    final response = await catAliasesWithNameWithHttpInfo(
      name,
      format: format,
      local: local,
      h: h,
      help: help,
      s: s,
      v: v,
      expandWildcards: expandWildcards,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Lists all active point-in-time segments.
  ///
  /// Note: This method returns the HTTP [Response].
  Future<Response> catAllPitSegmentsWithHttpInfo() async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/pit_segments/_all';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Lists all active point-in-time segments.
  Future<CatAllPitSegmentsResponseContent?> catAllPitSegments() async {
    final response = await catAllPitSegmentsWithHttpInfo();
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'CatAllPitSegmentsResponseContent',
      ) as CatAllPitSegmentsResponseContent;
    }
    return null;
  }

  /// Provides a snapshot of how many shards are allocated to each data node and how much disk space they are using.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [Bytes] bytes:
  ///   The unit in which to display byte values.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<Response> catAllocationWithHttpInfo({
    String? format,
    Bytes? bytes,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/allocation';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (bytes != null) {
      queryParams.addAll(_queryParams('', 'bytes', bytes));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Provides a snapshot of how many shards are allocated to each data node and how much disk space they are using.
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [Bytes] bytes:
  ///   The unit in which to display byte values.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<void> catAllocation({
    String? format,
    Bytes? bytes,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
  }) async {
    final response = await catAllocationWithHttpInfo(
      format: format,
      bytes: bytes,
      local: local,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      h: h,
      help: help,
      s: s,
      v: v,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Provides a snapshot of how many shards are allocated to each data node and how much disk space they are using.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] nodeId (required):
  ///   Comma-separated list of node IDs or names to limit the returned information.
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [Bytes] bytes:
  ///   The unit in which to display byte values.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<Response> catAllocationWithNodeIdWithHttpInfo(
    String nodeId, {
    String? format,
    Bytes? bytes,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/allocation/{node_id}'.replaceAll('{node_id}', nodeId);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (bytes != null) {
      queryParams.addAll(_queryParams('', 'bytes', bytes));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Provides a snapshot of how many shards are allocated to each data node and how much disk space they are using.
  ///
  /// Parameters:
  ///
  /// * [String] nodeId (required):
  ///   Comma-separated list of node IDs or names to limit the returned information.
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [Bytes] bytes:
  ///   The unit in which to display byte values.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<void> catAllocationWithNodeId(
    String nodeId, {
    String? format,
    Bytes? bytes,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
  }) async {
    final response = await catAllocationWithNodeIdWithHttpInfo(
      nodeId,
      format: format,
      bytes: bytes,
      local: local,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      h: h,
      help: help,
      s: s,
      v: v,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about the cluster-manager node.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<Response> catClusterManagerWithHttpInfo({
    String? format,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/cluster_manager';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about the cluster-manager node.
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<void> catClusterManager({
    String? format,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
  }) async {
    final response = await catClusterManagerWithHttpInfo(
      format: format,
      local: local,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      h: h,
      help: help,
      s: s,
      v: v,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Provides quick access to the document count of the entire cluster, or individual indices.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<Response> catCountWithHttpInfo({
    String? format,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/count';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Provides quick access to the document count of the entire cluster, or individual indices.
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<void> catCount({
    String? format,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
  }) async {
    final response = await catCountWithHttpInfo(
      format: format,
      h: h,
      help: help,
      s: s,
      v: v,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Provides quick access to the document count of the entire cluster, or individual indices.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to limit the returned information.
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<Response> catCountWithIndexWithHttpInfo(
    String index, {
    String? format,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/count/{index}'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Provides quick access to the document count of the entire cluster, or individual indices.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to limit the returned information.
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<void> catCountWithIndex(
    String index, {
    String? format,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
  }) async {
    final response = await catCountWithIndexWithHttpInfo(
      index,
      format: format,
      h: h,
      help: help,
      s: s,
      v: v,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Shows how much heap memory is currently being used by fielddata on every data node in the cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [Bytes] bytes:
  ///   The unit in which to display byte values.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields to return in the output.
  Future<Response> catFielddataWithHttpInfo({
    String? format,
    Bytes? bytes,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
    List<String>? fields,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/fielddata';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (bytes != null) {
      queryParams.addAll(_queryParams('', 'bytes', bytes));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }
    if (fields != null) {
      queryParams.addAll(_queryParams('multi', 'fields', fields));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Shows how much heap memory is currently being used by fielddata on every data node in the cluster.
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [Bytes] bytes:
  ///   The unit in which to display byte values.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields to return in the output.
  Future<void> catFielddata({
    String? format,
    Bytes? bytes,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
    List<String>? fields,
  }) async {
    final response = await catFielddataWithHttpInfo(
      format: format,
      bytes: bytes,
      h: h,
      help: help,
      s: s,
      v: v,
      fields: fields,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Shows how much heap memory is currently being used by fielddata on every data node in the cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] fields (required):
  ///   Comma-separated list of fields to return the fielddata size.
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [Bytes] bytes:
  ///   The unit in which to display byte values.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  ///
  /// * [List<String>] fields2:
  ///   Comma-separated list of fields to return in the output.
  Future<Response> catFielddataWithFieldsWithHttpInfo(
    String fields, {
    String? format,
    Bytes? bytes,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
    List<String>? fields2,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/fielddata/{fields}'.replaceAll('{fields}', fields);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (bytes != null) {
      queryParams.addAll(_queryParams('', 'bytes', bytes));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }
    if (fields2 != null) {
      queryParams.addAll(_queryParams('multi', 'fields', fields2));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Shows how much heap memory is currently being used by fielddata on every data node in the cluster.
  ///
  /// Parameters:
  ///
  /// * [String] fields (required):
  ///   Comma-separated list of fields to return the fielddata size.
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [Bytes] bytes:
  ///   The unit in which to display byte values.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  ///
  /// * [List<String>] fields2:
  ///   Comma-separated list of fields to return in the output.
  Future<void> catFielddataWithFields(
    String fields, {
    String? format,
    Bytes? bytes,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
    List<String>? fields2,
  }) async {
    final response = await catFielddataWithFieldsWithHttpInfo(
      fields,
      format: format,
      bytes: bytes,
      h: h,
      help: help,
      s: s,
      v: v,
      fields2: fields2,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns a concise representation of the cluster health.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [Time] time:
  ///   The unit in which to display time values.
  ///
  /// * [bool] ts:
  ///   Set to false to disable timestamping.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<Response> catHealthWithHttpInfo({
    String? format,
    List<String>? h,
    bool? help,
    List<String>? s,
    Time? time,
    bool? ts,
    bool? v,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/health';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (time != null) {
      queryParams.addAll(_queryParams('', 'time', time));
    }
    if (ts != null) {
      queryParams.addAll(_queryParams('', 'ts', ts));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns a concise representation of the cluster health.
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [Time] time:
  ///   The unit in which to display time values.
  ///
  /// * [bool] ts:
  ///   Set to false to disable timestamping.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<void> catHealth({
    String? format,
    List<String>? h,
    bool? help,
    List<String>? s,
    Time? time,
    bool? ts,
    bool? v,
  }) async {
    final response = await catHealthWithHttpInfo(
      format: format,
      h: h,
      help: help,
      s: s,
      time: time,
      ts: ts,
      v: v,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns help for the Cat APIs.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  Future<Response> catHelpWithHttpInfo({
    bool? help,
    List<String>? s,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns help for the Cat APIs.
  ///
  /// Parameters:
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  Future<void> catHelp({
    bool? help,
    List<String>? s,
  }) async {
    final response = await catHelpWithHttpInfo(
      help: help,
      s: s,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about indices: number of primaries and replicas, document counts, disk size, ...
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [Bytes] bytes:
  ///   The unit in which to display byte values.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [Health] health:
  ///   Health status ('green', 'yellow', or 'red') to filter only indices matching the specified health status.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [bool] pri:
  ///   Set to true to return stats only for primary shards.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [Time] time:
  ///   The unit in which to display time values.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  ///
  /// * [bool] includeUnloadedSegments:
  ///   If set to true segment stats will include stats for segments that are not currently loaded into memory.
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<Response> catIndicesWithHttpInfo({
    String? format,
    Bytes? bytes,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    Health? health,
    bool? help,
    bool? pri,
    List<String>? s,
    Time? time,
    bool? v,
    bool? includeUnloadedSegments,
    ExpandWildcards? expandWildcards,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/indices';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (bytes != null) {
      queryParams.addAll(_queryParams('', 'bytes', bytes));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (health != null) {
      queryParams.addAll(_queryParams('', 'health', health));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (pri != null) {
      queryParams.addAll(_queryParams('', 'pri', pri));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (time != null) {
      queryParams.addAll(_queryParams('', 'time', time));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }
    if (includeUnloadedSegments != null) {
      queryParams.addAll(_queryParams(
          '', 'include_unloaded_segments', includeUnloadedSegments));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about indices: number of primaries and replicas, document counts, disk size, ...
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [Bytes] bytes:
  ///   The unit in which to display byte values.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [Health] health:
  ///   Health status ('green', 'yellow', or 'red') to filter only indices matching the specified health status.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [bool] pri:
  ///   Set to true to return stats only for primary shards.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [Time] time:
  ///   The unit in which to display time values.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  ///
  /// * [bool] includeUnloadedSegments:
  ///   If set to true segment stats will include stats for segments that are not currently loaded into memory.
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<void> catIndices({
    String? format,
    Bytes? bytes,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    Health? health,
    bool? help,
    bool? pri,
    List<String>? s,
    Time? time,
    bool? v,
    bool? includeUnloadedSegments,
    ExpandWildcards? expandWildcards,
  }) async {
    final response = await catIndicesWithHttpInfo(
      format: format,
      bytes: bytes,
      local: local,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      h: h,
      health: health,
      help: help,
      pri: pri,
      s: s,
      time: time,
      v: v,
      includeUnloadedSegments: includeUnloadedSegments,
      expandWildcards: expandWildcards,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about indices: number of primaries and replicas, document counts, disk size, ...
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to limit the returned information.
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [Bytes] bytes:
  ///   The unit in which to display byte values.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [Health] health:
  ///   Health status ('green', 'yellow', or 'red') to filter only indices matching the specified health status.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [bool] pri:
  ///   Set to true to return stats only for primary shards.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [Time] time:
  ///   The unit in which to display time values.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  ///
  /// * [bool] includeUnloadedSegments:
  ///   If set to true segment stats will include stats for segments that are not currently loaded into memory.
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<Response> catIndicesWithIndexWithHttpInfo(
    String index, {
    String? format,
    Bytes? bytes,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    Health? health,
    bool? help,
    bool? pri,
    List<String>? s,
    Time? time,
    bool? v,
    bool? includeUnloadedSegments,
    ExpandWildcards? expandWildcards,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/indices/{index}'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (bytes != null) {
      queryParams.addAll(_queryParams('', 'bytes', bytes));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (health != null) {
      queryParams.addAll(_queryParams('', 'health', health));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (pri != null) {
      queryParams.addAll(_queryParams('', 'pri', pri));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (time != null) {
      queryParams.addAll(_queryParams('', 'time', time));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }
    if (includeUnloadedSegments != null) {
      queryParams.addAll(_queryParams(
          '', 'include_unloaded_segments', includeUnloadedSegments));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about indices: number of primaries and replicas, document counts, disk size, ...
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to limit the returned information.
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [Bytes] bytes:
  ///   The unit in which to display byte values.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [Health] health:
  ///   Health status ('green', 'yellow', or 'red') to filter only indices matching the specified health status.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [bool] pri:
  ///   Set to true to return stats only for primary shards.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [Time] time:
  ///   The unit in which to display time values.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  ///
  /// * [bool] includeUnloadedSegments:
  ///   If set to true segment stats will include stats for segments that are not currently loaded into memory.
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<void> catIndicesWithIndex(
    String index, {
    String? format,
    Bytes? bytes,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    Health? health,
    bool? help,
    bool? pri,
    List<String>? s,
    Time? time,
    bool? v,
    bool? includeUnloadedSegments,
    ExpandWildcards? expandWildcards,
  }) async {
    final response = await catIndicesWithIndexWithHttpInfo(
      index,
      format: format,
      bytes: bytes,
      local: local,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      h: h,
      health: health,
      help: help,
      pri: pri,
      s: s,
      time: time,
      v: v,
      includeUnloadedSegments: includeUnloadedSegments,
      expandWildcards: expandWildcards,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about the cluster-manager node.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<Response> catMasterWithHttpInfo({
    String? format,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/master';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about the cluster-manager node.
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<void> catMaster({
    String? format,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
  }) async {
    final response = await catMasterWithHttpInfo(
      format: format,
      local: local,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      h: h,
      help: help,
      s: s,
      v: v,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about custom node attributes.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<Response> catNodeattrsWithHttpInfo({
    String? format,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/nodeattrs';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about custom node attributes.
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<void> catNodeattrs({
    String? format,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
  }) async {
    final response = await catNodeattrsWithHttpInfo(
      format: format,
      local: local,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      h: h,
      help: help,
      s: s,
      v: v,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns basic statistics about performance of cluster nodes.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [Bytes] bytes:
  ///   The unit in which to display byte values.
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] fullId:
  ///   Return the full node ID instead of the shortened version.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [Time] time:
  ///   The unit in which to display time values.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<Response> catNodesWithHttpInfo({
    Bytes? bytes,
    String? format,
    bool? fullId,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    Time? time,
    bool? v,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/nodes';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (bytes != null) {
      queryParams.addAll(_queryParams('', 'bytes', bytes));
    }
    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (fullId != null) {
      queryParams.addAll(_queryParams('', 'full_id', fullId));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (time != null) {
      queryParams.addAll(_queryParams('', 'time', time));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns basic statistics about performance of cluster nodes.
  ///
  /// Parameters:
  ///
  /// * [Bytes] bytes:
  ///   The unit in which to display byte values.
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] fullId:
  ///   Return the full node ID instead of the shortened version.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [Time] time:
  ///   The unit in which to display time values.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<void> catNodes({
    Bytes? bytes,
    String? format,
    bool? fullId,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    Time? time,
    bool? v,
  }) async {
    final response = await catNodesWithHttpInfo(
      bytes: bytes,
      format: format,
      fullId: fullId,
      local: local,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      h: h,
      help: help,
      s: s,
      time: time,
      v: v,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns a concise representation of the cluster pending tasks.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [Time] time:
  ///   The unit in which to display time values.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<Response> catPendingTasksWithHttpInfo({
    String? format,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    Time? time,
    bool? v,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/pending_tasks';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (time != null) {
      queryParams.addAll(_queryParams('', 'time', time));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns a concise representation of the cluster pending tasks.
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [Time] time:
  ///   The unit in which to display time values.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<void> catPendingTasks({
    String? format,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    Time? time,
    bool? v,
  }) async {
    final response = await catPendingTasksWithHttpInfo(
      format: format,
      local: local,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      h: h,
      help: help,
      s: s,
      time: time,
      v: v,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// List segments for one or several PITs.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [CatPitSegmentsBodyParams] catPitSegmentsBodyParams:
  Future<Response> catPitSegmentsWithHttpInfo({
    CatPitSegmentsBodyParams? catPitSegmentsBodyParams,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/pit_segments';

    // ignore: prefer_final_locals
    Object? postBody = catPitSegmentsBodyParams;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// List segments for one or several PITs.
  ///
  /// Parameters:
  ///
  /// * [CatPitSegmentsBodyParams] catPitSegmentsBodyParams:
  Future<CatPitSegmentsResponseContent?> catPitSegments({
    CatPitSegmentsBodyParams? catPitSegmentsBodyParams,
  }) async {
    final response = await catPitSegmentsWithHttpInfo(
      catPitSegmentsBodyParams: catPitSegmentsBodyParams,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'CatPitSegmentsResponseContent',
      ) as CatPitSegmentsResponseContent;
    }
    return null;
  }

  /// Returns information about installed plugins across nodes node.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<Response> catPluginsWithHttpInfo({
    String? format,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/plugins';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about installed plugins across nodes node.
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<void> catPlugins({
    String? format,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
  }) async {
    final response = await catPluginsWithHttpInfo(
      format: format,
      local: local,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      h: h,
      help: help,
      s: s,
      v: v,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about index shard recoveries, both on-going completed.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] activeOnly:
  ///   If `true`, the response only includes ongoing shard recoveries.
  ///
  /// * [Bytes] bytes:
  ///   The unit in which to display byte values.
  ///
  /// * [bool] detailed:
  ///   If `true`, the response includes detailed information about shard recoveries.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] index:
  ///   Comma-separated list or wildcard expression of index names to limit the returned information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [Time] time:
  ///   The unit in which to display time values.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<Response> catRecoveryWithHttpInfo({
    String? format,
    bool? activeOnly,
    Bytes? bytes,
    bool? detailed,
    List<String>? h,
    bool? help,
    List<String>? index,
    List<String>? s,
    Time? time,
    bool? v,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/recovery';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (activeOnly != null) {
      queryParams.addAll(_queryParams('', 'active_only', activeOnly));
    }
    if (bytes != null) {
      queryParams.addAll(_queryParams('', 'bytes', bytes));
    }
    if (detailed != null) {
      queryParams.addAll(_queryParams('', 'detailed', detailed));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (index != null) {
      queryParams.addAll(_queryParams('multi', 'index', index));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (time != null) {
      queryParams.addAll(_queryParams('', 'time', time));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about index shard recoveries, both on-going completed.
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] activeOnly:
  ///   If `true`, the response only includes ongoing shard recoveries.
  ///
  /// * [Bytes] bytes:
  ///   The unit in which to display byte values.
  ///
  /// * [bool] detailed:
  ///   If `true`, the response includes detailed information about shard recoveries.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] index:
  ///   Comma-separated list or wildcard expression of index names to limit the returned information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [Time] time:
  ///   The unit in which to display time values.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<void> catRecovery({
    String? format,
    bool? activeOnly,
    Bytes? bytes,
    bool? detailed,
    List<String>? h,
    bool? help,
    List<String>? index,
    List<String>? s,
    Time? time,
    bool? v,
  }) async {
    final response = await catRecoveryWithHttpInfo(
      format: format,
      activeOnly: activeOnly,
      bytes: bytes,
      detailed: detailed,
      h: h,
      help: help,
      index: index,
      s: s,
      time: time,
      v: v,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about index shard recoveries, both on-going completed.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list or wildcard expression of index names to limit the returned information.
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] activeOnly:
  ///   If `true`, the response only includes ongoing shard recoveries.
  ///
  /// * [Bytes] bytes:
  ///   The unit in which to display byte values.
  ///
  /// * [bool] detailed:
  ///   If `true`, the response includes detailed information about shard recoveries.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] index2:
  ///   Comma-separated list or wildcard expression of index names to limit the returned information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [Time] time:
  ///   The unit in which to display time values.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<Response> catRecoveryWithIndexWithHttpInfo(
    String index, {
    String? format,
    bool? activeOnly,
    Bytes? bytes,
    bool? detailed,
    List<String>? h,
    bool? help,
    List<String>? index2,
    List<String>? s,
    Time? time,
    bool? v,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/recovery/{index}'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (activeOnly != null) {
      queryParams.addAll(_queryParams('', 'active_only', activeOnly));
    }
    if (bytes != null) {
      queryParams.addAll(_queryParams('', 'bytes', bytes));
    }
    if (detailed != null) {
      queryParams.addAll(_queryParams('', 'detailed', detailed));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (index2 != null) {
      queryParams.addAll(_queryParams('multi', 'index', index2));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (time != null) {
      queryParams.addAll(_queryParams('', 'time', time));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about index shard recoveries, both on-going completed.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list or wildcard expression of index names to limit the returned information.
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] activeOnly:
  ///   If `true`, the response only includes ongoing shard recoveries.
  ///
  /// * [Bytes] bytes:
  ///   The unit in which to display byte values.
  ///
  /// * [bool] detailed:
  ///   If `true`, the response includes detailed information about shard recoveries.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] index2:
  ///   Comma-separated list or wildcard expression of index names to limit the returned information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [Time] time:
  ///   The unit in which to display time values.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<void> catRecoveryWithIndex(
    String index, {
    String? format,
    bool? activeOnly,
    Bytes? bytes,
    bool? detailed,
    List<String>? h,
    bool? help,
    List<String>? index2,
    List<String>? s,
    Time? time,
    bool? v,
  }) async {
    final response = await catRecoveryWithIndexWithHttpInfo(
      index,
      format: format,
      activeOnly: activeOnly,
      bytes: bytes,
      detailed: detailed,
      h: h,
      help: help,
      index2: index2,
      s: s,
      time: time,
      v: v,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about snapshot repositories registered in the cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<Response> catRepositoriesWithHttpInfo({
    String? format,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/repositories';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about snapshot repositories registered in the cluster.
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<void> catRepositories({
    String? format,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
  }) async {
    final response = await catRepositoriesWithHttpInfo(
      format: format,
      local: local,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      h: h,
      help: help,
      s: s,
      v: v,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about both on-going and latest completed Segment Replication events.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] activeOnly:
  ///   If `true`, the response only includes ongoing segment replication events.
  ///
  /// * [bool] completedOnly:
  ///   If `true`, the response only includes latest completed segment replication events.
  ///
  /// * [Bytes] bytes:
  ///   The unit in which to display byte values.
  ///
  /// * [bool] detailed:
  ///   If `true`, the response includes detailed information about segment replications.
  ///
  /// * [List<String>] shards:
  ///   Comma-separated list of shards to display.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] index:
  ///   Comma-separated list or wildcard expression of index names to limit the returned information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [Time] time:
  ///   The unit in which to display time values.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<Response> catSegmentReplicationWithHttpInfo({
    String? format,
    bool? activeOnly,
    bool? completedOnly,
    Bytes? bytes,
    bool? detailed,
    List<String>? shards,
    List<String>? h,
    bool? help,
    List<String>? index,
    List<String>? s,
    Time? time,
    bool? v,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/segment_replication';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (activeOnly != null) {
      queryParams.addAll(_queryParams('', 'active_only', activeOnly));
    }
    if (completedOnly != null) {
      queryParams.addAll(_queryParams('', 'completed_only', completedOnly));
    }
    if (bytes != null) {
      queryParams.addAll(_queryParams('', 'bytes', bytes));
    }
    if (detailed != null) {
      queryParams.addAll(_queryParams('', 'detailed', detailed));
    }
    if (shards != null) {
      queryParams.addAll(_queryParams('multi', 'shards', shards));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (index != null) {
      queryParams.addAll(_queryParams('multi', 'index', index));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (time != null) {
      queryParams.addAll(_queryParams('', 'time', time));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about both on-going and latest completed Segment Replication events.
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] activeOnly:
  ///   If `true`, the response only includes ongoing segment replication events.
  ///
  /// * [bool] completedOnly:
  ///   If `true`, the response only includes latest completed segment replication events.
  ///
  /// * [Bytes] bytes:
  ///   The unit in which to display byte values.
  ///
  /// * [bool] detailed:
  ///   If `true`, the response includes detailed information about segment replications.
  ///
  /// * [List<String>] shards:
  ///   Comma-separated list of shards to display.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] index:
  ///   Comma-separated list or wildcard expression of index names to limit the returned information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [Time] time:
  ///   The unit in which to display time values.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<void> catSegmentReplication({
    String? format,
    bool? activeOnly,
    bool? completedOnly,
    Bytes? bytes,
    bool? detailed,
    List<String>? shards,
    List<String>? h,
    bool? help,
    List<String>? index,
    List<String>? s,
    Time? time,
    bool? v,
  }) async {
    final response = await catSegmentReplicationWithHttpInfo(
      format: format,
      activeOnly: activeOnly,
      completedOnly: completedOnly,
      bytes: bytes,
      detailed: detailed,
      shards: shards,
      h: h,
      help: help,
      index: index,
      s: s,
      time: time,
      v: v,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about both on-going and latest completed Segment Replication events.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list or wildcard expression of index names to limit the returned information.
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] activeOnly:
  ///   If `true`, the response only includes ongoing segment replication events.
  ///
  /// * [bool] completedOnly:
  ///   If `true`, the response only includes latest completed segment replication events.
  ///
  /// * [Bytes] bytes:
  ///   The unit in which to display byte values.
  ///
  /// * [bool] detailed:
  ///   If `true`, the response includes detailed information about segment replications.
  ///
  /// * [List<String>] shards:
  ///   Comma-separated list of shards to display.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] index2:
  ///   Comma-separated list or wildcard expression of index names to limit the returned information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [Time] time:
  ///   The unit in which to display time values.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<Response> catSegmentReplicationWithIndexWithHttpInfo(
    String index, {
    String? format,
    bool? activeOnly,
    bool? completedOnly,
    Bytes? bytes,
    bool? detailed,
    List<String>? shards,
    List<String>? h,
    bool? help,
    List<String>? index2,
    List<String>? s,
    Time? time,
    bool? v,
  }) async {
    // ignore: prefer_const_declarations
    final path =
        r'/_cat/segment_replication/{index}'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (activeOnly != null) {
      queryParams.addAll(_queryParams('', 'active_only', activeOnly));
    }
    if (completedOnly != null) {
      queryParams.addAll(_queryParams('', 'completed_only', completedOnly));
    }
    if (bytes != null) {
      queryParams.addAll(_queryParams('', 'bytes', bytes));
    }
    if (detailed != null) {
      queryParams.addAll(_queryParams('', 'detailed', detailed));
    }
    if (shards != null) {
      queryParams.addAll(_queryParams('multi', 'shards', shards));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (index2 != null) {
      queryParams.addAll(_queryParams('multi', 'index', index2));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (time != null) {
      queryParams.addAll(_queryParams('', 'time', time));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about both on-going and latest completed Segment Replication events.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list or wildcard expression of index names to limit the returned information.
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] activeOnly:
  ///   If `true`, the response only includes ongoing segment replication events.
  ///
  /// * [bool] completedOnly:
  ///   If `true`, the response only includes latest completed segment replication events.
  ///
  /// * [Bytes] bytes:
  ///   The unit in which to display byte values.
  ///
  /// * [bool] detailed:
  ///   If `true`, the response includes detailed information about segment replications.
  ///
  /// * [List<String>] shards:
  ///   Comma-separated list of shards to display.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] index2:
  ///   Comma-separated list or wildcard expression of index names to limit the returned information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [Time] time:
  ///   The unit in which to display time values.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<void> catSegmentReplicationWithIndex(
    String index, {
    String? format,
    bool? activeOnly,
    bool? completedOnly,
    Bytes? bytes,
    bool? detailed,
    List<String>? shards,
    List<String>? h,
    bool? help,
    List<String>? index2,
    List<String>? s,
    Time? time,
    bool? v,
  }) async {
    final response = await catSegmentReplicationWithIndexWithHttpInfo(
      index,
      format: format,
      activeOnly: activeOnly,
      completedOnly: completedOnly,
      bytes: bytes,
      detailed: detailed,
      shards: shards,
      h: h,
      help: help,
      index2: index2,
      s: s,
      time: time,
      v: v,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Provides low-level information about the segments in the shards of an index.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [Bytes] bytes:
  ///   The unit in which to display byte values.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<Response> catSegmentsWithHttpInfo({
    String? format,
    Bytes? bytes,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/segments';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (bytes != null) {
      queryParams.addAll(_queryParams('', 'bytes', bytes));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Provides low-level information about the segments in the shards of an index.
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [Bytes] bytes:
  ///   The unit in which to display byte values.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<void> catSegments({
    String? format,
    Bytes? bytes,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
  }) async {
    final response = await catSegmentsWithHttpInfo(
      format: format,
      bytes: bytes,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      h: h,
      help: help,
      s: s,
      v: v,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Provides low-level information about the segments in the shards of an index.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to limit the returned information.
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [Bytes] bytes:
  ///   The unit in which to display byte values.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<Response> catSegmentsWithIndexWithHttpInfo(
    String index, {
    String? format,
    Bytes? bytes,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/segments/{index}'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (bytes != null) {
      queryParams.addAll(_queryParams('', 'bytes', bytes));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Provides low-level information about the segments in the shards of an index.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to limit the returned information.
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [Bytes] bytes:
  ///   The unit in which to display byte values.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<void> catSegmentsWithIndex(
    String index, {
    String? format,
    Bytes? bytes,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
  }) async {
    final response = await catSegmentsWithIndexWithHttpInfo(
      index,
      format: format,
      bytes: bytes,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      h: h,
      help: help,
      s: s,
      v: v,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Provides a detailed view of shard allocation on nodes.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [Bytes] bytes:
  ///   The unit in which to display byte values.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [Time] time:
  ///   The unit in which to display time values.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<Response> catShardsWithHttpInfo({
    String? format,
    Bytes? bytes,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    Time? time,
    bool? v,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/shards';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (bytes != null) {
      queryParams.addAll(_queryParams('', 'bytes', bytes));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (time != null) {
      queryParams.addAll(_queryParams('', 'time', time));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Provides a detailed view of shard allocation on nodes.
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [Bytes] bytes:
  ///   The unit in which to display byte values.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [Time] time:
  ///   The unit in which to display time values.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<void> catShards({
    String? format,
    Bytes? bytes,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    Time? time,
    bool? v,
  }) async {
    final response = await catShardsWithHttpInfo(
      format: format,
      bytes: bytes,
      local: local,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      h: h,
      help: help,
      s: s,
      time: time,
      v: v,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Provides a detailed view of shard allocation on nodes.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to limit the returned information.
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [Bytes] bytes:
  ///   The unit in which to display byte values.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [Time] time:
  ///   The unit in which to display time values.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<Response> catShardsWithIndexWithHttpInfo(
    String index, {
    String? format,
    Bytes? bytes,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    Time? time,
    bool? v,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/shards/{index}'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (bytes != null) {
      queryParams.addAll(_queryParams('', 'bytes', bytes));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (time != null) {
      queryParams.addAll(_queryParams('', 'time', time));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Provides a detailed view of shard allocation on nodes.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to limit the returned information.
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [Bytes] bytes:
  ///   The unit in which to display byte values.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [Time] time:
  ///   The unit in which to display time values.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<void> catShardsWithIndex(
    String index, {
    String? format,
    Bytes? bytes,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    Time? time,
    bool? v,
  }) async {
    final response = await catShardsWithIndexWithHttpInfo(
      index,
      format: format,
      bytes: bytes,
      local: local,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      h: h,
      help: help,
      s: s,
      time: time,
      v: v,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns all snapshots in a specific repository.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [Time] time:
  ///   The unit in which to display time values.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<Response> catSnapshotsWithHttpInfo({
    String? format,
    bool? ignoreUnavailable,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    Time? time,
    bool? v,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/snapshots';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (time != null) {
      queryParams.addAll(_queryParams('', 'time', time));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns all snapshots in a specific repository.
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [Time] time:
  ///   The unit in which to display time values.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<void> catSnapshots({
    String? format,
    bool? ignoreUnavailable,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    Time? time,
    bool? v,
  }) async {
    final response = await catSnapshotsWithHttpInfo(
      format: format,
      ignoreUnavailable: ignoreUnavailable,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      h: h,
      help: help,
      s: s,
      time: time,
      v: v,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns all snapshots in a specific repository.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] repository (required):
  ///   Comma-separated list of repository names.
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [Time] time:
  ///   The unit in which to display time values.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<Response> catSnapshotsWithRepositoryWithHttpInfo(
    String repository, {
    String? format,
    bool? ignoreUnavailable,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    Time? time,
    bool? v,
  }) async {
    // ignore: prefer_const_declarations
    final path =
        r'/_cat/snapshots/{repository}'.replaceAll('{repository}', repository);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (time != null) {
      queryParams.addAll(_queryParams('', 'time', time));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns all snapshots in a specific repository.
  ///
  /// Parameters:
  ///
  /// * [String] repository (required):
  ///   Comma-separated list of repository names.
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [Time] time:
  ///   The unit in which to display time values.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<void> catSnapshotsWithRepository(
    String repository, {
    String? format,
    bool? ignoreUnavailable,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    Time? time,
    bool? v,
  }) async {
    final response = await catSnapshotsWithRepositoryWithHttpInfo(
      repository,
      format: format,
      ignoreUnavailable: ignoreUnavailable,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      h: h,
      help: help,
      s: s,
      time: time,
      v: v,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about the tasks currently executing on one or more nodes in the cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [List<String>] nodes:
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [List<String>] actions:
  ///   Comma-separated list of actions that should be returned. Leave empty to return all.
  ///
  /// * [bool] detailed:
  ///   Return detailed task information.
  ///
  /// * [String] parentTaskId:
  ///   Return tasks with specified parent task id (node_id:task_number). Set to -1 to return all.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [Time] time:
  ///   The unit in which to display time values.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<Response> catTasksWithHttpInfo({
    String? format,
    List<String>? nodes,
    List<String>? actions,
    bool? detailed,
    String? parentTaskId,
    List<String>? h,
    bool? help,
    List<String>? s,
    Time? time,
    bool? v,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/tasks';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (nodes != null) {
      queryParams.addAll(_queryParams('multi', 'nodes', nodes));
    }
    if (actions != null) {
      queryParams.addAll(_queryParams('multi', 'actions', actions));
    }
    if (detailed != null) {
      queryParams.addAll(_queryParams('', 'detailed', detailed));
    }
    if (parentTaskId != null) {
      queryParams.addAll(_queryParams('', 'parent_task_id', parentTaskId));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (time != null) {
      queryParams.addAll(_queryParams('', 'time', time));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about the tasks currently executing on one or more nodes in the cluster.
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [List<String>] nodes:
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [List<String>] actions:
  ///   Comma-separated list of actions that should be returned. Leave empty to return all.
  ///
  /// * [bool] detailed:
  ///   Return detailed task information.
  ///
  /// * [String] parentTaskId:
  ///   Return tasks with specified parent task id (node_id:task_number). Set to -1 to return all.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [Time] time:
  ///   The unit in which to display time values.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<void> catTasks({
    String? format,
    List<String>? nodes,
    List<String>? actions,
    bool? detailed,
    String? parentTaskId,
    List<String>? h,
    bool? help,
    List<String>? s,
    Time? time,
    bool? v,
  }) async {
    final response = await catTasksWithHttpInfo(
      format: format,
      nodes: nodes,
      actions: actions,
      detailed: detailed,
      parentTaskId: parentTaskId,
      h: h,
      help: help,
      s: s,
      time: time,
      v: v,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about existing templates.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<Response> catTemplatesWithHttpInfo({
    String? format,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/templates';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about existing templates.
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<void> catTemplates({
    String? format,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
  }) async {
    final response = await catTemplatesWithHttpInfo(
      format: format,
      local: local,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      h: h,
      help: help,
      s: s,
      v: v,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about existing templates.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The name of the template.
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<Response> catTemplatesWithNameWithHttpInfo(
    String name, {
    String? format,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/templates/{name}'.replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about existing templates.
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The name of the template.
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<void> catTemplatesWithName(
    String name, {
    String? format,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
  }) async {
    final response = await catTemplatesWithNameWithHttpInfo(
      name,
      format: format,
      local: local,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      h: h,
      help: help,
      s: s,
      v: v,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns cluster-wide thread pool statistics per node. By default the active, queue and rejected statistics are returned for all thread pools.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [int] size:
  ///   The multiplier in which to display values.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<Response> catThreadPoolWithHttpInfo({
    String? format,
    int? size,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/thread_pool';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (size != null) {
      queryParams.addAll(_queryParams('', 'size', size));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns cluster-wide thread pool statistics per node. By default the active, queue and rejected statistics are returned for all thread pools.
  ///
  /// Parameters:
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [int] size:
  ///   The multiplier in which to display values.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<void> catThreadPool({
    String? format,
    int? size,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
  }) async {
    final response = await catThreadPoolWithHttpInfo(
      format: format,
      size: size,
      local: local,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      h: h,
      help: help,
      s: s,
      v: v,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns cluster-wide thread pool statistics per node. By default the active, queue and rejected statistics are returned for all thread pools.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] threadPoolPatterns (required):
  ///   Comma-separated list of regular-expressions to filter the thread pools in the output.
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [int] size:
  ///   The multiplier in which to display values.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<Response> catThreadPoolWithThreadPoolPatternsWithHttpInfo(
    String threadPoolPatterns, {
    String? format,
    int? size,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cat/thread_pool/{thread_pool_patterns}'
        .replaceAll('{thread_pool_patterns}', threadPoolPatterns);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (format != null) {
      queryParams.addAll(_queryParams('', 'format', format));
    }
    if (size != null) {
      queryParams.addAll(_queryParams('', 'size', size));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (h != null) {
      queryParams.addAll(_queryParams('multi', 'h', h));
    }
    if (help != null) {
      queryParams.addAll(_queryParams('', 'help', help));
    }
    if (s != null) {
      queryParams.addAll(_queryParams('multi', 's', s));
    }
    if (v != null) {
      queryParams.addAll(_queryParams('', 'v', v));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns cluster-wide thread pool statistics per node. By default the active, queue and rejected statistics are returned for all thread pools.
  ///
  /// Parameters:
  ///
  /// * [String] threadPoolPatterns (required):
  ///   Comma-separated list of regular-expressions to filter the thread pools in the output.
  ///
  /// * [String] format:
  ///   A short version of the Accept header, e.g. json, yaml.
  ///
  /// * [int] size:
  ///   The multiplier in which to display values.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [List<String>] h:
  ///   Comma-separated list of column names to display.
  ///
  /// * [bool] help:
  ///   Return help information.
  ///
  /// * [List<String>] s:
  ///   Comma-separated list of column names or column aliases to sort by.
  ///
  /// * [bool] v:
  ///   Verbose mode. Display column headers.
  Future<void> catThreadPoolWithThreadPoolPatterns(
    String threadPoolPatterns, {
    String? format,
    int? size,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    List<String>? h,
    bool? help,
    List<String>? s,
    bool? v,
  }) async {
    final response = await catThreadPoolWithThreadPoolPatternsWithHttpInfo(
      threadPoolPatterns,
      format: format,
      size: size,
      local: local,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      h: h,
      help: help,
      s: s,
      v: v,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Changes the password for the current user.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [ChangePasswordRequestContent] changePasswordRequestContent (required):
  Future<Response> changePasswordWithHttpInfo(
    ChangePasswordRequestContent changePasswordRequestContent,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/account';

    // ignore: prefer_final_locals
    Object? postBody = changePasswordRequestContent;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Changes the password for the current user.
  ///
  /// Parameters:
  ///
  /// * [ChangePasswordRequestContent] changePasswordRequestContent (required):
  Future<ChangePasswordResponseContent?> changePassword(
    ChangePasswordRequestContent changePasswordRequestContent,
  ) async {
    final response = await changePasswordWithHttpInfo(
      changePasswordRequestContent,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'ChangePasswordResponseContent',
      ) as ChangePasswordResponseContent;
    }
    return null;
  }

  /// Explicitly clears the search context for a scroll.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [Object] body:
  Future<Response> clearScrollWithHttpInfo({
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_search/scroll';

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'DELETE',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Explicitly clears the search context for a scroll.
  ///
  /// Parameters:
  ///
  /// * [Object] body:
  Future<void> clearScroll({
    Object? body,
  }) async {
    final response = await clearScrollWithHttpInfo(
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Explicitly clears the search context for a scroll.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] scrollId (required):
  ///   Comma-separated list of scroll IDs to clear.
  ///
  /// * [Object] body:
  Future<Response> clearScrollWithScrollIdWithHttpInfo(
    String scrollId, {
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path =
        r'/_search/scroll/{scroll_id}'.replaceAll('{scroll_id}', scrollId);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'DELETE',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Explicitly clears the search context for a scroll.
  ///
  /// Parameters:
  ///
  /// * [String] scrollId (required):
  ///   Comma-separated list of scroll IDs to clear.
  ///
  /// * [Object] body:
  Future<void> clearScrollWithScrollId(
    String scrollId, {
    Object? body,
  }) async {
    final response = await clearScrollWithScrollIdWithHttpInfo(
      scrollId,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Provides explanations for shard allocations in the cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] includeYesDecisions:
  ///   Return 'YES' decisions in explanation.
  ///
  /// * [bool] includeDiskInfo:
  ///   Return information about disk usage and shard sizes.
  Future<Response> clusterAllocationExplainGetWithHttpInfo({
    bool? includeYesDecisions,
    bool? includeDiskInfo,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cluster/allocation/explain';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (includeYesDecisions != null) {
      queryParams.addAll(
          _queryParams('', 'include_yes_decisions', includeYesDecisions));
    }
    if (includeDiskInfo != null) {
      queryParams
          .addAll(_queryParams('', 'include_disk_info', includeDiskInfo));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Provides explanations for shard allocations in the cluster.
  ///
  /// Parameters:
  ///
  /// * [bool] includeYesDecisions:
  ///   Return 'YES' decisions in explanation.
  ///
  /// * [bool] includeDiskInfo:
  ///   Return information about disk usage and shard sizes.
  Future<void> clusterAllocationExplainGet({
    bool? includeYesDecisions,
    bool? includeDiskInfo,
  }) async {
    final response = await clusterAllocationExplainGetWithHttpInfo(
      includeYesDecisions: includeYesDecisions,
      includeDiskInfo: includeDiskInfo,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Provides explanations for shard allocations in the cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] includeYesDecisions:
  ///   Return 'YES' decisions in explanation.
  ///
  /// * [bool] includeDiskInfo:
  ///   Return information about disk usage and shard sizes.
  ///
  /// * [Object] body:
  Future<Response> clusterAllocationExplainPostWithHttpInfo({
    bool? includeYesDecisions,
    bool? includeDiskInfo,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cluster/allocation/explain';

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (includeYesDecisions != null) {
      queryParams.addAll(
          _queryParams('', 'include_yes_decisions', includeYesDecisions));
    }
    if (includeDiskInfo != null) {
      queryParams
          .addAll(_queryParams('', 'include_disk_info', includeDiskInfo));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Provides explanations for shard allocations in the cluster.
  ///
  /// Parameters:
  ///
  /// * [bool] includeYesDecisions:
  ///   Return 'YES' decisions in explanation.
  ///
  /// * [bool] includeDiskInfo:
  ///   Return information about disk usage and shard sizes.
  ///
  /// * [Object] body:
  Future<void> clusterAllocationExplainPost({
    bool? includeYesDecisions,
    bool? includeDiskInfo,
    Object? body,
  }) async {
    final response = await clusterAllocationExplainPostWithHttpInfo(
      includeYesDecisions: includeYesDecisions,
      includeDiskInfo: includeDiskInfo,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Deletes a component template.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The name of the template.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<Response> clusterDeleteComponentTemplateWithHttpInfo(
    String name, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_component_template/{name}'.replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'DELETE',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Deletes a component template.
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The name of the template.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<void> clusterDeleteComponentTemplate(
    String name, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    final response = await clusterDeleteComponentTemplateWithHttpInfo(
      name,
      timeout: timeout,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Delete any existing decommission.
  ///
  /// Note: This method returns the HTTP [Response].
  Future<Response> clusterDeleteDecommissionAwarenessWithHttpInfo() async {
    // ignore: prefer_const_declarations
    final path = r'/_cluster/decommission/awareness/';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'DELETE',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Delete any existing decommission.
  Future<void> clusterDeleteDecommissionAwareness() async {
    final response = await clusterDeleteDecommissionAwarenessWithHttpInfo();
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Clears cluster voting config exclusions.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] waitForRemoval:
  ///   Specifies whether to wait for all excluded nodes to be removed from the cluster before clearing the voting configuration exclusions list.
  Future<Response> clusterDeleteVotingConfigExclusionsWithHttpInfo({
    bool? waitForRemoval,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cluster/voting_config_exclusions';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (waitForRemoval != null) {
      queryParams.addAll(_queryParams('', 'wait_for_removal', waitForRemoval));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'DELETE',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Clears cluster voting config exclusions.
  ///
  /// Parameters:
  ///
  /// * [bool] waitForRemoval:
  ///   Specifies whether to wait for all excluded nodes to be removed from the cluster before clearing the voting configuration exclusions list.
  Future<void> clusterDeleteVotingConfigExclusions({
    bool? waitForRemoval,
  }) async {
    final response = await clusterDeleteVotingConfigExclusionsWithHttpInfo(
      waitForRemoval: waitForRemoval,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Delete weighted shard routing weights.
  ///
  /// Note: This method returns the HTTP [Response].
  Future<Response> clusterDeleteWeightedRoutingWithHttpInfo() async {
    // ignore: prefer_const_declarations
    final path = r'/_cluster/routing/awareness/weights';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'DELETE',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Delete weighted shard routing weights.
  Future<void> clusterDeleteWeightedRouting() async {
    final response = await clusterDeleteWeightedRoutingWithHttpInfo();
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about whether a particular component template exist.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The name of the template.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<Response> clusterExistsComponentTemplateWithHttpInfo(
    String name, {
    String? masterTimeout,
    bool? local,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_component_template/{name}'.replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'HEAD',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about whether a particular component template exist.
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The name of the template.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<void> clusterExistsComponentTemplate(
    String name, {
    String? masterTimeout,
    bool? local,
  }) async {
    final response = await clusterExistsComponentTemplateWithHttpInfo(
      name,
      masterTimeout: masterTimeout,
      local: local,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns one or more component templates.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<Response> clusterGetComponentTemplateWithHttpInfo({
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? local,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_component_template';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns one or more component templates.
  ///
  /// Parameters:
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<void> clusterGetComponentTemplate({
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? local,
  }) async {
    final response = await clusterGetComponentTemplateWithHttpInfo(
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      local: local,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns one or more component templates.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The Comma-separated names of the component templates.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<Response> clusterGetComponentTemplateWithNameWithHttpInfo(
    String name, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? local,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_component_template/{name}'.replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns one or more component templates.
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The Comma-separated names of the component templates.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<void> clusterGetComponentTemplateWithName(
    String name, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? local,
  }) async {
    final response = await clusterGetComponentTemplateWithNameWithHttpInfo(
      name,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      local: local,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Get details and status of decommissioned attribute.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] awarenessAttributeName (required):
  ///   Awareness attribute name.
  Future<Response> clusterGetDecommissionAwarenessWithHttpInfo(
    String awarenessAttributeName,
  ) async {
    // ignore: prefer_const_declarations
    final path =
        r'/_cluster/decommission/awareness/{awareness_attribute_name}/_status'
            .replaceAll('{awareness_attribute_name}', awarenessAttributeName);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Get details and status of decommissioned attribute.
  ///
  /// Parameters:
  ///
  /// * [String] awarenessAttributeName (required):
  ///   Awareness attribute name.
  Future<void> clusterGetDecommissionAwareness(
    String awarenessAttributeName,
  ) async {
    final response = await clusterGetDecommissionAwarenessWithHttpInfo(
      awarenessAttributeName,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns cluster settings.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] includeDefaults:
  ///   Whether to return all default clusters setting.
  Future<Response> clusterGetSettingsWithHttpInfo({
    bool? flatSettings,
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? timeout,
    bool? includeDefaults,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cluster/settings';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (flatSettings != null) {
      queryParams.addAll(_queryParams('', 'flat_settings', flatSettings));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (includeDefaults != null) {
      queryParams.addAll(_queryParams('', 'include_defaults', includeDefaults));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns cluster settings.
  ///
  /// Parameters:
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] includeDefaults:
  ///   Whether to return all default clusters setting.
  Future<ClusterGetSettingsResponseContent?> clusterGetSettings({
    bool? flatSettings,
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? timeout,
    bool? includeDefaults,
  }) async {
    final response = await clusterGetSettingsWithHttpInfo(
      flatSettings: flatSettings,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      timeout: timeout,
      includeDefaults: includeDefaults,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'ClusterGetSettingsResponseContent',
      ) as ClusterGetSettingsResponseContent;
    }
    return null;
  }

  /// Fetches weighted shard routing weights.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] attribute (required):
  ///   Awareness attribute name.
  Future<Response> clusterGetWeightedRoutingWithHttpInfo(
    String attribute,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_cluster/routing/awareness/{attribute}/weights'
        .replaceAll('{attribute}', attribute);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Fetches weighted shard routing weights.
  ///
  /// Parameters:
  ///
  /// * [String] attribute (required):
  ///   Awareness attribute name.
  Future<void> clusterGetWeightedRouting(
    String attribute,
  ) async {
    final response = await clusterGetWeightedRoutingWithHttpInfo(
      attribute,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns basic information about the health of the cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [ClusterHealthLevel] level:
  ///   Specify the level of detail for returned information.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] waitForActiveShards:
  ///   Wait until the specified number of shards is active.
  ///
  /// * [String] waitForNodes:
  ///   Wait until the specified number of nodes is available.
  ///
  /// * [WaitForEvents] waitForEvents:
  ///   Wait until all currently queued events with the given priority are processed.
  ///
  /// * [bool] waitForNoRelocatingShards:
  ///   Whether to wait until there are no relocating shards in the cluster.
  ///
  /// * [bool] waitForNoInitializingShards:
  ///   Whether to wait until there are no initializing shards in the cluster.
  ///
  /// * [WaitForStatus] waitForStatus:
  ///   Wait until cluster is in a specific state.
  ///
  /// * [String] awarenessAttribute:
  ///   The awareness attribute for which the health is required.
  ///
  /// * [bool] ensureNodeCommissioned:
  ///   Checks whether local node is commissioned or not. If set to true on a local call it will throw exception if node is decommissioned.
  Future<Response> clusterHealthWithHttpInfo({
    ExpandWildcards? expandWildcards,
    ClusterHealthLevel? level,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? timeout,
    String? waitForActiveShards,
    String? waitForNodes,
    WaitForEvents? waitForEvents,
    bool? waitForNoRelocatingShards,
    bool? waitForNoInitializingShards,
    WaitForStatus? waitForStatus,
    String? awarenessAttribute,
    bool? ensureNodeCommissioned,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cluster/health';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (level != null) {
      queryParams.addAll(_queryParams('', 'level', level));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (waitForActiveShards != null) {
      queryParams.addAll(
          _queryParams('', 'wait_for_active_shards', waitForActiveShards));
    }
    if (waitForNodes != null) {
      queryParams.addAll(_queryParams('', 'wait_for_nodes', waitForNodes));
    }
    if (waitForEvents != null) {
      queryParams.addAll(_queryParams('', 'wait_for_events', waitForEvents));
    }
    if (waitForNoRelocatingShards != null) {
      queryParams.addAll(_queryParams(
          '', 'wait_for_no_relocating_shards', waitForNoRelocatingShards));
    }
    if (waitForNoInitializingShards != null) {
      queryParams.addAll(_queryParams(
          '', 'wait_for_no_initializing_shards', waitForNoInitializingShards));
    }
    if (waitForStatus != null) {
      queryParams.addAll(_queryParams('', 'wait_for_status', waitForStatus));
    }
    if (awarenessAttribute != null) {
      queryParams
          .addAll(_queryParams('', 'awareness_attribute', awarenessAttribute));
    }
    if (ensureNodeCommissioned != null) {
      queryParams.addAll(
          _queryParams('', 'ensure_node_commissioned', ensureNodeCommissioned));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns basic information about the health of the cluster.
  ///
  /// Parameters:
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [ClusterHealthLevel] level:
  ///   Specify the level of detail for returned information.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] waitForActiveShards:
  ///   Wait until the specified number of shards is active.
  ///
  /// * [String] waitForNodes:
  ///   Wait until the specified number of nodes is available.
  ///
  /// * [WaitForEvents] waitForEvents:
  ///   Wait until all currently queued events with the given priority are processed.
  ///
  /// * [bool] waitForNoRelocatingShards:
  ///   Whether to wait until there are no relocating shards in the cluster.
  ///
  /// * [bool] waitForNoInitializingShards:
  ///   Whether to wait until there are no initializing shards in the cluster.
  ///
  /// * [WaitForStatus] waitForStatus:
  ///   Wait until cluster is in a specific state.
  ///
  /// * [String] awarenessAttribute:
  ///   The awareness attribute for which the health is required.
  ///
  /// * [bool] ensureNodeCommissioned:
  ///   Checks whether local node is commissioned or not. If set to true on a local call it will throw exception if node is decommissioned.
  Future<void> clusterHealth({
    ExpandWildcards? expandWildcards,
    ClusterHealthLevel? level,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? timeout,
    String? waitForActiveShards,
    String? waitForNodes,
    WaitForEvents? waitForEvents,
    bool? waitForNoRelocatingShards,
    bool? waitForNoInitializingShards,
    WaitForStatus? waitForStatus,
    String? awarenessAttribute,
    bool? ensureNodeCommissioned,
  }) async {
    final response = await clusterHealthWithHttpInfo(
      expandWildcards: expandWildcards,
      level: level,
      local: local,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      timeout: timeout,
      waitForActiveShards: waitForActiveShards,
      waitForNodes: waitForNodes,
      waitForEvents: waitForEvents,
      waitForNoRelocatingShards: waitForNoRelocatingShards,
      waitForNoInitializingShards: waitForNoInitializingShards,
      waitForStatus: waitForStatus,
      awarenessAttribute: awarenessAttribute,
      ensureNodeCommissioned: ensureNodeCommissioned,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns basic information about the health of the cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Limit the information returned to specific indicies.
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [ClusterHealthLevel] level:
  ///   Specify the level of detail for returned information.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] waitForActiveShards:
  ///   Wait until the specified number of shards is active.
  ///
  /// * [String] waitForNodes:
  ///   Wait until the specified number of nodes is available.
  ///
  /// * [WaitForEvents] waitForEvents:
  ///   Wait until all currently queued events with the given priority are processed.
  ///
  /// * [bool] waitForNoRelocatingShards:
  ///   Whether to wait until there are no relocating shards in the cluster.
  ///
  /// * [bool] waitForNoInitializingShards:
  ///   Whether to wait until there are no initializing shards in the cluster.
  ///
  /// * [WaitForStatus] waitForStatus:
  ///   Wait until cluster is in a specific state.
  ///
  /// * [String] awarenessAttribute:
  ///   The awareness attribute for which the health is required.
  ///
  /// * [bool] ensureNodeCommissioned:
  ///   Checks whether local node is commissioned or not. If set to true on a local call it will throw exception if node is decommissioned.
  Future<Response> clusterHealthWithIndexWithHttpInfo(
    String index, {
    ExpandWildcards? expandWildcards,
    ClusterHealthLevel? level,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? timeout,
    String? waitForActiveShards,
    String? waitForNodes,
    WaitForEvents? waitForEvents,
    bool? waitForNoRelocatingShards,
    bool? waitForNoInitializingShards,
    WaitForStatus? waitForStatus,
    String? awarenessAttribute,
    bool? ensureNodeCommissioned,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cluster/health/{index}'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (level != null) {
      queryParams.addAll(_queryParams('', 'level', level));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (waitForActiveShards != null) {
      queryParams.addAll(
          _queryParams('', 'wait_for_active_shards', waitForActiveShards));
    }
    if (waitForNodes != null) {
      queryParams.addAll(_queryParams('', 'wait_for_nodes', waitForNodes));
    }
    if (waitForEvents != null) {
      queryParams.addAll(_queryParams('', 'wait_for_events', waitForEvents));
    }
    if (waitForNoRelocatingShards != null) {
      queryParams.addAll(_queryParams(
          '', 'wait_for_no_relocating_shards', waitForNoRelocatingShards));
    }
    if (waitForNoInitializingShards != null) {
      queryParams.addAll(_queryParams(
          '', 'wait_for_no_initializing_shards', waitForNoInitializingShards));
    }
    if (waitForStatus != null) {
      queryParams.addAll(_queryParams('', 'wait_for_status', waitForStatus));
    }
    if (awarenessAttribute != null) {
      queryParams
          .addAll(_queryParams('', 'awareness_attribute', awarenessAttribute));
    }
    if (ensureNodeCommissioned != null) {
      queryParams.addAll(
          _queryParams('', 'ensure_node_commissioned', ensureNodeCommissioned));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns basic information about the health of the cluster.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Limit the information returned to specific indicies.
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [ClusterHealthLevel] level:
  ///   Specify the level of detail for returned information.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] waitForActiveShards:
  ///   Wait until the specified number of shards is active.
  ///
  /// * [String] waitForNodes:
  ///   Wait until the specified number of nodes is available.
  ///
  /// * [WaitForEvents] waitForEvents:
  ///   Wait until all currently queued events with the given priority are processed.
  ///
  /// * [bool] waitForNoRelocatingShards:
  ///   Whether to wait until there are no relocating shards in the cluster.
  ///
  /// * [bool] waitForNoInitializingShards:
  ///   Whether to wait until there are no initializing shards in the cluster.
  ///
  /// * [WaitForStatus] waitForStatus:
  ///   Wait until cluster is in a specific state.
  ///
  /// * [String] awarenessAttribute:
  ///   The awareness attribute for which the health is required.
  ///
  /// * [bool] ensureNodeCommissioned:
  ///   Checks whether local node is commissioned or not. If set to true on a local call it will throw exception if node is decommissioned.
  Future<void> clusterHealthWithIndex(
    String index, {
    ExpandWildcards? expandWildcards,
    ClusterHealthLevel? level,
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? timeout,
    String? waitForActiveShards,
    String? waitForNodes,
    WaitForEvents? waitForEvents,
    bool? waitForNoRelocatingShards,
    bool? waitForNoInitializingShards,
    WaitForStatus? waitForStatus,
    String? awarenessAttribute,
    bool? ensureNodeCommissioned,
  }) async {
    final response = await clusterHealthWithIndexWithHttpInfo(
      index,
      expandWildcards: expandWildcards,
      level: level,
      local: local,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      timeout: timeout,
      waitForActiveShards: waitForActiveShards,
      waitForNodes: waitForNodes,
      waitForEvents: waitForEvents,
      waitForNoRelocatingShards: waitForNoRelocatingShards,
      waitForNoInitializingShards: waitForNoInitializingShards,
      waitForStatus: waitForStatus,
      awarenessAttribute: awarenessAttribute,
      ensureNodeCommissioned: ensureNodeCommissioned,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns a list of any cluster-level changes (e.g. create index, update mapping, allocate or fail shard) which have not yet been executed.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<Response> clusterPendingTasksWithHttpInfo({
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cluster/pending_tasks';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns a list of any cluster-level changes (e.g. create index, update mapping, allocate or fail shard) which have not yet been executed.
  ///
  /// Parameters:
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<void> clusterPendingTasks({
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    final response = await clusterPendingTasksWithHttpInfo(
      local: local,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Updates the cluster voting config exclusions by node ids or node names.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] nodeIds:
  ///   Comma-separated list of the persistent ids of the nodes to exclude from the voting configuration. If specified, you may not also specify ?node_names.
  ///
  /// * [String] nodeNames:
  ///   Comma-separated list of the names of the nodes to exclude from the voting configuration. If specified, you may not also specify ?node_ids.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<Response> clusterPostVotingConfigExclusionsWithHttpInfo({
    String? nodeIds,
    String? nodeNames,
    String? timeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cluster/voting_config_exclusions';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (nodeIds != null) {
      queryParams.addAll(_queryParams('', 'node_ids', nodeIds));
    }
    if (nodeNames != null) {
      queryParams.addAll(_queryParams('', 'node_names', nodeNames));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Updates the cluster voting config exclusions by node ids or node names.
  ///
  /// Parameters:
  ///
  /// * [String] nodeIds:
  ///   Comma-separated list of the persistent ids of the nodes to exclude from the voting configuration. If specified, you may not also specify ?node_names.
  ///
  /// * [String] nodeNames:
  ///   Comma-separated list of the names of the nodes to exclude from the voting configuration. If specified, you may not also specify ?node_ids.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<void> clusterPostVotingConfigExclusions({
    String? nodeIds,
    String? nodeNames,
    String? timeout,
  }) async {
    final response = await clusterPostVotingConfigExclusionsWithHttpInfo(
      nodeIds: nodeIds,
      nodeNames: nodeNames,
      timeout: timeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Creates or updates a component template.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The name of the template.
  ///
  /// * [Object] body (required):
  ///
  /// * [bool] create:
  ///   Whether the index template should only be added if new or can also replace an existing one.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<Response> clusterPutComponentTemplatePostWithHttpInfo(
    String name,
    Object body, {
    bool? create,
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_component_template/{name}'.replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (create != null) {
      queryParams.addAll(_queryParams('', 'create', create));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates or updates a component template.
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The name of the template.
  ///
  /// * [Object] body (required):
  ///
  /// * [bool] create:
  ///   Whether the index template should only be added if new or can also replace an existing one.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<void> clusterPutComponentTemplatePost(
    String name,
    Object body, {
    bool? create,
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    final response = await clusterPutComponentTemplatePostWithHttpInfo(
      name,
      body,
      create: create,
      timeout: timeout,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Creates or updates a component template.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The name of the template.
  ///
  /// * [Object] body (required):
  ///
  /// * [bool] create:
  ///   Whether the index template should only be added if new or can also replace an existing one.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<Response> clusterPutComponentTemplatePutWithHttpInfo(
    String name,
    Object body, {
    bool? create,
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_component_template/{name}'.replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (create != null) {
      queryParams.addAll(_queryParams('', 'create', create));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates or updates a component template.
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The name of the template.
  ///
  /// * [Object] body (required):
  ///
  /// * [bool] create:
  ///   Whether the index template should only be added if new or can also replace an existing one.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<void> clusterPutComponentTemplatePut(
    String name,
    Object body, {
    bool? create,
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    final response = await clusterPutComponentTemplatePutWithHttpInfo(
      name,
      body,
      create: create,
      timeout: timeout,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Decommissions an awareness attribute.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] awarenessAttributeName (required):
  ///   Awareness attribute name.
  ///
  /// * [String] awarenessAttributeValue (required):
  ///   Awareness attribute value.
  Future<Response> clusterPutDecommissionAwarenessWithHttpInfo(
    String awarenessAttributeName,
    String awarenessAttributeValue,
  ) async {
    // ignore: prefer_const_declarations
    final path =
        r'/_cluster/decommission/awareness/{awareness_attribute_name}/{awareness_attribute_value}'
            .replaceAll('{awareness_attribute_name}', awarenessAttributeName)
            .replaceAll('{awareness_attribute_value}', awarenessAttributeValue);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Decommissions an awareness attribute.
  ///
  /// Parameters:
  ///
  /// * [String] awarenessAttributeName (required):
  ///   Awareness attribute name.
  ///
  /// * [String] awarenessAttributeValue (required):
  ///   Awareness attribute value.
  Future<void> clusterPutDecommissionAwareness(
    String awarenessAttributeName,
    String awarenessAttributeValue,
  ) async {
    final response = await clusterPutDecommissionAwarenessWithHttpInfo(
      awarenessAttributeName,
      awarenessAttributeValue,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Updates the cluster settings.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [ClusterPutSettingsBodyParams] clusterPutSettingsBodyParams (required):
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<Response> clusterPutSettingsWithHttpInfo(
    ClusterPutSettingsBodyParams clusterPutSettingsBodyParams, {
    bool? flatSettings,
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? timeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cluster/settings';

    // ignore: prefer_final_locals
    Object? postBody = clusterPutSettingsBodyParams;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (flatSettings != null) {
      queryParams.addAll(_queryParams('', 'flat_settings', flatSettings));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Updates the cluster settings.
  ///
  /// Parameters:
  ///
  /// * [ClusterPutSettingsBodyParams] clusterPutSettingsBodyParams (required):
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<ClusterPutSettingsResponseContent?> clusterPutSettings(
    ClusterPutSettingsBodyParams clusterPutSettingsBodyParams, {
    bool? flatSettings,
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? timeout,
  }) async {
    final response = await clusterPutSettingsWithHttpInfo(
      clusterPutSettingsBodyParams,
      flatSettings: flatSettings,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      timeout: timeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'ClusterPutSettingsResponseContent',
      ) as ClusterPutSettingsResponseContent;
    }
    return null;
  }

  /// Updates weighted shard routing weights.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] attribute (required):
  ///   Awareness attribute name.
  Future<Response> clusterPutWeightedRoutingWithHttpInfo(
    String attribute,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_cluster/routing/awareness/{attribute}/weights'
        .replaceAll('{attribute}', attribute);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Updates weighted shard routing weights.
  ///
  /// Parameters:
  ///
  /// * [String] attribute (required):
  ///   Awareness attribute name.
  Future<void> clusterPutWeightedRouting(
    String attribute,
  ) async {
    final response = await clusterPutWeightedRoutingWithHttpInfo(
      attribute,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns the information about configured remote clusters.
  ///
  /// Note: This method returns the HTTP [Response].
  Future<Response> clusterRemoteInfoWithHttpInfo() async {
    // ignore: prefer_const_declarations
    final path = r'/_remote/info';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns the information about configured remote clusters.
  Future<void> clusterRemoteInfo() async {
    final response = await clusterRemoteInfoWithHttpInfo();
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to manually change the allocation of individual shards in the cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] dryRun:
  ///   Simulate the operation only and return the resulting state.
  ///
  /// * [bool] explain:
  ///   Return an explanation of why the commands can or cannot be executed.
  ///
  /// * [bool] retryFailed:
  ///   Retries allocation of shards that are blocked due to too many subsequent allocation failures.
  ///
  /// * [List<ClusterRerouteMetricMember>] metric:
  ///   Limit the information returned to the specified metrics. Defaults to all but metadata.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [Object] body:
  Future<Response> clusterRerouteWithHttpInfo({
    bool? dryRun,
    bool? explain,
    bool? retryFailed,
    List<ClusterRerouteMetricMember>? metric,
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? timeout,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cluster/reroute';

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (dryRun != null) {
      queryParams.addAll(_queryParams('', 'dry_run', dryRun));
    }
    if (explain != null) {
      queryParams.addAll(_queryParams('', 'explain', explain));
    }
    if (retryFailed != null) {
      queryParams.addAll(_queryParams('', 'retry_failed', retryFailed));
    }
    if (metric != null) {
      queryParams.addAll(_queryParams('multi', 'metric', metric));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to manually change the allocation of individual shards in the cluster.
  ///
  /// Parameters:
  ///
  /// * [bool] dryRun:
  ///   Simulate the operation only and return the resulting state.
  ///
  /// * [bool] explain:
  ///   Return an explanation of why the commands can or cannot be executed.
  ///
  /// * [bool] retryFailed:
  ///   Retries allocation of shards that are blocked due to too many subsequent allocation failures.
  ///
  /// * [List<ClusterRerouteMetricMember>] metric:
  ///   Limit the information returned to the specified metrics. Defaults to all but metadata.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [Object] body:
  Future<void> clusterReroute({
    bool? dryRun,
    bool? explain,
    bool? retryFailed,
    List<ClusterRerouteMetricMember>? metric,
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? timeout,
    Object? body,
  }) async {
    final response = await clusterRerouteWithHttpInfo(
      dryRun: dryRun,
      explain: explain,
      retryFailed: retryFailed,
      metric: metric,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      timeout: timeout,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns a comprehensive information about the state of the cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [int] waitForMetadataVersion:
  ///   Wait for the metadata version to be equal or greater than the specified metadata version.
  ///
  /// * [String] waitForTimeout:
  ///   The maximum time to wait for wait_for_metadata_version before timing out.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<Response> clusterStateWithHttpInfo({
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? flatSettings,
    int? waitForMetadataVersion,
    String? waitForTimeout,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cluster/state';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (flatSettings != null) {
      queryParams.addAll(_queryParams('', 'flat_settings', flatSettings));
    }
    if (waitForMetadataVersion != null) {
      queryParams.addAll(_queryParams(
          '', 'wait_for_metadata_version', waitForMetadataVersion));
    }
    if (waitForTimeout != null) {
      queryParams.addAll(_queryParams('', 'wait_for_timeout', waitForTimeout));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns a comprehensive information about the state of the cluster.
  ///
  /// Parameters:
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [int] waitForMetadataVersion:
  ///   Wait for the metadata version to be equal or greater than the specified metadata version.
  ///
  /// * [String] waitForTimeout:
  ///   The maximum time to wait for wait_for_metadata_version before timing out.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<void> clusterState({
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? flatSettings,
    int? waitForMetadataVersion,
    String? waitForTimeout,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    final response = await clusterStateWithHttpInfo(
      local: local,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      flatSettings: flatSettings,
      waitForMetadataVersion: waitForMetadataVersion,
      waitForTimeout: waitForTimeout,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns a comprehensive information about the state of the cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [String] metric (required):
  ///   Limit the information returned to the specified metrics.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [int] waitForMetadataVersion:
  ///   Wait for the metadata version to be equal or greater than the specified metadata version.
  ///
  /// * [String] waitForTimeout:
  ///   The maximum time to wait for wait_for_metadata_version before timing out.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<Response> clusterStateWithIndexMetricWithHttpInfo(
    String index,
    String metric, {
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? flatSettings,
    int? waitForMetadataVersion,
    String? waitForTimeout,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cluster/state/{metric}/{index}'
        .replaceAll('{index}', index)
        .replaceAll('{metric}', metric);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (flatSettings != null) {
      queryParams.addAll(_queryParams('', 'flat_settings', flatSettings));
    }
    if (waitForMetadataVersion != null) {
      queryParams.addAll(_queryParams(
          '', 'wait_for_metadata_version', waitForMetadataVersion));
    }
    if (waitForTimeout != null) {
      queryParams.addAll(_queryParams('', 'wait_for_timeout', waitForTimeout));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns a comprehensive information about the state of the cluster.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [String] metric (required):
  ///   Limit the information returned to the specified metrics.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [int] waitForMetadataVersion:
  ///   Wait for the metadata version to be equal or greater than the specified metadata version.
  ///
  /// * [String] waitForTimeout:
  ///   The maximum time to wait for wait_for_metadata_version before timing out.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<void> clusterStateWithIndexMetric(
    String index,
    String metric, {
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? flatSettings,
    int? waitForMetadataVersion,
    String? waitForTimeout,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    final response = await clusterStateWithIndexMetricWithHttpInfo(
      index,
      metric,
      local: local,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      flatSettings: flatSettings,
      waitForMetadataVersion: waitForMetadataVersion,
      waitForTimeout: waitForTimeout,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns a comprehensive information about the state of the cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] metric (required):
  ///   Limit the information returned to the specified metrics.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [int] waitForMetadataVersion:
  ///   Wait for the metadata version to be equal or greater than the specified metadata version.
  ///
  /// * [String] waitForTimeout:
  ///   The maximum time to wait for wait_for_metadata_version before timing out.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<Response> clusterStateWithMetricWithHttpInfo(
    String metric, {
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? flatSettings,
    int? waitForMetadataVersion,
    String? waitForTimeout,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cluster/state/{metric}'.replaceAll('{metric}', metric);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (flatSettings != null) {
      queryParams.addAll(_queryParams('', 'flat_settings', flatSettings));
    }
    if (waitForMetadataVersion != null) {
      queryParams.addAll(_queryParams(
          '', 'wait_for_metadata_version', waitForMetadataVersion));
    }
    if (waitForTimeout != null) {
      queryParams.addAll(_queryParams('', 'wait_for_timeout', waitForTimeout));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns a comprehensive information about the state of the cluster.
  ///
  /// Parameters:
  ///
  /// * [String] metric (required):
  ///   Limit the information returned to the specified metrics.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [int] waitForMetadataVersion:
  ///   Wait for the metadata version to be equal or greater than the specified metadata version.
  ///
  /// * [String] waitForTimeout:
  ///   The maximum time to wait for wait_for_metadata_version before timing out.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<void> clusterStateWithMetric(
    String metric, {
    bool? local,
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? flatSettings,
    int? waitForMetadataVersion,
    String? waitForTimeout,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    final response = await clusterStateWithMetricWithHttpInfo(
      metric,
      local: local,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      flatSettings: flatSettings,
      waitForMetadataVersion: waitForMetadataVersion,
      waitForTimeout: waitForTimeout,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns high-level overview of cluster statistics.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<Response> clusterStatsWithHttpInfo({
    bool? flatSettings,
    String? timeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cluster/stats';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (flatSettings != null) {
      queryParams.addAll(_queryParams('', 'flat_settings', flatSettings));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns high-level overview of cluster statistics.
  ///
  /// Parameters:
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<void> clusterStats({
    bool? flatSettings,
    String? timeout,
  }) async {
    final response = await clusterStatsWithHttpInfo(
      flatSettings: flatSettings,
      timeout: timeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns high-level overview of cluster statistics.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] nodeId (required):
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<Response> clusterStatsWithNodeIdWithHttpInfo(
    String nodeId, {
    bool? flatSettings,
    String? timeout,
  }) async {
    // ignore: prefer_const_declarations
    final path =
        r'/_cluster/stats/nodes/{node_id}'.replaceAll('{node_id}', nodeId);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (flatSettings != null) {
      queryParams.addAll(_queryParams('', 'flat_settings', flatSettings));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns high-level overview of cluster statistics.
  ///
  /// Parameters:
  ///
  /// * [String] nodeId (required):
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<void> clusterStatsWithNodeId(
    String nodeId, {
    bool? flatSettings,
    String? timeout,
  }) async {
    final response = await clusterStatsWithNodeIdWithHttpInfo(
      nodeId,
      flatSettings: flatSettings,
      timeout: timeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns number of documents matching a query.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] ignoreThrottled:
  ///   Whether specified concrete, expanded or aliased indices should be ignored when throttled.
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [int] minScore:
  ///   Include only documents with a specific `_score` value in the result.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [List<String>] routing:
  ///   Comma-separated list of specific routing values.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcard and prefix queries should be analyzed.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The field to use as default where no field prefix is given in the query string.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [int] terminateAfter:
  ///   The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
  Future<Response> countGetWithHttpInfo({
    bool? ignoreUnavailable,
    bool? ignoreThrottled,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    int? minScore,
    String? preference,
    List<String>? routing,
    String? q,
    String? analyzer,
    bool? analyzeWildcard,
    DefaultOperator? defaultOperator,
    String? df,
    bool? lenient,
    int? terminateAfter,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_count';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (ignoreThrottled != null) {
      queryParams.addAll(_queryParams('', 'ignore_throttled', ignoreThrottled));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (minScore != null) {
      queryParams.addAll(_queryParams('', 'min_score', minScore));
    }
    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('multi', 'routing', routing));
    }
    if (q != null) {
      queryParams.addAll(_queryParams('', 'q', q));
    }
    if (analyzer != null) {
      queryParams.addAll(_queryParams('', 'analyzer', analyzer));
    }
    if (analyzeWildcard != null) {
      queryParams.addAll(_queryParams('', 'analyze_wildcard', analyzeWildcard));
    }
    if (defaultOperator != null) {
      queryParams.addAll(_queryParams('', 'default_operator', defaultOperator));
    }
    if (df != null) {
      queryParams.addAll(_queryParams('', 'df', df));
    }
    if (lenient != null) {
      queryParams.addAll(_queryParams('', 'lenient', lenient));
    }
    if (terminateAfter != null) {
      queryParams.addAll(_queryParams('', 'terminate_after', terminateAfter));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns number of documents matching a query.
  ///
  /// Parameters:
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] ignoreThrottled:
  ///   Whether specified concrete, expanded or aliased indices should be ignored when throttled.
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [int] minScore:
  ///   Include only documents with a specific `_score` value in the result.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [List<String>] routing:
  ///   Comma-separated list of specific routing values.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcard and prefix queries should be analyzed.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The field to use as default where no field prefix is given in the query string.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [int] terminateAfter:
  ///   The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
  Future<void> countGet({
    bool? ignoreUnavailable,
    bool? ignoreThrottled,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    int? minScore,
    String? preference,
    List<String>? routing,
    String? q,
    String? analyzer,
    bool? analyzeWildcard,
    DefaultOperator? defaultOperator,
    String? df,
    bool? lenient,
    int? terminateAfter,
  }) async {
    final response = await countGetWithHttpInfo(
      ignoreUnavailable: ignoreUnavailable,
      ignoreThrottled: ignoreThrottled,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      minScore: minScore,
      preference: preference,
      routing: routing,
      q: q,
      analyzer: analyzer,
      analyzeWildcard: analyzeWildcard,
      defaultOperator: defaultOperator,
      df: df,
      lenient: lenient,
      terminateAfter: terminateAfter,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns number of documents matching a query.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to restrict the results.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] ignoreThrottled:
  ///   Whether specified concrete, expanded or aliased indices should be ignored when throttled.
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [int] minScore:
  ///   Include only documents with a specific `_score` value in the result.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [List<String>] routing:
  ///   Comma-separated list of specific routing values.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcard and prefix queries should be analyzed.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The field to use as default where no field prefix is given in the query string.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [int] terminateAfter:
  ///   The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
  Future<Response> countGetWithIndexWithHttpInfo(
    String index, {
    bool? ignoreUnavailable,
    bool? ignoreThrottled,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    int? minScore,
    String? preference,
    List<String>? routing,
    String? q,
    String? analyzer,
    bool? analyzeWildcard,
    DefaultOperator? defaultOperator,
    String? df,
    bool? lenient,
    int? terminateAfter,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_count'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (ignoreThrottled != null) {
      queryParams.addAll(_queryParams('', 'ignore_throttled', ignoreThrottled));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (minScore != null) {
      queryParams.addAll(_queryParams('', 'min_score', minScore));
    }
    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('multi', 'routing', routing));
    }
    if (q != null) {
      queryParams.addAll(_queryParams('', 'q', q));
    }
    if (analyzer != null) {
      queryParams.addAll(_queryParams('', 'analyzer', analyzer));
    }
    if (analyzeWildcard != null) {
      queryParams.addAll(_queryParams('', 'analyze_wildcard', analyzeWildcard));
    }
    if (defaultOperator != null) {
      queryParams.addAll(_queryParams('', 'default_operator', defaultOperator));
    }
    if (df != null) {
      queryParams.addAll(_queryParams('', 'df', df));
    }
    if (lenient != null) {
      queryParams.addAll(_queryParams('', 'lenient', lenient));
    }
    if (terminateAfter != null) {
      queryParams.addAll(_queryParams('', 'terminate_after', terminateAfter));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns number of documents matching a query.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to restrict the results.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] ignoreThrottled:
  ///   Whether specified concrete, expanded or aliased indices should be ignored when throttled.
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [int] minScore:
  ///   Include only documents with a specific `_score` value in the result.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [List<String>] routing:
  ///   Comma-separated list of specific routing values.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcard and prefix queries should be analyzed.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The field to use as default where no field prefix is given in the query string.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [int] terminateAfter:
  ///   The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
  Future<void> countGetWithIndex(
    String index, {
    bool? ignoreUnavailable,
    bool? ignoreThrottled,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    int? minScore,
    String? preference,
    List<String>? routing,
    String? q,
    String? analyzer,
    bool? analyzeWildcard,
    DefaultOperator? defaultOperator,
    String? df,
    bool? lenient,
    int? terminateAfter,
  }) async {
    final response = await countGetWithIndexWithHttpInfo(
      index,
      ignoreUnavailable: ignoreUnavailable,
      ignoreThrottled: ignoreThrottled,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      minScore: minScore,
      preference: preference,
      routing: routing,
      q: q,
      analyzer: analyzer,
      analyzeWildcard: analyzeWildcard,
      defaultOperator: defaultOperator,
      df: df,
      lenient: lenient,
      terminateAfter: terminateAfter,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns number of documents matching a query.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] ignoreThrottled:
  ///   Whether specified concrete, expanded or aliased indices should be ignored when throttled.
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [int] minScore:
  ///   Include only documents with a specific `_score` value in the result.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [List<String>] routing:
  ///   Comma-separated list of specific routing values.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcard and prefix queries should be analyzed.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The field to use as default where no field prefix is given in the query string.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [int] terminateAfter:
  ///   The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
  ///
  /// * [Object] body:
  Future<Response> countPostWithHttpInfo({
    bool? ignoreUnavailable,
    bool? ignoreThrottled,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    int? minScore,
    String? preference,
    List<String>? routing,
    String? q,
    String? analyzer,
    bool? analyzeWildcard,
    DefaultOperator? defaultOperator,
    String? df,
    bool? lenient,
    int? terminateAfter,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_count';

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (ignoreThrottled != null) {
      queryParams.addAll(_queryParams('', 'ignore_throttled', ignoreThrottled));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (minScore != null) {
      queryParams.addAll(_queryParams('', 'min_score', minScore));
    }
    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('multi', 'routing', routing));
    }
    if (q != null) {
      queryParams.addAll(_queryParams('', 'q', q));
    }
    if (analyzer != null) {
      queryParams.addAll(_queryParams('', 'analyzer', analyzer));
    }
    if (analyzeWildcard != null) {
      queryParams.addAll(_queryParams('', 'analyze_wildcard', analyzeWildcard));
    }
    if (defaultOperator != null) {
      queryParams.addAll(_queryParams('', 'default_operator', defaultOperator));
    }
    if (df != null) {
      queryParams.addAll(_queryParams('', 'df', df));
    }
    if (lenient != null) {
      queryParams.addAll(_queryParams('', 'lenient', lenient));
    }
    if (terminateAfter != null) {
      queryParams.addAll(_queryParams('', 'terminate_after', terminateAfter));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns number of documents matching a query.
  ///
  /// Parameters:
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] ignoreThrottled:
  ///   Whether specified concrete, expanded or aliased indices should be ignored when throttled.
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [int] minScore:
  ///   Include only documents with a specific `_score` value in the result.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [List<String>] routing:
  ///   Comma-separated list of specific routing values.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcard and prefix queries should be analyzed.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The field to use as default where no field prefix is given in the query string.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [int] terminateAfter:
  ///   The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
  ///
  /// * [Object] body:
  Future<void> countPost({
    bool? ignoreUnavailable,
    bool? ignoreThrottled,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    int? minScore,
    String? preference,
    List<String>? routing,
    String? q,
    String? analyzer,
    bool? analyzeWildcard,
    DefaultOperator? defaultOperator,
    String? df,
    bool? lenient,
    int? terminateAfter,
    Object? body,
  }) async {
    final response = await countPostWithHttpInfo(
      ignoreUnavailable: ignoreUnavailable,
      ignoreThrottled: ignoreThrottled,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      minScore: minScore,
      preference: preference,
      routing: routing,
      q: q,
      analyzer: analyzer,
      analyzeWildcard: analyzeWildcard,
      defaultOperator: defaultOperator,
      df: df,
      lenient: lenient,
      terminateAfter: terminateAfter,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns number of documents matching a query.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to restrict the results.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] ignoreThrottled:
  ///   Whether specified concrete, expanded or aliased indices should be ignored when throttled.
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [int] minScore:
  ///   Include only documents with a specific `_score` value in the result.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [List<String>] routing:
  ///   Comma-separated list of specific routing values.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcard and prefix queries should be analyzed.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The field to use as default where no field prefix is given in the query string.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [int] terminateAfter:
  ///   The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
  ///
  /// * [Object] body:
  Future<Response> countPostWithIndexWithHttpInfo(
    String index, {
    bool? ignoreUnavailable,
    bool? ignoreThrottled,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    int? minScore,
    String? preference,
    List<String>? routing,
    String? q,
    String? analyzer,
    bool? analyzeWildcard,
    DefaultOperator? defaultOperator,
    String? df,
    bool? lenient,
    int? terminateAfter,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_count'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (ignoreThrottled != null) {
      queryParams.addAll(_queryParams('', 'ignore_throttled', ignoreThrottled));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (minScore != null) {
      queryParams.addAll(_queryParams('', 'min_score', minScore));
    }
    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('multi', 'routing', routing));
    }
    if (q != null) {
      queryParams.addAll(_queryParams('', 'q', q));
    }
    if (analyzer != null) {
      queryParams.addAll(_queryParams('', 'analyzer', analyzer));
    }
    if (analyzeWildcard != null) {
      queryParams.addAll(_queryParams('', 'analyze_wildcard', analyzeWildcard));
    }
    if (defaultOperator != null) {
      queryParams.addAll(_queryParams('', 'default_operator', defaultOperator));
    }
    if (df != null) {
      queryParams.addAll(_queryParams('', 'df', df));
    }
    if (lenient != null) {
      queryParams.addAll(_queryParams('', 'lenient', lenient));
    }
    if (terminateAfter != null) {
      queryParams.addAll(_queryParams('', 'terminate_after', terminateAfter));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns number of documents matching a query.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to restrict the results.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] ignoreThrottled:
  ///   Whether specified concrete, expanded or aliased indices should be ignored when throttled.
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [int] minScore:
  ///   Include only documents with a specific `_score` value in the result.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [List<String>] routing:
  ///   Comma-separated list of specific routing values.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcard and prefix queries should be analyzed.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The field to use as default where no field prefix is given in the query string.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [int] terminateAfter:
  ///   The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
  ///
  /// * [Object] body:
  Future<void> countPostWithIndex(
    String index, {
    bool? ignoreUnavailable,
    bool? ignoreThrottled,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    int? minScore,
    String? preference,
    List<String>? routing,
    String? q,
    String? analyzer,
    bool? analyzeWildcard,
    DefaultOperator? defaultOperator,
    String? df,
    bool? lenient,
    int? terminateAfter,
    Object? body,
  }) async {
    final response = await countPostWithIndexWithHttpInfo(
      index,
      ignoreUnavailable: ignoreUnavailable,
      ignoreThrottled: ignoreThrottled,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      minScore: minScore,
      preference: preference,
      routing: routing,
      q: q,
      analyzer: analyzer,
      analyzeWildcard: analyzeWildcard,
      defaultOperator: defaultOperator,
      df: df,
      lenient: lenient,
      terminateAfter: terminateAfter,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Creates or replaces the specified action group.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] actionGroup (required):
  ///   The name of the action group to create or replace
  ///
  /// * [ActionGroup] actionGroup2 (required):
  Future<Response> createActionGroupWithHttpInfo(
    String actionGroup,
    ActionGroup actionGroup2,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/actiongroups/{action_group}'
        .replaceAll('{action_group}', actionGroup);

    // ignore: prefer_final_locals
    Object? postBody = actionGroup2;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates or replaces the specified action group.
  ///
  /// Parameters:
  ///
  /// * [String] actionGroup (required):
  ///   The name of the action group to create or replace
  ///
  /// * [ActionGroup] actionGroup2 (required):
  Future<CreateActionGroupResponseContent?> createActionGroup(
    String actionGroup,
    ActionGroup actionGroup2,
  ) async {
    final response = await createActionGroupWithHttpInfo(
      actionGroup,
      actionGroup2,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'CreateActionGroupResponseContent',
      ) as CreateActionGroupResponseContent;
    }
    return null;
  }

  /// Creates point in time context.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] allowPartialPitCreation:
  ///   Allow if point in time can be created with partial failures.
  ///
  /// * [String] keepAlive:
  ///   Specify the keep alive for point in time.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [List<String>] routing:
  ///   Comma-separated list of specific routing values.
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<Response> createPitWithHttpInfo(
    String index, {
    bool? allowPartialPitCreation,
    String? keepAlive,
    String? preference,
    List<String>? routing,
    ExpandWildcards? expandWildcards,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_search/point_in_time'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (allowPartialPitCreation != null) {
      queryParams.addAll(_queryParams(
          '', 'allow_partial_pit_creation', allowPartialPitCreation));
    }
    if (keepAlive != null) {
      queryParams.addAll(_queryParams('', 'keep_alive', keepAlive));
    }
    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('multi', 'routing', routing));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates point in time context.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] allowPartialPitCreation:
  ///   Allow if point in time can be created with partial failures.
  ///
  /// * [String] keepAlive:
  ///   Specify the keep alive for point in time.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [List<String>] routing:
  ///   Comma-separated list of specific routing values.
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<CreatePitResponseContent?> createPit(
    String index, {
    bool? allowPartialPitCreation,
    String? keepAlive,
    String? preference,
    List<String>? routing,
    ExpandWildcards? expandWildcards,
  }) async {
    final response = await createPitWithHttpInfo(
      index,
      allowPartialPitCreation: allowPartialPitCreation,
      keepAlive: keepAlive,
      preference: preference,
      routing: routing,
      expandWildcards: expandWildcards,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'CreatePitResponseContent',
      ) as CreatePitResponseContent;
    }
    return null;
  }

  /// Creates a new document in the index.  Returns a 409 response when a document with a same ID already exists in the index.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Document ID.
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
  ///
  /// * [RefreshEnum] refresh:
  ///   If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  ///
  /// * [String] pipeline:
  ///   The pipeline id to preprocess incoming documents with.
  Future<Response> createPostWithHttpInfo(
    String id,
    String index,
    Object body, {
    String? waitForActiveShards,
    RefreshEnum? refresh,
    String? routing,
    String? timeout,
    int? version,
    VersionType? versionType,
    String? pipeline,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_create/{id}'
        .replaceAll('{id}', id)
        .replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (waitForActiveShards != null) {
      queryParams.addAll(
          _queryParams('', 'wait_for_active_shards', waitForActiveShards));
    }
    if (refresh != null) {
      queryParams.addAll(_queryParams('', 'refresh', refresh));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (version != null) {
      queryParams.addAll(_queryParams('', 'version', version));
    }
    if (versionType != null) {
      queryParams.addAll(_queryParams('', 'version_type', versionType));
    }
    if (pipeline != null) {
      queryParams.addAll(_queryParams('', 'pipeline', pipeline));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates a new document in the index.  Returns a 409 response when a document with a same ID already exists in the index.
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Document ID.
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
  ///
  /// * [RefreshEnum] refresh:
  ///   If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  ///
  /// * [String] pipeline:
  ///   The pipeline id to preprocess incoming documents with.
  Future<void> createPost(
    String id,
    String index,
    Object body, {
    String? waitForActiveShards,
    RefreshEnum? refresh,
    String? routing,
    String? timeout,
    int? version,
    VersionType? versionType,
    String? pipeline,
  }) async {
    final response = await createPostWithHttpInfo(
      id,
      index,
      body,
      waitForActiveShards: waitForActiveShards,
      refresh: refresh,
      routing: routing,
      timeout: timeout,
      version: version,
      versionType: versionType,
      pipeline: pipeline,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Creates a new document in the index.  Returns a 409 response when a document with a same ID already exists in the index.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Document ID.
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
  ///
  /// * [RefreshEnum] refresh:
  ///   If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  ///
  /// * [String] pipeline:
  ///   The pipeline id to preprocess incoming documents with.
  Future<Response> createPutWithHttpInfo(
    String id,
    String index,
    Object body, {
    String? waitForActiveShards,
    RefreshEnum? refresh,
    String? routing,
    String? timeout,
    int? version,
    VersionType? versionType,
    String? pipeline,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_create/{id}'
        .replaceAll('{id}', id)
        .replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (waitForActiveShards != null) {
      queryParams.addAll(
          _queryParams('', 'wait_for_active_shards', waitForActiveShards));
    }
    if (refresh != null) {
      queryParams.addAll(_queryParams('', 'refresh', refresh));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (version != null) {
      queryParams.addAll(_queryParams('', 'version', version));
    }
    if (versionType != null) {
      queryParams.addAll(_queryParams('', 'version_type', versionType));
    }
    if (pipeline != null) {
      queryParams.addAll(_queryParams('', 'pipeline', pipeline));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates a new document in the index.  Returns a 409 response when a document with a same ID already exists in the index.
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Document ID.
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
  ///
  /// * [RefreshEnum] refresh:
  ///   If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  ///
  /// * [String] pipeline:
  ///   The pipeline id to preprocess incoming documents with.
  Future<void> createPut(
    String id,
    String index,
    Object body, {
    String? waitForActiveShards,
    RefreshEnum? refresh,
    String? routing,
    String? timeout,
    int? version,
    VersionType? versionType,
    String? pipeline,
  }) async {
    final response = await createPutWithHttpInfo(
      id,
      index,
      body,
      waitForActiveShards: waitForActiveShards,
      refresh: refresh,
      routing: routing,
      timeout: timeout,
      version: version,
      versionType: versionType,
      pipeline: pipeline,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Creates or replaces the specified role.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] role (required):
  ///
  /// * [Role] role2 (required):
  Future<Response> createRoleWithHttpInfo(
    String role,
    Role role2,
  ) async {
    // ignore: prefer_const_declarations
    final path =
        r'/_plugins/_security/api/roles/{role}'.replaceAll('{role}', role);

    // ignore: prefer_final_locals
    Object? postBody = role2;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates or replaces the specified role.
  ///
  /// Parameters:
  ///
  /// * [String] role (required):
  ///
  /// * [Role] role2 (required):
  Future<CreateRoleResponseContent?> createRole(
    String role,
    Role role2,
  ) async {
    final response = await createRoleWithHttpInfo(
      role,
      role2,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'CreateRoleResponseContent',
      ) as CreateRoleResponseContent;
    }
    return null;
  }

  /// Creates or replaces the specified role mapping.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] role (required):
  ///
  /// * [RoleMapping] roleMapping (required):
  Future<Response> createRoleMappingWithHttpInfo(
    String role,
    RoleMapping roleMapping,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/rolesmapping/{role}'
        .replaceAll('{role}', role);

    // ignore: prefer_final_locals
    Object? postBody = roleMapping;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates or replaces the specified role mapping.
  ///
  /// Parameters:
  ///
  /// * [String] role (required):
  ///
  /// * [RoleMapping] roleMapping (required):
  Future<CreateRoleMappingResponseContent?> createRoleMapping(
    String role,
    RoleMapping roleMapping,
  ) async {
    final response = await createRoleMappingWithHttpInfo(
      role,
      roleMapping,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'CreateRoleMappingResponseContent',
      ) as CreateRoleMappingResponseContent;
    }
    return null;
  }

  /// Creates or replaces the specified tenant.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] tenant (required):
  ///
  /// * [CreateTenantParams] createTenantParams (required):
  Future<Response> createTenantWithHttpInfo(
    String tenant,
    CreateTenantParams createTenantParams,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/tenants/{tenant}'
        .replaceAll('{tenant}', tenant);

    // ignore: prefer_final_locals
    Object? postBody = createTenantParams;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates or replaces the specified tenant.
  ///
  /// Parameters:
  ///
  /// * [String] tenant (required):
  ///
  /// * [CreateTenantParams] createTenantParams (required):
  Future<CreateTenantResponseContent?> createTenant(
    String tenant,
    CreateTenantParams createTenantParams,
  ) async {
    final response = await createTenantWithHttpInfo(
      tenant,
      createTenantParams,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'CreateTenantResponseContent',
      ) as CreateTenantResponseContent;
    }
    return null;
  }

  /// Creates or replaces the specified user.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] username (required):
  ///
  /// * [User] user (required):
  Future<Response> createUserWithHttpInfo(
    String username,
    User user,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/internalusers/{username}'
        .replaceAll('{username}', username);

    // ignore: prefer_final_locals
    Object? postBody = user;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates or replaces the specified user.
  ///
  /// Parameters:
  ///
  /// * [String] username (required):
  ///
  /// * [User] user (required):
  Future<CreateUserResponseContent?> createUser(
    String username,
    User user,
  ) async {
    final response = await createUserWithHttpInfo(
      username,
      user,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'CreateUserResponseContent',
      ) as CreateUserResponseContent;
    }
    return null;
  }

  /// Deletes the specified dangling index.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] indexUuid (required):
  ///   The UUID of the dangling index.
  ///
  /// * [bool] acceptDataLoss:
  ///   Must be set to true in order to delete the dangling index.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<Response> danglingIndicesDeleteDanglingIndexWithHttpInfo(
    String indexUuid, {
    bool? acceptDataLoss,
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    // ignore: prefer_const_declarations
    final path =
        r'/_dangling/{index_uuid}'.replaceAll('{index_uuid}', indexUuid);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (acceptDataLoss != null) {
      queryParams.addAll(_queryParams('', 'accept_data_loss', acceptDataLoss));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'DELETE',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Deletes the specified dangling index.
  ///
  /// Parameters:
  ///
  /// * [String] indexUuid (required):
  ///   The UUID of the dangling index.
  ///
  /// * [bool] acceptDataLoss:
  ///   Must be set to true in order to delete the dangling index.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<void> danglingIndicesDeleteDanglingIndex(
    String indexUuid, {
    bool? acceptDataLoss,
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    final response = await danglingIndicesDeleteDanglingIndexWithHttpInfo(
      indexUuid,
      acceptDataLoss: acceptDataLoss,
      timeout: timeout,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Imports the specified dangling index.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] indexUuid (required):
  ///   The UUID of the dangling index.
  ///
  /// * [bool] acceptDataLoss:
  ///   Must be set to true in order to import the dangling index.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<Response> danglingIndicesImportDanglingIndexWithHttpInfo(
    String indexUuid, {
    bool? acceptDataLoss,
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    // ignore: prefer_const_declarations
    final path =
        r'/_dangling/{index_uuid}'.replaceAll('{index_uuid}', indexUuid);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (acceptDataLoss != null) {
      queryParams.addAll(_queryParams('', 'accept_data_loss', acceptDataLoss));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Imports the specified dangling index.
  ///
  /// Parameters:
  ///
  /// * [String] indexUuid (required):
  ///   The UUID of the dangling index.
  ///
  /// * [bool] acceptDataLoss:
  ///   Must be set to true in order to import the dangling index.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<void> danglingIndicesImportDanglingIndex(
    String indexUuid, {
    bool? acceptDataLoss,
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    final response = await danglingIndicesImportDanglingIndexWithHttpInfo(
      indexUuid,
      acceptDataLoss: acceptDataLoss,
      timeout: timeout,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns all dangling indices.
  ///
  /// Note: This method returns the HTTP [Response].
  Future<Response> danglingIndicesListDanglingIndicesWithHttpInfo() async {
    // ignore: prefer_const_declarations
    final path = r'/_dangling';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns all dangling indices.
  Future<void> danglingIndicesListDanglingIndices() async {
    final response = await danglingIndicesListDanglingIndicesWithHttpInfo();
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Removes a document from the index.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Document ID.
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
  ///
  /// * [RefreshEnum] refresh:
  ///   If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [int] ifSeqNo:
  ///   only perform the operation if the last operation that has changed the document has the specified sequence number.
  ///
  /// * [int] ifPrimaryTerm:
  ///   only perform the operation if the last operation that has changed the document has the specified primary term.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  Future<Response> deleteWithHttpInfo(
    String id,
    String index, {
    String? waitForActiveShards,
    RefreshEnum? refresh,
    String? routing,
    String? timeout,
    int? ifSeqNo,
    int? ifPrimaryTerm,
    int? version,
    VersionType? versionType,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_doc/{id}'
        .replaceAll('{id}', id)
        .replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (waitForActiveShards != null) {
      queryParams.addAll(
          _queryParams('', 'wait_for_active_shards', waitForActiveShards));
    }
    if (refresh != null) {
      queryParams.addAll(_queryParams('', 'refresh', refresh));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (ifSeqNo != null) {
      queryParams.addAll(_queryParams('', 'if_seq_no', ifSeqNo));
    }
    if (ifPrimaryTerm != null) {
      queryParams.addAll(_queryParams('', 'if_primary_term', ifPrimaryTerm));
    }
    if (version != null) {
      queryParams.addAll(_queryParams('', 'version', version));
    }
    if (versionType != null) {
      queryParams.addAll(_queryParams('', 'version_type', versionType));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'DELETE',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Removes a document from the index.
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Document ID.
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
  ///
  /// * [RefreshEnum] refresh:
  ///   If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [int] ifSeqNo:
  ///   only perform the operation if the last operation that has changed the document has the specified sequence number.
  ///
  /// * [int] ifPrimaryTerm:
  ///   only perform the operation if the last operation that has changed the document has the specified primary term.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  Future<void> delete(
    String id,
    String index, {
    String? waitForActiveShards,
    RefreshEnum? refresh,
    String? routing,
    String? timeout,
    int? ifSeqNo,
    int? ifPrimaryTerm,
    int? version,
    VersionType? versionType,
  }) async {
    final response = await deleteWithHttpInfo(
      id,
      index,
      waitForActiveShards: waitForActiveShards,
      refresh: refresh,
      routing: routing,
      timeout: timeout,
      ifSeqNo: ifSeqNo,
      ifPrimaryTerm: ifPrimaryTerm,
      version: version,
      versionType: versionType,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Delete a specified action group.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] actionGroup (required):
  ///   Action group to delete.
  Future<Response> deleteActionGroupWithHttpInfo(
    String actionGroup,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/actiongroups/{action_group}'
        .replaceAll('{action_group}', actionGroup);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'DELETE',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Delete a specified action group.
  ///
  /// Parameters:
  ///
  /// * [String] actionGroup (required):
  ///   Action group to delete.
  Future<DeleteActionGroupResponseContent?> deleteActionGroup(
    String actionGroup,
  ) async {
    final response = await deleteActionGroupWithHttpInfo(
      actionGroup,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'DeleteActionGroupResponseContent',
      ) as DeleteActionGroupResponseContent;
    }
    return null;
  }

  /// Deletes all active point in time searches.
  ///
  /// Note: This method returns the HTTP [Response].
  Future<Response> deleteAllPitsWithHttpInfo() async {
    // ignore: prefer_const_declarations
    final path = r'/_search/point_in_time/_all';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'DELETE',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Deletes all active point in time searches.
  Future<DeleteAllPitsResponseContent?> deleteAllPits() async {
    final response = await deleteAllPitsWithHttpInfo();
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'DeleteAllPitsResponseContent',
      ) as DeleteAllPitsResponseContent;
    }
    return null;
  }

  /// Deletes documents matching the provided query.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcard and prefix queries should be analyzed.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The field to use as default where no field prefix is given in the query string.
  ///
  /// * [int] from:
  ///   Starting offset.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [Conflicts] conflicts:
  ///   What to do when the operation encounters version conflicts?.
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [List<String>] routing:
  ///   Comma-separated list of specific routing values.
  ///
  /// * [String] scroll:
  ///   Specify how long a consistent view of the index should be maintained for scrolled search.
  ///
  /// * [SearchType] searchType:
  ///   Search operation type.
  ///
  /// * [String] searchTimeout:
  ///   Explicit timeout for each search request. Defaults to no timeout.
  ///
  /// * [int] size:
  ///   Deprecated, please use `max_docs` instead.
  ///
  /// * [int] maxDocs:
  ///   Maximum number of documents to process (default: all documents).
  ///
  /// * [List<String>] sort:
  ///   Comma-separated list of <field>:<direction> pairs.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  ///
  /// * [int] terminateAfter:
  ///   The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
  ///
  /// * [List<String>] stats:
  ///   Specific 'tag' of the request for logging and statistical purposes.
  ///
  /// * [bool] version:
  ///   Whether to return document version as part of a hit.
  ///
  /// * [bool] requestCache:
  ///   Specify if request cache should be used for this request or not, defaults to index level setting.
  ///
  /// * [bool] refresh:
  ///   Refresh the shard containing the document before performing the operation.
  ///
  /// * [String] timeout:
  ///   Time each individual bulk request should wait for shards that are unavailable.
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
  ///
  /// * [int] scrollSize:
  ///   Size on the scroll request powering the operation.
  ///
  /// * [bool] waitForCompletion:
  ///   Should this request wait until the operation has completed before returning.
  ///
  /// * [int] requestsPerSecond:
  ///   The throttle for this request in sub-requests per second. -1 means no throttle.
  ///
  /// * [String] slices:
  ///   The number of slices this task should be divided into. Defaults to 1, meaning the task isn't sliced into subtasks. Can be set to `auto`.
  Future<Response> deleteByQueryWithHttpInfo(
    String index,
    Object body, {
    String? analyzer,
    bool? analyzeWildcard,
    DefaultOperator? defaultOperator,
    String? df,
    int? from,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    Conflicts? conflicts,
    ExpandWildcards? expandWildcards,
    bool? lenient,
    String? preference,
    String? q,
    List<String>? routing,
    String? scroll,
    SearchType? searchType,
    String? searchTimeout,
    int? size,
    int? maxDocs,
    List<String>? sort,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    int? terminateAfter,
    List<String>? stats,
    bool? version,
    bool? requestCache,
    bool? refresh,
    String? timeout,
    String? waitForActiveShards,
    int? scrollSize,
    bool? waitForCompletion,
    int? requestsPerSecond,
    String? slices,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_delete_by_query'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (analyzer != null) {
      queryParams.addAll(_queryParams('', 'analyzer', analyzer));
    }
    if (analyzeWildcard != null) {
      queryParams.addAll(_queryParams('', 'analyze_wildcard', analyzeWildcard));
    }
    if (defaultOperator != null) {
      queryParams.addAll(_queryParams('', 'default_operator', defaultOperator));
    }
    if (df != null) {
      queryParams.addAll(_queryParams('', 'df', df));
    }
    if (from != null) {
      queryParams.addAll(_queryParams('', 'from', from));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (conflicts != null) {
      queryParams.addAll(_queryParams('', 'conflicts', conflicts));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (lenient != null) {
      queryParams.addAll(_queryParams('', 'lenient', lenient));
    }
    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (q != null) {
      queryParams.addAll(_queryParams('', 'q', q));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('multi', 'routing', routing));
    }
    if (scroll != null) {
      queryParams.addAll(_queryParams('', 'scroll', scroll));
    }
    if (searchType != null) {
      queryParams.addAll(_queryParams('', 'search_type', searchType));
    }
    if (searchTimeout != null) {
      queryParams.addAll(_queryParams('', 'search_timeout', searchTimeout));
    }
    if (size != null) {
      queryParams.addAll(_queryParams('', 'size', size));
    }
    if (maxDocs != null) {
      queryParams.addAll(_queryParams('', 'max_docs', maxDocs));
    }
    if (sort != null) {
      queryParams.addAll(_queryParams('multi', 'sort', sort));
    }
    if (source_ != null) {
      queryParams.addAll(_queryParams('multi', '_source', source_));
    }
    if (sourceExcludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_excludes', sourceExcludes));
    }
    if (sourceIncludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_includes', sourceIncludes));
    }
    if (terminateAfter != null) {
      queryParams.addAll(_queryParams('', 'terminate_after', terminateAfter));
    }
    if (stats != null) {
      queryParams.addAll(_queryParams('multi', 'stats', stats));
    }
    if (version != null) {
      queryParams.addAll(_queryParams('', 'version', version));
    }
    if (requestCache != null) {
      queryParams.addAll(_queryParams('', 'request_cache', requestCache));
    }
    if (refresh != null) {
      queryParams.addAll(_queryParams('', 'refresh', refresh));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (waitForActiveShards != null) {
      queryParams.addAll(
          _queryParams('', 'wait_for_active_shards', waitForActiveShards));
    }
    if (scrollSize != null) {
      queryParams.addAll(_queryParams('', 'scroll_size', scrollSize));
    }
    if (waitForCompletion != null) {
      queryParams
          .addAll(_queryParams('', 'wait_for_completion', waitForCompletion));
    }
    if (requestsPerSecond != null) {
      queryParams
          .addAll(_queryParams('', 'requests_per_second', requestsPerSecond));
    }
    if (slices != null) {
      queryParams.addAll(_queryParams('', 'slices', slices));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Deletes documents matching the provided query.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcard and prefix queries should be analyzed.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The field to use as default where no field prefix is given in the query string.
  ///
  /// * [int] from:
  ///   Starting offset.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [Conflicts] conflicts:
  ///   What to do when the operation encounters version conflicts?.
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [List<String>] routing:
  ///   Comma-separated list of specific routing values.
  ///
  /// * [String] scroll:
  ///   Specify how long a consistent view of the index should be maintained for scrolled search.
  ///
  /// * [SearchType] searchType:
  ///   Search operation type.
  ///
  /// * [String] searchTimeout:
  ///   Explicit timeout for each search request. Defaults to no timeout.
  ///
  /// * [int] size:
  ///   Deprecated, please use `max_docs` instead.
  ///
  /// * [int] maxDocs:
  ///   Maximum number of documents to process (default: all documents).
  ///
  /// * [List<String>] sort:
  ///   Comma-separated list of <field>:<direction> pairs.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  ///
  /// * [int] terminateAfter:
  ///   The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
  ///
  /// * [List<String>] stats:
  ///   Specific 'tag' of the request for logging and statistical purposes.
  ///
  /// * [bool] version:
  ///   Whether to return document version as part of a hit.
  ///
  /// * [bool] requestCache:
  ///   Specify if request cache should be used for this request or not, defaults to index level setting.
  ///
  /// * [bool] refresh:
  ///   Refresh the shard containing the document before performing the operation.
  ///
  /// * [String] timeout:
  ///   Time each individual bulk request should wait for shards that are unavailable.
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
  ///
  /// * [int] scrollSize:
  ///   Size on the scroll request powering the operation.
  ///
  /// * [bool] waitForCompletion:
  ///   Should this request wait until the operation has completed before returning.
  ///
  /// * [int] requestsPerSecond:
  ///   The throttle for this request in sub-requests per second. -1 means no throttle.
  ///
  /// * [String] slices:
  ///   The number of slices this task should be divided into. Defaults to 1, meaning the task isn't sliced into subtasks. Can be set to `auto`.
  Future<void> deleteByQuery(
    String index,
    Object body, {
    String? analyzer,
    bool? analyzeWildcard,
    DefaultOperator? defaultOperator,
    String? df,
    int? from,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    Conflicts? conflicts,
    ExpandWildcards? expandWildcards,
    bool? lenient,
    String? preference,
    String? q,
    List<String>? routing,
    String? scroll,
    SearchType? searchType,
    String? searchTimeout,
    int? size,
    int? maxDocs,
    List<String>? sort,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    int? terminateAfter,
    List<String>? stats,
    bool? version,
    bool? requestCache,
    bool? refresh,
    String? timeout,
    String? waitForActiveShards,
    int? scrollSize,
    bool? waitForCompletion,
    int? requestsPerSecond,
    String? slices,
  }) async {
    final response = await deleteByQueryWithHttpInfo(
      index,
      body,
      analyzer: analyzer,
      analyzeWildcard: analyzeWildcard,
      defaultOperator: defaultOperator,
      df: df,
      from: from,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      conflicts: conflicts,
      expandWildcards: expandWildcards,
      lenient: lenient,
      preference: preference,
      q: q,
      routing: routing,
      scroll: scroll,
      searchType: searchType,
      searchTimeout: searchTimeout,
      size: size,
      maxDocs: maxDocs,
      sort: sort,
      source_: source_,
      sourceExcludes: sourceExcludes,
      sourceIncludes: sourceIncludes,
      terminateAfter: terminateAfter,
      stats: stats,
      version: version,
      requestCache: requestCache,
      refresh: refresh,
      timeout: timeout,
      waitForActiveShards: waitForActiveShards,
      scrollSize: scrollSize,
      waitForCompletion: waitForCompletion,
      requestsPerSecond: requestsPerSecond,
      slices: slices,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Changes the number of requests per second for a particular Delete By Query operation.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] taskId (required):
  ///   The task id to rethrottle.
  ///
  /// * [int] requestsPerSecond (required):
  ///   The throttle for this request in sub-requests per second. -1 means no throttle.
  Future<Response> deleteByQueryRethrottleWithHttpInfo(
    String taskId,
    int requestsPerSecond,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_delete_by_query/{task_id}/_rethrottle'
        .replaceAll('{task_id}', taskId);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    queryParams
        .addAll(_queryParams('', 'requests_per_second', requestsPerSecond));

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Changes the number of requests per second for a particular Delete By Query operation.
  ///
  /// Parameters:
  ///
  /// * [String] taskId (required):
  ///   The task id to rethrottle.
  ///
  /// * [int] requestsPerSecond (required):
  ///   The throttle for this request in sub-requests per second. -1 means no throttle.
  Future<void> deleteByQueryRethrottle(
    String taskId,
    int requestsPerSecond,
  ) async {
    final response = await deleteByQueryRethrottleWithHttpInfo(
      taskId,
      requestsPerSecond,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Deletes all distinguished names in the specified clusters or nodes allow list.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] clusterName (required):
  Future<Response> deleteDistinguishedNamesWithHttpInfo(
    String clusterName,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/nodesdn/{cluster_name}'
        .replaceAll('{cluster_name}', clusterName);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'DELETE',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Deletes all distinguished names in the specified clusters or nodes allow list.
  ///
  /// Parameters:
  ///
  /// * [String] clusterName (required):
  Future<DeleteDistinguishedNamesResponseContent?> deleteDistinguishedNames(
    String clusterName,
  ) async {
    final response = await deleteDistinguishedNamesWithHttpInfo(
      clusterName,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'DeleteDistinguishedNamesResponseContent',
      ) as DeleteDistinguishedNamesResponseContent;
    }
    return null;
  }

  /// Deletes one or more point in time searches based on the IDs passed.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [DeletePitBodyParams] deletePitBodyParams:
  Future<Response> deletePitWithHttpInfo({
    DeletePitBodyParams? deletePitBodyParams,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_search/point_in_time';

    // ignore: prefer_final_locals
    Object? postBody = deletePitBodyParams;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'DELETE',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Deletes one or more point in time searches based on the IDs passed.
  ///
  /// Parameters:
  ///
  /// * [DeletePitBodyParams] deletePitBodyParams:
  Future<DeletePitResponseContent?> deletePit({
    DeletePitBodyParams? deletePitBodyParams,
  }) async {
    final response = await deletePitWithHttpInfo(
      deletePitBodyParams: deletePitBodyParams,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'DeletePitResponseContent',
      ) as DeletePitResponseContent;
    }
    return null;
  }

  /// Delete the specified role.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] role (required):
  Future<Response> deleteRoleWithHttpInfo(
    String role,
  ) async {
    // ignore: prefer_const_declarations
    final path =
        r'/_plugins/_security/api/roles/{role}'.replaceAll('{role}', role);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'DELETE',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Delete the specified role.
  ///
  /// Parameters:
  ///
  /// * [String] role (required):
  Future<DeleteRoleResponseContent?> deleteRole(
    String role,
  ) async {
    final response = await deleteRoleWithHttpInfo(
      role,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'DeleteRoleResponseContent',
      ) as DeleteRoleResponseContent;
    }
    return null;
  }

  /// Deletes the specified role mapping.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] role (required):
  Future<Response> deleteRoleMappingWithHttpInfo(
    String role,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/rolesmapping/{role}'
        .replaceAll('{role}', role);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'DELETE',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Deletes the specified role mapping.
  ///
  /// Parameters:
  ///
  /// * [String] role (required):
  Future<DeleteRoleMappingResponseContent?> deleteRoleMapping(
    String role,
  ) async {
    final response = await deleteRoleMappingWithHttpInfo(
      role,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'DeleteRoleMappingResponseContent',
      ) as DeleteRoleMappingResponseContent;
    }
    return null;
  }

  /// Deletes a script.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Script ID.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<Response> deleteScriptWithHttpInfo(
    String id, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_scripts/{id}'.replaceAll('{id}', id);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'DELETE',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Deletes a script.
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Script ID.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<void> deleteScript(
    String id, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    final response = await deleteScriptWithHttpInfo(
      id,
      timeout: timeout,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Delete the specified tenant.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] tenant (required):
  Future<Response> deleteTenantWithHttpInfo(
    String tenant,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/tenants/{tenant}'
        .replaceAll('{tenant}', tenant);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'DELETE',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Delete the specified tenant.
  ///
  /// Parameters:
  ///
  /// * [String] tenant (required):
  Future<DeleteTenantResponseContent?> deleteTenant(
    String tenant,
  ) async {
    final response = await deleteTenantWithHttpInfo(
      tenant,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'DeleteTenantResponseContent',
      ) as DeleteTenantResponseContent;
    }
    return null;
  }

  /// Delete the specified user.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] username (required):
  Future<Response> deleteUserWithHttpInfo(
    String username,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/internalusers/{username}'
        .replaceAll('{username}', username);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'DELETE',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Delete the specified user.
  ///
  /// Parameters:
  ///
  /// * [String] username (required):
  Future<DeleteUserResponseContent?> deleteUser(
    String username,
  ) async {
    final response = await deleteUserWithHttpInfo(
      username,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'DeleteUserResponseContent',
      ) as DeleteUserResponseContent;
    }
    return null;
  }

  /// Returns information about whether a document exists in an index.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Document ID.
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [List<String>] storedFields:
  ///   Comma-separated list of stored fields to return.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [bool] realtime:
  ///   Specify whether to perform the operation in realtime or search mode.
  ///
  /// * [bool] refresh:
  ///   Refresh the shard containing the document before performing the operation.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  Future<Response> existsWithHttpInfo(
    String id,
    String index, {
    List<String>? storedFields,
    String? preference,
    bool? realtime,
    bool? refresh,
    String? routing,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    int? version,
    VersionType? versionType,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_doc/{id}'
        .replaceAll('{id}', id)
        .replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (storedFields != null) {
      queryParams.addAll(_queryParams('multi', 'stored_fields', storedFields));
    }
    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (realtime != null) {
      queryParams.addAll(_queryParams('', 'realtime', realtime));
    }
    if (refresh != null) {
      queryParams.addAll(_queryParams('', 'refresh', refresh));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (source_ != null) {
      queryParams.addAll(_queryParams('multi', '_source', source_));
    }
    if (sourceExcludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_excludes', sourceExcludes));
    }
    if (sourceIncludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_includes', sourceIncludes));
    }
    if (version != null) {
      queryParams.addAll(_queryParams('', 'version', version));
    }
    if (versionType != null) {
      queryParams.addAll(_queryParams('', 'version_type', versionType));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'HEAD',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about whether a document exists in an index.
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Document ID.
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [List<String>] storedFields:
  ///   Comma-separated list of stored fields to return.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [bool] realtime:
  ///   Specify whether to perform the operation in realtime or search mode.
  ///
  /// * [bool] refresh:
  ///   Refresh the shard containing the document before performing the operation.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  Future<void> exists(
    String id,
    String index, {
    List<String>? storedFields,
    String? preference,
    bool? realtime,
    bool? refresh,
    String? routing,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    int? version,
    VersionType? versionType,
  }) async {
    final response = await existsWithHttpInfo(
      id,
      index,
      storedFields: storedFields,
      preference: preference,
      realtime: realtime,
      refresh: refresh,
      routing: routing,
      source_: source_,
      sourceExcludes: sourceExcludes,
      sourceIncludes: sourceIncludes,
      version: version,
      versionType: versionType,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about whether a document source exists in an index.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Document ID.
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [bool] realtime:
  ///   Specify whether to perform the operation in realtime or search mode.
  ///
  /// * [bool] refresh:
  ///   Refresh the shard containing the document before performing the operation.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  Future<Response> existsSourceWithHttpInfo(
    String id,
    String index, {
    String? preference,
    bool? realtime,
    bool? refresh,
    String? routing,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    int? version,
    VersionType? versionType,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_source/{id}'
        .replaceAll('{id}', id)
        .replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (realtime != null) {
      queryParams.addAll(_queryParams('', 'realtime', realtime));
    }
    if (refresh != null) {
      queryParams.addAll(_queryParams('', 'refresh', refresh));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (source_ != null) {
      queryParams.addAll(_queryParams('multi', '_source', source_));
    }
    if (sourceExcludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_excludes', sourceExcludes));
    }
    if (sourceIncludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_includes', sourceIncludes));
    }
    if (version != null) {
      queryParams.addAll(_queryParams('', 'version', version));
    }
    if (versionType != null) {
      queryParams.addAll(_queryParams('', 'version_type', versionType));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'HEAD',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about whether a document source exists in an index.
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Document ID.
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [bool] realtime:
  ///   Specify whether to perform the operation in realtime or search mode.
  ///
  /// * [bool] refresh:
  ///   Refresh the shard containing the document before performing the operation.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  Future<void> existsSource(
    String id,
    String index, {
    String? preference,
    bool? realtime,
    bool? refresh,
    String? routing,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    int? version,
    VersionType? versionType,
  }) async {
    final response = await existsSourceWithHttpInfo(
      id,
      index,
      preference: preference,
      realtime: realtime,
      refresh: refresh,
      routing: routing,
      source_: source_,
      sourceExcludes: sourceExcludes,
      sourceIncludes: sourceIncludes,
      version: version,
      versionType: versionType,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about why a specific matches (or doesn't match) a query.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Document ID.
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcards and prefix queries in the query string query should be analyzed.
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The default field for query string query.
  ///
  /// * [List<String>] storedFields:
  ///   Comma-separated list of stored fields to return.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  Future<Response> explainGetWithHttpInfo(
    String id,
    String index, {
    bool? analyzeWildcard,
    String? analyzer,
    DefaultOperator? defaultOperator,
    String? df,
    List<String>? storedFields,
    bool? lenient,
    String? preference,
    String? q,
    String? routing,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_explain/{id}'
        .replaceAll('{id}', id)
        .replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (analyzeWildcard != null) {
      queryParams.addAll(_queryParams('', 'analyze_wildcard', analyzeWildcard));
    }
    if (analyzer != null) {
      queryParams.addAll(_queryParams('', 'analyzer', analyzer));
    }
    if (defaultOperator != null) {
      queryParams.addAll(_queryParams('', 'default_operator', defaultOperator));
    }
    if (df != null) {
      queryParams.addAll(_queryParams('', 'df', df));
    }
    if (storedFields != null) {
      queryParams.addAll(_queryParams('multi', 'stored_fields', storedFields));
    }
    if (lenient != null) {
      queryParams.addAll(_queryParams('', 'lenient', lenient));
    }
    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (q != null) {
      queryParams.addAll(_queryParams('', 'q', q));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (source_ != null) {
      queryParams.addAll(_queryParams('multi', '_source', source_));
    }
    if (sourceExcludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_excludes', sourceExcludes));
    }
    if (sourceIncludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_includes', sourceIncludes));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about why a specific matches (or doesn't match) a query.
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Document ID.
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcards and prefix queries in the query string query should be analyzed.
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The default field for query string query.
  ///
  /// * [List<String>] storedFields:
  ///   Comma-separated list of stored fields to return.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  Future<void> explainGet(
    String id,
    String index, {
    bool? analyzeWildcard,
    String? analyzer,
    DefaultOperator? defaultOperator,
    String? df,
    List<String>? storedFields,
    bool? lenient,
    String? preference,
    String? q,
    String? routing,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
  }) async {
    final response = await explainGetWithHttpInfo(
      id,
      index,
      analyzeWildcard: analyzeWildcard,
      analyzer: analyzer,
      defaultOperator: defaultOperator,
      df: df,
      storedFields: storedFields,
      lenient: lenient,
      preference: preference,
      q: q,
      routing: routing,
      source_: source_,
      sourceExcludes: sourceExcludes,
      sourceIncludes: sourceIncludes,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about why a specific matches (or doesn't match) a query.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Document ID.
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcards and prefix queries in the query string query should be analyzed.
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The default field for query string query.
  ///
  /// * [List<String>] storedFields:
  ///   Comma-separated list of stored fields to return.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  ///
  /// * [Object] body:
  Future<Response> explainPostWithHttpInfo(
    String id,
    String index, {
    bool? analyzeWildcard,
    String? analyzer,
    DefaultOperator? defaultOperator,
    String? df,
    List<String>? storedFields,
    bool? lenient,
    String? preference,
    String? q,
    String? routing,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_explain/{id}'
        .replaceAll('{id}', id)
        .replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (analyzeWildcard != null) {
      queryParams.addAll(_queryParams('', 'analyze_wildcard', analyzeWildcard));
    }
    if (analyzer != null) {
      queryParams.addAll(_queryParams('', 'analyzer', analyzer));
    }
    if (defaultOperator != null) {
      queryParams.addAll(_queryParams('', 'default_operator', defaultOperator));
    }
    if (df != null) {
      queryParams.addAll(_queryParams('', 'df', df));
    }
    if (storedFields != null) {
      queryParams.addAll(_queryParams('multi', 'stored_fields', storedFields));
    }
    if (lenient != null) {
      queryParams.addAll(_queryParams('', 'lenient', lenient));
    }
    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (q != null) {
      queryParams.addAll(_queryParams('', 'q', q));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (source_ != null) {
      queryParams.addAll(_queryParams('multi', '_source', source_));
    }
    if (sourceExcludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_excludes', sourceExcludes));
    }
    if (sourceIncludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_includes', sourceIncludes));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about why a specific matches (or doesn't match) a query.
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Document ID.
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcards and prefix queries in the query string query should be analyzed.
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The default field for query string query.
  ///
  /// * [List<String>] storedFields:
  ///   Comma-separated list of stored fields to return.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  ///
  /// * [Object] body:
  Future<void> explainPost(
    String id,
    String index, {
    bool? analyzeWildcard,
    String? analyzer,
    DefaultOperator? defaultOperator,
    String? df,
    List<String>? storedFields,
    bool? lenient,
    String? preference,
    String? q,
    String? routing,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    Object? body,
  }) async {
    final response = await explainPostWithHttpInfo(
      id,
      index,
      analyzeWildcard: analyzeWildcard,
      analyzer: analyzer,
      defaultOperator: defaultOperator,
      df: df,
      storedFields: storedFields,
      lenient: lenient,
      preference: preference,
      q: q,
      routing: routing,
      source_: source_,
      sourceExcludes: sourceExcludes,
      sourceIncludes: sourceIncludes,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns the information about the capabilities of fields among multiple indices.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of field names.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] includeUnmapped:
  ///   Indicates whether unmapped fields should be included in the response.
  Future<Response> fieldCapsGetWithHttpInfo({
    List<String>? fields,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? includeUnmapped,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_field_caps';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (fields != null) {
      queryParams.addAll(_queryParams('multi', 'fields', fields));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (includeUnmapped != null) {
      queryParams.addAll(_queryParams('', 'include_unmapped', includeUnmapped));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns the information about the capabilities of fields among multiple indices.
  ///
  /// Parameters:
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of field names.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] includeUnmapped:
  ///   Indicates whether unmapped fields should be included in the response.
  Future<void> fieldCapsGet({
    List<String>? fields,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? includeUnmapped,
  }) async {
    final response = await fieldCapsGetWithHttpInfo(
      fields: fields,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      includeUnmapped: includeUnmapped,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns the information about the capabilities of fields among multiple indices.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of field names.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] includeUnmapped:
  ///   Indicates whether unmapped fields should be included in the response.
  Future<Response> fieldCapsGetWithIndexWithHttpInfo(
    String index, {
    List<String>? fields,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? includeUnmapped,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_field_caps'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (fields != null) {
      queryParams.addAll(_queryParams('multi', 'fields', fields));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (includeUnmapped != null) {
      queryParams.addAll(_queryParams('', 'include_unmapped', includeUnmapped));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns the information about the capabilities of fields among multiple indices.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of field names.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] includeUnmapped:
  ///   Indicates whether unmapped fields should be included in the response.
  Future<void> fieldCapsGetWithIndex(
    String index, {
    List<String>? fields,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? includeUnmapped,
  }) async {
    final response = await fieldCapsGetWithIndexWithHttpInfo(
      index,
      fields: fields,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      includeUnmapped: includeUnmapped,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns the information about the capabilities of fields among multiple indices.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of field names.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] includeUnmapped:
  ///   Indicates whether unmapped fields should be included in the response.
  ///
  /// * [Object] body:
  Future<Response> fieldCapsPostWithHttpInfo({
    List<String>? fields,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? includeUnmapped,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_field_caps';

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (fields != null) {
      queryParams.addAll(_queryParams('multi', 'fields', fields));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (includeUnmapped != null) {
      queryParams.addAll(_queryParams('', 'include_unmapped', includeUnmapped));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns the information about the capabilities of fields among multiple indices.
  ///
  /// Parameters:
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of field names.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] includeUnmapped:
  ///   Indicates whether unmapped fields should be included in the response.
  ///
  /// * [Object] body:
  Future<void> fieldCapsPost({
    List<String>? fields,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? includeUnmapped,
    Object? body,
  }) async {
    final response = await fieldCapsPostWithHttpInfo(
      fields: fields,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      includeUnmapped: includeUnmapped,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns the information about the capabilities of fields among multiple indices.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of field names.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] includeUnmapped:
  ///   Indicates whether unmapped fields should be included in the response.
  ///
  /// * [Object] body:
  Future<Response> fieldCapsPostWithIndexWithHttpInfo(
    String index, {
    List<String>? fields,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? includeUnmapped,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_field_caps'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (fields != null) {
      queryParams.addAll(_queryParams('multi', 'fields', fields));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (includeUnmapped != null) {
      queryParams.addAll(_queryParams('', 'include_unmapped', includeUnmapped));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns the information about the capabilities of fields among multiple indices.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of field names.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] includeUnmapped:
  ///   Indicates whether unmapped fields should be included in the response.
  ///
  /// * [Object] body:
  Future<void> fieldCapsPostWithIndex(
    String index, {
    List<String>? fields,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? includeUnmapped,
    Object? body,
  }) async {
    final response = await fieldCapsPostWithIndexWithHttpInfo(
      index,
      fields: fields,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      includeUnmapped: includeUnmapped,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Flushes the Security plugin user, authentication, and authorization cache.
  ///
  /// Note: This method returns the HTTP [Response].
  Future<Response> flushCacheWithHttpInfo() async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/cache';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'DELETE',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Flushes the Security plugin user, authentication, and authorization cache.
  Future<FlushCacheResponseContent?> flushCache() async {
    final response = await flushCacheWithHttpInfo();
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'FlushCacheResponseContent',
      ) as FlushCacheResponseContent;
    }
    return null;
  }

  /// Returns account details for the current user.
  ///
  /// Note: This method returns the HTTP [Response].
  Future<Response> getAccountDetailsWithHttpInfo() async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/account';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns account details for the current user.
  Future<AccountDetails?> getAccountDetails() async {
    final response = await getAccountDetailsWithHttpInfo();
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'AccountDetails',
      ) as AccountDetails;
    }
    return null;
  }

  /// Retrieves one action group.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] actionGroup (required):
  ///   Action group to retrieve.
  Future<Response> getActionGroupWithHttpInfo(
    String actionGroup,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/actiongroups/{action_group}'
        .replaceAll('{action_group}', actionGroup);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Retrieves one action group.
  ///
  /// Parameters:
  ///
  /// * [String] actionGroup (required):
  ///   Action group to retrieve.
  Future<Map<String, ActionGroup>?> getActionGroup(
    String actionGroup,
  ) async {
    final response = await getActionGroupWithHttpInfo(
      actionGroup,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return Map<String, ActionGroup>.from(
        await apiClient.deserializeAsync(
            await _decodeBodyBytes(response), 'Map<String, ActionGroup>'),
      );
    }
    return null;
  }

  /// Retrieves all action groups.
  ///
  /// Note: This method returns the HTTP [Response].
  Future<Response> getActionGroupsWithHttpInfo() async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/actiongroups/';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Retrieves all action groups.
  Future<Map<String, ActionGroup>?> getActionGroups() async {
    final response = await getActionGroupsWithHttpInfo();
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return Map<String, ActionGroup>.from(
        await apiClient.deserializeAsync(
            await _decodeBodyBytes(response), 'Map<String, ActionGroup>'),
      );
    }
    return null;
  }

  /// Lists all active point in time searches.
  ///
  /// Note: This method returns the HTTP [Response].
  Future<Response> getAllPitsWithHttpInfo() async {
    // ignore: prefer_const_declarations
    final path = r'/_search/point_in_time/_all';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Lists all active point in time searches.
  Future<GetAllPitsResponseContent?> getAllPits() async {
    final response = await getAllPitsWithHttpInfo();
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'GetAllPitsResponseContent',
      ) as GetAllPitsResponseContent;
    }
    return null;
  }

  /// Retrieves the audit configuration.
  ///
  /// Note: This method returns the HTTP [Response].
  Future<Response> getAuditConfigurationWithHttpInfo() async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/audit';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Retrieves the audit configuration.
  Future<AuditConfigWithReadOnly?> getAuditConfiguration() async {
    final response = await getAuditConfigurationWithHttpInfo();
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'AuditConfigWithReadOnly',
      ) as AuditConfigWithReadOnly;
    }
    return null;
  }

  /// Retrieves the clusters security certificates.
  ///
  /// Note: This method returns the HTTP [Response].
  Future<Response> getCertificatesWithHttpInfo() async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/ssl/certs';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Retrieves the clusters security certificates.
  Future<GetCertificatesResponseContent?> getCertificates() async {
    final response = await getCertificatesWithHttpInfo();
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'GetCertificatesResponseContent',
      ) as GetCertificatesResponseContent;
    }
    return null;
  }

  /// Returns the current Security plugin configuration in JSON format.
  ///
  /// Note: This method returns the HTTP [Response].
  Future<Response> getConfigurationWithHttpInfo() async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/securityconfig';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns the current Security plugin configuration in JSON format.
  Future<DynamicConfig?> getConfiguration() async {
    final response = await getConfigurationWithHttpInfo();
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'DynamicConfig',
      ) as DynamicConfig;
    }
    return null;
  }

  /// Retrieves all distinguished names in the allow list.
  ///
  /// Note: This method returns the HTTP [Response].
  Future<Response> getDistinguishedNamesWithHttpInfo() async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/nodesdn';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Retrieves all distinguished names in the allow list.
  Future<Map<String, DistinguishedNames>?> getDistinguishedNames() async {
    final response = await getDistinguishedNamesWithHttpInfo();
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return Map<String, DistinguishedNames>.from(
        await apiClient.deserializeAsync(await _decodeBodyBytes(response),
            'Map<String, DistinguishedNames>'),
      );
    }
    return null;
  }

  /// Retrieve distinguished names of a specified cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] clusterName (required):
  Future<Response> getDistinguishedNamesWithClusterNameWithHttpInfo(
    String clusterName,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/nodesdn/{cluster_name}'
        .replaceAll('{cluster_name}', clusterName);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Retrieve distinguished names of a specified cluster.
  ///
  /// Parameters:
  ///
  /// * [String] clusterName (required):
  Future<Map<String, DistinguishedNames>?> getDistinguishedNamesWithClusterName(
    String clusterName,
  ) async {
    final response = await getDistinguishedNamesWithClusterNameWithHttpInfo(
      clusterName,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return Map<String, DistinguishedNames>.from(
        await apiClient.deserializeAsync(await _decodeBodyBytes(response),
            'Map<String, DistinguishedNames>'),
      );
    }
    return null;
  }

  /// Retrieves one role.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] role (required):
  Future<Response> getRoleWithHttpInfo(
    String role,
  ) async {
    // ignore: prefer_const_declarations
    final path =
        r'/_plugins/_security/api/roles/{role}'.replaceAll('{role}', role);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Retrieves one role.
  ///
  /// Parameters:
  ///
  /// * [String] role (required):
  Future<Map<String, Role>?> getRole(
    String role,
  ) async {
    final response = await getRoleWithHttpInfo(
      role,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return Map<String, Role>.from(
        await apiClient.deserializeAsync(
            await _decodeBodyBytes(response), 'Map<String, Role>'),
      );
    }
    return null;
  }

  /// Retrieves one role mapping.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] role (required):
  Future<Response> getRoleMappingWithHttpInfo(
    String role,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/rolesmapping/{role}'
        .replaceAll('{role}', role);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Retrieves one role mapping.
  ///
  /// Parameters:
  ///
  /// * [String] role (required):
  Future<Map<String, RoleMapping>?> getRoleMapping(
    String role,
  ) async {
    final response = await getRoleMappingWithHttpInfo(
      role,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return Map<String, RoleMapping>.from(
        await apiClient.deserializeAsync(
            await _decodeBodyBytes(response), 'Map<String, RoleMapping>'),
      );
    }
    return null;
  }

  /// Retrieves all role mappings.
  ///
  /// Note: This method returns the HTTP [Response].
  Future<Response> getRoleMappingsWithHttpInfo() async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/rolesmapping';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Retrieves all role mappings.
  Future<Map<String, RoleMapping>?> getRoleMappings() async {
    final response = await getRoleMappingsWithHttpInfo();
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return Map<String, RoleMapping>.from(
        await apiClient.deserializeAsync(
            await _decodeBodyBytes(response), 'Map<String, RoleMapping>'),
      );
    }
    return null;
  }

  /// Retrieves all roles.
  ///
  /// Note: This method returns the HTTP [Response].
  Future<Response> getRolesWithHttpInfo() async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/roles/';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Retrieves all roles.
  Future<Map<String, Role>?> getRoles() async {
    final response = await getRolesWithHttpInfo();
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return Map<String, Role>.from(
        await apiClient.deserializeAsync(
            await _decodeBodyBytes(response), 'Map<String, Role>'),
      );
    }
    return null;
  }

  /// Returns a script.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Script ID.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<Response> getScriptWithHttpInfo(
    String id, {
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_scripts/{id}'.replaceAll('{id}', id);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns a script.
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Script ID.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<void> getScript(
    String id, {
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    final response = await getScriptWithHttpInfo(
      id,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns all script contexts.
  ///
  /// Note: This method returns the HTTP [Response].
  Future<Response> getScriptContextWithHttpInfo() async {
    // ignore: prefer_const_declarations
    final path = r'/_script_context';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns all script contexts.
  Future<void> getScriptContext() async {
    final response = await getScriptContextWithHttpInfo();
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns available script types, languages and contexts.
  ///
  /// Note: This method returns the HTTP [Response].
  Future<Response> getScriptLanguagesWithHttpInfo() async {
    // ignore: prefer_const_declarations
    final path = r'/_script_language';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns available script types, languages and contexts.
  Future<void> getScriptLanguages() async {
    final response = await getScriptLanguagesWithHttpInfo();
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns the source of a document.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Document ID.
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [bool] realtime:
  ///   Specify whether to perform the operation in realtime or search mode.
  ///
  /// * [bool] refresh:
  ///   Refresh the shard containing the document before performing the operation.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  Future<Response> getSourceWithHttpInfo(
    String id,
    String index, {
    String? preference,
    bool? realtime,
    bool? refresh,
    String? routing,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    int? version,
    VersionType? versionType,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_source/{id}'
        .replaceAll('{id}', id)
        .replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (realtime != null) {
      queryParams.addAll(_queryParams('', 'realtime', realtime));
    }
    if (refresh != null) {
      queryParams.addAll(_queryParams('', 'refresh', refresh));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (source_ != null) {
      queryParams.addAll(_queryParams('multi', '_source', source_));
    }
    if (sourceExcludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_excludes', sourceExcludes));
    }
    if (sourceIncludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_includes', sourceIncludes));
    }
    if (version != null) {
      queryParams.addAll(_queryParams('', 'version', version));
    }
    if (versionType != null) {
      queryParams.addAll(_queryParams('', 'version_type', versionType));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns the source of a document.
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Document ID.
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [bool] realtime:
  ///   Specify whether to perform the operation in realtime or search mode.
  ///
  /// * [bool] refresh:
  ///   Refresh the shard containing the document before performing the operation.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  Future<void> getSource(
    String id,
    String index, {
    String? preference,
    bool? realtime,
    bool? refresh,
    String? routing,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    int? version,
    VersionType? versionType,
  }) async {
    final response = await getSourceWithHttpInfo(
      id,
      index,
      preference: preference,
      realtime: realtime,
      refresh: refresh,
      routing: routing,
      source_: source_,
      sourceExcludes: sourceExcludes,
      sourceIncludes: sourceIncludes,
      version: version,
      versionType: versionType,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Retrieves one tenant.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] tenant (required):
  Future<Response> getTenantWithHttpInfo(
    String tenant,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/tenants/{tenant}'
        .replaceAll('{tenant}', tenant);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Retrieves one tenant.
  ///
  /// Parameters:
  ///
  /// * [String] tenant (required):
  Future<Map<String, Tenant>?> getTenant(
    String tenant,
  ) async {
    final response = await getTenantWithHttpInfo(
      tenant,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return Map<String, Tenant>.from(
        await apiClient.deserializeAsync(
            await _decodeBodyBytes(response), 'Map<String, Tenant>'),
      );
    }
    return null;
  }

  /// Retrieves all tenants.
  ///
  /// Note: This method returns the HTTP [Response].
  Future<Response> getTenantsWithHttpInfo() async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/tenants/';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Retrieves all tenants.
  Future<Map<String, Tenant>?> getTenants() async {
    final response = await getTenantsWithHttpInfo();
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return Map<String, Tenant>.from(
        await apiClient.deserializeAsync(
            await _decodeBodyBytes(response), 'Map<String, Tenant>'),
      );
    }
    return null;
  }

  /// Retrieve one internal user.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] username (required):
  Future<Response> getUserWithHttpInfo(
    String username,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/internalusers/{username}'
        .replaceAll('{username}', username);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Retrieve one internal user.
  ///
  /// Parameters:
  ///
  /// * [String] username (required):
  Future<Map<String, User>?> getUser(
    String username,
  ) async {
    final response = await getUserWithHttpInfo(
      username,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return Map<String, User>.from(
        await apiClient.deserializeAsync(
            await _decodeBodyBytes(response), 'Map<String, User>'),
      );
    }
    return null;
  }

  /// Retrieve all internal users.
  ///
  /// Note: This method returns the HTTP [Response].
  Future<Response> getUsersWithHttpInfo() async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/internalusers';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Retrieve all internal users.
  Future<Map<String, User>?> getUsers() async {
    final response = await getUsersWithHttpInfo();
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return Map<String, User>.from(
        await apiClient.deserializeAsync(
            await _decodeBodyBytes(response), 'Map<String, User>'),
      );
    }
    return null;
  }

  /// Creates or updates a document in an index.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
  ///
  /// * [OpType] opType:
  ///   Explicit operation type. Defaults to `index` for requests with an explicit document ID, and to `create`for requests without an explicit document ID.
  ///
  /// * [RefreshEnum] refresh:
  ///   If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  ///
  /// * [int] ifSeqNo:
  ///   only perform the operation if the last operation that has changed the document has the specified sequence number.
  ///
  /// * [int] ifPrimaryTerm:
  ///   only perform the operation if the last operation that has changed the document has the specified primary term.
  ///
  /// * [String] pipeline:
  ///   The pipeline id to preprocess incoming documents with.
  ///
  /// * [bool] requireAlias:
  ///   When true, requires destination to be an alias.
  Future<Response> indexPostWithHttpInfo(
    String index,
    Object body, {
    String? waitForActiveShards,
    OpType? opType,
    RefreshEnum? refresh,
    String? routing,
    String? timeout,
    int? version,
    VersionType? versionType,
    int? ifSeqNo,
    int? ifPrimaryTerm,
    String? pipeline,
    bool? requireAlias,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_doc'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (waitForActiveShards != null) {
      queryParams.addAll(
          _queryParams('', 'wait_for_active_shards', waitForActiveShards));
    }
    if (opType != null) {
      queryParams.addAll(_queryParams('', 'op_type', opType));
    }
    if (refresh != null) {
      queryParams.addAll(_queryParams('', 'refresh', refresh));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (version != null) {
      queryParams.addAll(_queryParams('', 'version', version));
    }
    if (versionType != null) {
      queryParams.addAll(_queryParams('', 'version_type', versionType));
    }
    if (ifSeqNo != null) {
      queryParams.addAll(_queryParams('', 'if_seq_no', ifSeqNo));
    }
    if (ifPrimaryTerm != null) {
      queryParams.addAll(_queryParams('', 'if_primary_term', ifPrimaryTerm));
    }
    if (pipeline != null) {
      queryParams.addAll(_queryParams('', 'pipeline', pipeline));
    }
    if (requireAlias != null) {
      queryParams.addAll(_queryParams('', 'require_alias', requireAlias));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates or updates a document in an index.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
  ///
  /// * [OpType] opType:
  ///   Explicit operation type. Defaults to `index` for requests with an explicit document ID, and to `create`for requests without an explicit document ID.
  ///
  /// * [RefreshEnum] refresh:
  ///   If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  ///
  /// * [int] ifSeqNo:
  ///   only perform the operation if the last operation that has changed the document has the specified sequence number.
  ///
  /// * [int] ifPrimaryTerm:
  ///   only perform the operation if the last operation that has changed the document has the specified primary term.
  ///
  /// * [String] pipeline:
  ///   The pipeline id to preprocess incoming documents with.
  ///
  /// * [bool] requireAlias:
  ///   When true, requires destination to be an alias.
  Future<void> indexPost(
    String index,
    Object body, {
    String? waitForActiveShards,
    OpType? opType,
    RefreshEnum? refresh,
    String? routing,
    String? timeout,
    int? version,
    VersionType? versionType,
    int? ifSeqNo,
    int? ifPrimaryTerm,
    String? pipeline,
    bool? requireAlias,
  }) async {
    final response = await indexPostWithHttpInfo(
      index,
      body,
      waitForActiveShards: waitForActiveShards,
      opType: opType,
      refresh: refresh,
      routing: routing,
      timeout: timeout,
      version: version,
      versionType: versionType,
      ifSeqNo: ifSeqNo,
      ifPrimaryTerm: ifPrimaryTerm,
      pipeline: pipeline,
      requireAlias: requireAlias,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Creates or updates a document in an index.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Document ID.
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
  ///
  /// * [OpType] opType:
  ///   Explicit operation type. Defaults to `index` for requests with an explicit document ID, and to `create`for requests without an explicit document ID.
  ///
  /// * [RefreshEnum] refresh:
  ///   If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  ///
  /// * [int] ifSeqNo:
  ///   only perform the operation if the last operation that has changed the document has the specified sequence number.
  ///
  /// * [int] ifPrimaryTerm:
  ///   only perform the operation if the last operation that has changed the document has the specified primary term.
  ///
  /// * [String] pipeline:
  ///   The pipeline id to preprocess incoming documents with.
  ///
  /// * [bool] requireAlias:
  ///   When true, requires destination to be an alias.
  Future<Response> indexPostWithIdWithHttpInfo(
    String id,
    String index,
    Object body, {
    String? waitForActiveShards,
    OpType? opType,
    RefreshEnum? refresh,
    String? routing,
    String? timeout,
    int? version,
    VersionType? versionType,
    int? ifSeqNo,
    int? ifPrimaryTerm,
    String? pipeline,
    bool? requireAlias,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_doc/{id}'
        .replaceAll('{id}', id)
        .replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (waitForActiveShards != null) {
      queryParams.addAll(
          _queryParams('', 'wait_for_active_shards', waitForActiveShards));
    }
    if (opType != null) {
      queryParams.addAll(_queryParams('', 'op_type', opType));
    }
    if (refresh != null) {
      queryParams.addAll(_queryParams('', 'refresh', refresh));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (version != null) {
      queryParams.addAll(_queryParams('', 'version', version));
    }
    if (versionType != null) {
      queryParams.addAll(_queryParams('', 'version_type', versionType));
    }
    if (ifSeqNo != null) {
      queryParams.addAll(_queryParams('', 'if_seq_no', ifSeqNo));
    }
    if (ifPrimaryTerm != null) {
      queryParams.addAll(_queryParams('', 'if_primary_term', ifPrimaryTerm));
    }
    if (pipeline != null) {
      queryParams.addAll(_queryParams('', 'pipeline', pipeline));
    }
    if (requireAlias != null) {
      queryParams.addAll(_queryParams('', 'require_alias', requireAlias));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates or updates a document in an index.
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Document ID.
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
  ///
  /// * [OpType] opType:
  ///   Explicit operation type. Defaults to `index` for requests with an explicit document ID, and to `create`for requests without an explicit document ID.
  ///
  /// * [RefreshEnum] refresh:
  ///   If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  ///
  /// * [int] ifSeqNo:
  ///   only perform the operation if the last operation that has changed the document has the specified sequence number.
  ///
  /// * [int] ifPrimaryTerm:
  ///   only perform the operation if the last operation that has changed the document has the specified primary term.
  ///
  /// * [String] pipeline:
  ///   The pipeline id to preprocess incoming documents with.
  ///
  /// * [bool] requireAlias:
  ///   When true, requires destination to be an alias.
  Future<void> indexPostWithId(
    String id,
    String index,
    Object body, {
    String? waitForActiveShards,
    OpType? opType,
    RefreshEnum? refresh,
    String? routing,
    String? timeout,
    int? version,
    VersionType? versionType,
    int? ifSeqNo,
    int? ifPrimaryTerm,
    String? pipeline,
    bool? requireAlias,
  }) async {
    final response = await indexPostWithIdWithHttpInfo(
      id,
      index,
      body,
      waitForActiveShards: waitForActiveShards,
      opType: opType,
      refresh: refresh,
      routing: routing,
      timeout: timeout,
      version: version,
      versionType: versionType,
      ifSeqNo: ifSeqNo,
      ifPrimaryTerm: ifPrimaryTerm,
      pipeline: pipeline,
      requireAlias: requireAlias,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Creates or updates a document in an index.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Document ID.
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
  ///
  /// * [OpType] opType:
  ///   Explicit operation type. Defaults to `index` for requests with an explicit document ID, and to `create`for requests without an explicit document ID.
  ///
  /// * [RefreshEnum] refresh:
  ///   If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  ///
  /// * [int] ifSeqNo:
  ///   only perform the operation if the last operation that has changed the document has the specified sequence number.
  ///
  /// * [int] ifPrimaryTerm:
  ///   only perform the operation if the last operation that has changed the document has the specified primary term.
  ///
  /// * [String] pipeline:
  ///   The pipeline id to preprocess incoming documents with.
  ///
  /// * [bool] requireAlias:
  ///   When true, requires destination to be an alias.
  Future<Response> indexPutWithIdWithHttpInfo(
    String id,
    String index,
    Object body, {
    String? waitForActiveShards,
    OpType? opType,
    RefreshEnum? refresh,
    String? routing,
    String? timeout,
    int? version,
    VersionType? versionType,
    int? ifSeqNo,
    int? ifPrimaryTerm,
    String? pipeline,
    bool? requireAlias,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_doc/{id}'
        .replaceAll('{id}', id)
        .replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (waitForActiveShards != null) {
      queryParams.addAll(
          _queryParams('', 'wait_for_active_shards', waitForActiveShards));
    }
    if (opType != null) {
      queryParams.addAll(_queryParams('', 'op_type', opType));
    }
    if (refresh != null) {
      queryParams.addAll(_queryParams('', 'refresh', refresh));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (version != null) {
      queryParams.addAll(_queryParams('', 'version', version));
    }
    if (versionType != null) {
      queryParams.addAll(_queryParams('', 'version_type', versionType));
    }
    if (ifSeqNo != null) {
      queryParams.addAll(_queryParams('', 'if_seq_no', ifSeqNo));
    }
    if (ifPrimaryTerm != null) {
      queryParams.addAll(_queryParams('', 'if_primary_term', ifPrimaryTerm));
    }
    if (pipeline != null) {
      queryParams.addAll(_queryParams('', 'pipeline', pipeline));
    }
    if (requireAlias != null) {
      queryParams.addAll(_queryParams('', 'require_alias', requireAlias));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates or updates a document in an index.
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Document ID.
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
  ///
  /// * [OpType] opType:
  ///   Explicit operation type. Defaults to `index` for requests with an explicit document ID, and to `create`for requests without an explicit document ID.
  ///
  /// * [RefreshEnum] refresh:
  ///   If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  ///
  /// * [int] ifSeqNo:
  ///   only perform the operation if the last operation that has changed the document has the specified sequence number.
  ///
  /// * [int] ifPrimaryTerm:
  ///   only perform the operation if the last operation that has changed the document has the specified primary term.
  ///
  /// * [String] pipeline:
  ///   The pipeline id to preprocess incoming documents with.
  ///
  /// * [bool] requireAlias:
  ///   When true, requires destination to be an alias.
  Future<void> indexPutWithId(
    String id,
    String index,
    Object body, {
    String? waitForActiveShards,
    OpType? opType,
    RefreshEnum? refresh,
    String? routing,
    String? timeout,
    int? version,
    VersionType? versionType,
    int? ifSeqNo,
    int? ifPrimaryTerm,
    String? pipeline,
    bool? requireAlias,
  }) async {
    final response = await indexPutWithIdWithHttpInfo(
      id,
      index,
      body,
      waitForActiveShards: waitForActiveShards,
      opType: opType,
      refresh: refresh,
      routing: routing,
      timeout: timeout,
      version: version,
      versionType: versionType,
      ifSeqNo: ifSeqNo,
      ifPrimaryTerm: ifPrimaryTerm,
      pipeline: pipeline,
      requireAlias: requireAlias,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Adds a block to an index.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to add a block to.
  ///
  /// * [String] block (required):
  ///   The block to add (one of read, write, read_only or metadata).
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<Response> indicesAddBlockWithHttpInfo(
    String index,
    String block, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_block/{block}'
        .replaceAll('{index}', index)
        .replaceAll('{block}', block);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Adds a block to an index.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to add a block to.
  ///
  /// * [String] block (required):
  ///   The block to add (one of read, write, read_only or metadata).
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<void> indicesAddBlock(
    String index,
    String block, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    final response = await indicesAddBlockWithHttpInfo(
      index,
      block,
      timeout: timeout,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Performs the analysis process on a text and return the tokens breakdown of the text.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index:
  ///   The name of the index to scope the operation.
  Future<Response> indicesAnalyzeGetWithHttpInfo({
    String? index,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_analyze';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (index != null) {
      queryParams.addAll(_queryParams('', 'index', index));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Performs the analysis process on a text and return the tokens breakdown of the text.
  ///
  /// Parameters:
  ///
  /// * [String] index:
  ///   The name of the index to scope the operation.
  Future<void> indicesAnalyzeGet({
    String? index,
  }) async {
    final response = await indicesAnalyzeGetWithHttpInfo(
      index: index,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Performs the analysis process on a text and return the tokens breakdown of the text.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   The name of the index to scope the operation.
  ///
  /// * [String] index2:
  ///   The name of the index to scope the operation.
  Future<Response> indicesAnalyzeGetWithIndexWithHttpInfo(
    String index, {
    String? index2,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_analyze'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (index2 != null) {
      queryParams.addAll(_queryParams('', 'index', index2));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Performs the analysis process on a text and return the tokens breakdown of the text.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   The name of the index to scope the operation.
  ///
  /// * [String] index2:
  ///   The name of the index to scope the operation.
  Future<void> indicesAnalyzeGetWithIndex(
    String index, {
    String? index2,
  }) async {
    final response = await indicesAnalyzeGetWithIndexWithHttpInfo(
      index,
      index2: index2,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Performs the analysis process on a text and return the tokens breakdown of the text.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index:
  ///   The name of the index to scope the operation.
  ///
  /// * [Object] body:
  Future<Response> indicesAnalyzePostWithHttpInfo({
    String? index,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_analyze';

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (index != null) {
      queryParams.addAll(_queryParams('', 'index', index));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Performs the analysis process on a text and return the tokens breakdown of the text.
  ///
  /// Parameters:
  ///
  /// * [String] index:
  ///   The name of the index to scope the operation.
  ///
  /// * [Object] body:
  Future<void> indicesAnalyzePost({
    String? index,
    Object? body,
  }) async {
    final response = await indicesAnalyzePostWithHttpInfo(
      index: index,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Performs the analysis process on a text and return the tokens breakdown of the text.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   The name of the index to scope the operation.
  ///
  /// * [String] index2:
  ///   The name of the index to scope the operation.
  ///
  /// * [Object] body:
  Future<Response> indicesAnalyzePostWithIndexWithHttpInfo(
    String index, {
    String? index2,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_analyze'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (index2 != null) {
      queryParams.addAll(_queryParams('', 'index', index2));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Performs the analysis process on a text and return the tokens breakdown of the text.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   The name of the index to scope the operation.
  ///
  /// * [String] index2:
  ///   The name of the index to scope the operation.
  ///
  /// * [Object] body:
  Future<void> indicesAnalyzePostWithIndex(
    String index, {
    String? index2,
    Object? body,
  }) async {
    final response = await indicesAnalyzePostWithIndexWithHttpInfo(
      index,
      index2: index2,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Clears all or specific caches for one or more indices.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] fielddata:
  ///   Clear field data.
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields to clear when using the `fielddata` parameter (default: all).
  ///
  /// * [bool] query:
  ///   Clear query caches.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [List<String>] index:
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] request:
  ///   Clear request cache.
  Future<Response> indicesClearCacheWithHttpInfo({
    bool? fielddata,
    List<String>? fields,
    bool? query,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    List<String>? index,
    bool? request,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cache/clear';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (fielddata != null) {
      queryParams.addAll(_queryParams('', 'fielddata', fielddata));
    }
    if (fields != null) {
      queryParams.addAll(_queryParams('multi', 'fields', fields));
    }
    if (query != null) {
      queryParams.addAll(_queryParams('', 'query', query));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (index != null) {
      queryParams.addAll(_queryParams('multi', 'index', index));
    }
    if (request != null) {
      queryParams.addAll(_queryParams('', 'request', request));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Clears all or specific caches for one or more indices.
  ///
  /// Parameters:
  ///
  /// * [bool] fielddata:
  ///   Clear field data.
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields to clear when using the `fielddata` parameter (default: all).
  ///
  /// * [bool] query:
  ///   Clear query caches.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [List<String>] index:
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] request:
  ///   Clear request cache.
  Future<void> indicesClearCache({
    bool? fielddata,
    List<String>? fields,
    bool? query,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    List<String>? index,
    bool? request,
  }) async {
    final response = await indicesClearCacheWithHttpInfo(
      fielddata: fielddata,
      fields: fields,
      query: query,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      index: index,
      request: request,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Clears all or specific caches for one or more indices.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] fielddata:
  ///   Clear field data.
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields to clear when using the `fielddata` parameter (default: all).
  ///
  /// * [bool] query:
  ///   Clear query caches.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [List<String>] index2:
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] request:
  ///   Clear request cache.
  Future<Response> indicesClearCacheWithIndexWithHttpInfo(
    String index, {
    bool? fielddata,
    List<String>? fields,
    bool? query,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    List<String>? index2,
    bool? request,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_cache/clear'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (fielddata != null) {
      queryParams.addAll(_queryParams('', 'fielddata', fielddata));
    }
    if (fields != null) {
      queryParams.addAll(_queryParams('multi', 'fields', fields));
    }
    if (query != null) {
      queryParams.addAll(_queryParams('', 'query', query));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (index2 != null) {
      queryParams.addAll(_queryParams('multi', 'index', index2));
    }
    if (request != null) {
      queryParams.addAll(_queryParams('', 'request', request));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Clears all or specific caches for one or more indices.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] fielddata:
  ///   Clear field data.
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields to clear when using the `fielddata` parameter (default: all).
  ///
  /// * [bool] query:
  ///   Clear query caches.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [List<String>] index2:
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] request:
  ///   Clear request cache.
  Future<void> indicesClearCacheWithIndex(
    String index, {
    bool? fielddata,
    List<String>? fields,
    bool? query,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    List<String>? index2,
    bool? request,
  }) async {
    final response = await indicesClearCacheWithIndexWithHttpInfo(
      index,
      fielddata: fielddata,
      fields: fields,
      query: query,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      index2: index2,
      request: request,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Clones an index.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   The name of the source index to clone.
  ///
  /// * [String] target (required):
  ///   The name of the target index.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] waitForActiveShards:
  ///   Set the number of active shards to wait for on the cloned index before the operation returns.
  ///
  /// * [Object] body:
  Future<Response> indicesClonePostWithHttpInfo(
    String index,
    String target, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? waitForActiveShards,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_clone/{target}'
        .replaceAll('{index}', index)
        .replaceAll('{target}', target);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (waitForActiveShards != null) {
      queryParams.addAll(
          _queryParams('', 'wait_for_active_shards', waitForActiveShards));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Clones an index.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   The name of the source index to clone.
  ///
  /// * [String] target (required):
  ///   The name of the target index.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] waitForActiveShards:
  ///   Set the number of active shards to wait for on the cloned index before the operation returns.
  ///
  /// * [Object] body:
  Future<void> indicesClonePost(
    String index,
    String target, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? waitForActiveShards,
    Object? body,
  }) async {
    final response = await indicesClonePostWithHttpInfo(
      index,
      target,
      timeout: timeout,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      waitForActiveShards: waitForActiveShards,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Clones an index.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   The name of the source index to clone.
  ///
  /// * [String] target (required):
  ///   The name of the target index.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] waitForActiveShards:
  ///   Set the number of active shards to wait for on the cloned index before the operation returns.
  ///
  /// * [Object] body:
  Future<Response> indicesClonePutWithHttpInfo(
    String index,
    String target, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? waitForActiveShards,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_clone/{target}'
        .replaceAll('{index}', index)
        .replaceAll('{target}', target);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (waitForActiveShards != null) {
      queryParams.addAll(
          _queryParams('', 'wait_for_active_shards', waitForActiveShards));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Clones an index.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   The name of the source index to clone.
  ///
  /// * [String] target (required):
  ///   The name of the target index.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] waitForActiveShards:
  ///   Set the number of active shards to wait for on the cloned index before the operation returns.
  ///
  /// * [Object] body:
  Future<void> indicesClonePut(
    String index,
    String target, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? waitForActiveShards,
    Object? body,
  }) async {
    final response = await indicesClonePutWithHttpInfo(
      index,
      target,
      timeout: timeout,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      waitForActiveShards: waitForActiveShards,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Closes an index.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to close.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of active shards to wait for before the operation returns.
  Future<Response> indicesCloseWithHttpInfo(
    String index, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    String? waitForActiveShards,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_close'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (waitForActiveShards != null) {
      queryParams.addAll(
          _queryParams('', 'wait_for_active_shards', waitForActiveShards));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Closes an index.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to close.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of active shards to wait for before the operation returns.
  Future<void> indicesClose(
    String index, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    String? waitForActiveShards,
  }) async {
    final response = await indicesCloseWithHttpInfo(
      index,
      timeout: timeout,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      waitForActiveShards: waitForActiveShards,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Creates an index with optional settings and mappings.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [String] waitForActiveShards:
  ///   Set the number of active shards to wait for before the operation returns.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [IndicesCreateBodyParams] indicesCreateBodyParams:
  Future<Response> indicesCreateWithHttpInfo(
    String index, {
    String? waitForActiveShards,
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
    IndicesCreateBodyParams? indicesCreateBodyParams,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody = indicesCreateBodyParams;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (waitForActiveShards != null) {
      queryParams.addAll(
          _queryParams('', 'wait_for_active_shards', waitForActiveShards));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates an index with optional settings and mappings.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [String] waitForActiveShards:
  ///   Set the number of active shards to wait for before the operation returns.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [IndicesCreateBodyParams] indicesCreateBodyParams:
  Future<IndicesCreateResponseContent?> indicesCreate(
    String index, {
    String? waitForActiveShards,
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
    IndicesCreateBodyParams? indicesCreateBodyParams,
  }) async {
    final response = await indicesCreateWithHttpInfo(
      index,
      waitForActiveShards: waitForActiveShards,
      timeout: timeout,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      indicesCreateBodyParams: indicesCreateBodyParams,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'IndicesCreateResponseContent',
      ) as IndicesCreateResponseContent;
    }
    return null;
  }

  /// Creates or updates a data stream.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The name of the data stream.
  ///
  /// * [Object] body:
  Future<Response> indicesCreateDataStreamWithHttpInfo(
    String name, {
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_data_stream/{name}'.replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates or updates a data stream.
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The name of the data stream.
  ///
  /// * [Object] body:
  Future<IndicesCreateDataStreamResponseContent?> indicesCreateDataStream(
    String name, {
    Object? body,
  }) async {
    final response = await indicesCreateDataStreamWithHttpInfo(
      name,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'IndicesCreateDataStreamResponseContent',
      ) as IndicesCreateDataStreamResponseContent;
    }
    return null;
  }

  /// Provides statistics on operations happening in a data stream.
  ///
  /// Note: This method returns the HTTP [Response].
  Future<Response> indicesDataStreamsStatsWithHttpInfo() async {
    // ignore: prefer_const_declarations
    final path = r'/_data_stream/_stats';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Provides statistics on operations happening in a data stream.
  Future<void> indicesDataStreamsStats() async {
    final response = await indicesDataStreamsStatsWithHttpInfo();
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Provides statistics on operations happening in a data stream.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   Comma-separated list of data streams; use `_all` or empty string to perform the operation on all data streams.
  Future<Response> indicesDataStreamsStatsWithNameWithHttpInfo(
    String name,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_data_stream/{name}/_stats'.replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Provides statistics on operations happening in a data stream.
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   Comma-separated list of data streams; use `_all` or empty string to perform the operation on all data streams.
  Future<void> indicesDataStreamsStatsWithName(
    String name,
  ) async {
    final response = await indicesDataStreamsStatsWithNameWithHttpInfo(
      name,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Deletes an index.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to delete; use `_all` or `*` string to delete all indices.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<Response> indicesDeleteWithHttpInfo(
    String index, {
    String? timeout,
    String? masterTimeout,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'DELETE',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Deletes an index.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to delete; use `_all` or `*` string to delete all indices.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<IndicesDeleteResponseContent?> indicesDelete(
    String index, {
    String? timeout,
    String? masterTimeout,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    final response = await indicesDeleteWithHttpInfo(
      index,
      timeout: timeout,
      masterTimeout: masterTimeout,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'IndicesDeleteResponseContent',
      ) as IndicesDeleteResponseContent;
    }
    return null;
  }

  /// Deletes an alias.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [String] name (required):
  ///   Comma-separated list of aliases to delete (supports wildcards); use `_all` to delete all aliases for the specified indices.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<Response> indicesDeleteAliasWithHttpInfo(
    String index,
    String name, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_alias/{name}'
        .replaceAll('{index}', index)
        .replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'DELETE',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Deletes an alias.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [String] name (required):
  ///   Comma-separated list of aliases to delete (supports wildcards); use `_all` to delete all aliases for the specified indices.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<void> indicesDeleteAlias(
    String index,
    String name, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    final response = await indicesDeleteAliasWithHttpInfo(
      index,
      name,
      timeout: timeout,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Deletes an alias.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [String] name (required):
  ///   Comma-separated list of aliases to delete (supports wildcards); use `_all` to delete all aliases for the specified indices.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<Response> indicesDeleteAliasPluralWithHttpInfo(
    String index,
    String name, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_aliases/{name}'
        .replaceAll('{index}', index)
        .replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'DELETE',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Deletes an alias.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [String] name (required):
  ///   Comma-separated list of aliases to delete (supports wildcards); use `_all` to delete all aliases for the specified indices.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<void> indicesDeleteAliasPlural(
    String index,
    String name, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    final response = await indicesDeleteAliasPluralWithHttpInfo(
      index,
      name,
      timeout: timeout,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Deletes a data stream.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   Comma-separated list of data streams; use `_all` or empty string to perform the operation on all data streams.
  Future<Response> indicesDeleteDataStreamWithHttpInfo(
    String name,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_data_stream/{name}'.replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'DELETE',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Deletes a data stream.
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   Comma-separated list of data streams; use `_all` or empty string to perform the operation on all data streams.
  Future<IndicesDeleteDataStreamResponseContent?> indicesDeleteDataStream(
    String name,
  ) async {
    final response = await indicesDeleteDataStreamWithHttpInfo(
      name,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'IndicesDeleteDataStreamResponseContent',
      ) as IndicesDeleteDataStreamResponseContent;
    }
    return null;
  }

  /// Deletes an index template.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The name of the template.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<Response> indicesDeleteIndexTemplateWithHttpInfo(
    String name, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_index_template/{name}'.replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'DELETE',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Deletes an index template.
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The name of the template.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<void> indicesDeleteIndexTemplate(
    String name, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    final response = await indicesDeleteIndexTemplateWithHttpInfo(
      name,
      timeout: timeout,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Deletes an index template.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The name of the template.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<Response> indicesDeleteTemplateWithHttpInfo(
    String name, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_template/{name}'.replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'DELETE',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Deletes an index template.
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The name of the template.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<void> indicesDeleteTemplate(
    String name, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    final response = await indicesDeleteTemplateWithHttpInfo(
      name,
      timeout: timeout,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about whether a particular index exists.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [bool] includeDefaults:
  ///   Whether to return all default setting for each of the indices.
  Future<Response> indicesExistsWithHttpInfo(
    String index, {
    bool? local,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? flatSettings,
    bool? includeDefaults,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (flatSettings != null) {
      queryParams.addAll(_queryParams('', 'flat_settings', flatSettings));
    }
    if (includeDefaults != null) {
      queryParams.addAll(_queryParams('', 'include_defaults', includeDefaults));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'HEAD',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about whether a particular index exists.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [bool] includeDefaults:
  ///   Whether to return all default setting for each of the indices.
  Future<void> indicesExists(
    String index, {
    bool? local,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? flatSettings,
    bool? includeDefaults,
  }) async {
    final response = await indicesExistsWithHttpInfo(
      index,
      local: local,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      flatSettings: flatSettings,
      includeDefaults: includeDefaults,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about whether a particular alias exists.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   Comma-separated list of alias names.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<Response> indicesExistsAliasWithHttpInfo(
    String name, {
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? local,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_alias/{name}'.replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'HEAD',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about whether a particular alias exists.
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   Comma-separated list of alias names.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<void> indicesExistsAlias(
    String name, {
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? local,
  }) async {
    final response = await indicesExistsAliasWithHttpInfo(
      name,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      local: local,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about whether a particular alias exists.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to filter aliases.
  ///
  /// * [String] name (required):
  ///   Comma-separated list of alias names.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<Response> indicesExistsAliasWithIndexWithHttpInfo(
    String index,
    String name, {
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? local,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_alias/{name}'
        .replaceAll('{index}', index)
        .replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'HEAD',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about whether a particular alias exists.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to filter aliases.
  ///
  /// * [String] name (required):
  ///   Comma-separated list of alias names.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<void> indicesExistsAliasWithIndex(
    String index,
    String name, {
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? local,
  }) async {
    final response = await indicesExistsAliasWithIndexWithHttpInfo(
      index,
      name,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      local: local,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about whether a particular index template exists.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The name of the template.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<Response> indicesExistsIndexTemplateWithHttpInfo(
    String name, {
    bool? flatSettings,
    String? masterTimeout,
    bool? local,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_index_template/{name}'.replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (flatSettings != null) {
      queryParams.addAll(_queryParams('', 'flat_settings', flatSettings));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'HEAD',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about whether a particular index template exists.
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The name of the template.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<void> indicesExistsIndexTemplate(
    String name, {
    bool? flatSettings,
    String? masterTimeout,
    bool? local,
  }) async {
    final response = await indicesExistsIndexTemplateWithHttpInfo(
      name,
      flatSettings: flatSettings,
      masterTimeout: masterTimeout,
      local: local,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about whether a particular index template exists.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   Comma-separated names of the index templates.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<Response> indicesExistsTemplateWithHttpInfo(
    String name, {
    bool? flatSettings,
    String? masterTimeout,
    bool? local,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_template/{name}'.replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (flatSettings != null) {
      queryParams.addAll(_queryParams('', 'flat_settings', flatSettings));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'HEAD',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about whether a particular index template exists.
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   Comma-separated names of the index templates.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<void> indicesExistsTemplate(
    String name, {
    bool? flatSettings,
    String? masterTimeout,
    bool? local,
  }) async {
    final response = await indicesExistsTemplateWithHttpInfo(
      name,
      flatSettings: flatSettings,
      masterTimeout: masterTimeout,
      local: local,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Performs the flush operation on one or more indices.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] force:
  ///   Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal).
  ///
  /// * [bool] waitIfOngoing:
  ///   If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. If set to false the flush will be skipped iff if another flush operation is already running.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<Response> indicesFlushGetWithHttpInfo({
    bool? force,
    bool? waitIfOngoing,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_flush';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (force != null) {
      queryParams.addAll(_queryParams('', 'force', force));
    }
    if (waitIfOngoing != null) {
      queryParams.addAll(_queryParams('', 'wait_if_ongoing', waitIfOngoing));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Performs the flush operation on one or more indices.
  ///
  /// Parameters:
  ///
  /// * [bool] force:
  ///   Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal).
  ///
  /// * [bool] waitIfOngoing:
  ///   If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. If set to false the flush will be skipped iff if another flush operation is already running.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<void> indicesFlushGet({
    bool? force,
    bool? waitIfOngoing,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    final response = await indicesFlushGetWithHttpInfo(
      force: force,
      waitIfOngoing: waitIfOngoing,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Performs the flush operation on one or more indices.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] force:
  ///   Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal).
  ///
  /// * [bool] waitIfOngoing:
  ///   If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. If set to false the flush will be skipped iff if another flush operation is already running.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<Response> indicesFlushGetWithIndexWithHttpInfo(
    String index, {
    bool? force,
    bool? waitIfOngoing,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_flush'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (force != null) {
      queryParams.addAll(_queryParams('', 'force', force));
    }
    if (waitIfOngoing != null) {
      queryParams.addAll(_queryParams('', 'wait_if_ongoing', waitIfOngoing));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Performs the flush operation on one or more indices.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] force:
  ///   Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal).
  ///
  /// * [bool] waitIfOngoing:
  ///   If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. If set to false the flush will be skipped iff if another flush operation is already running.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<void> indicesFlushGetWithIndex(
    String index, {
    bool? force,
    bool? waitIfOngoing,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    final response = await indicesFlushGetWithIndexWithHttpInfo(
      index,
      force: force,
      waitIfOngoing: waitIfOngoing,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Performs the flush operation on one or more indices.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] force:
  ///   Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal).
  ///
  /// * [bool] waitIfOngoing:
  ///   If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. If set to false the flush will be skipped iff if another flush operation is already running.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<Response> indicesFlushPostWithHttpInfo({
    bool? force,
    bool? waitIfOngoing,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_flush';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (force != null) {
      queryParams.addAll(_queryParams('', 'force', force));
    }
    if (waitIfOngoing != null) {
      queryParams.addAll(_queryParams('', 'wait_if_ongoing', waitIfOngoing));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Performs the flush operation on one or more indices.
  ///
  /// Parameters:
  ///
  /// * [bool] force:
  ///   Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal).
  ///
  /// * [bool] waitIfOngoing:
  ///   If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. If set to false the flush will be skipped iff if another flush operation is already running.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<void> indicesFlushPost({
    bool? force,
    bool? waitIfOngoing,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    final response = await indicesFlushPostWithHttpInfo(
      force: force,
      waitIfOngoing: waitIfOngoing,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Performs the flush operation on one or more indices.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] force:
  ///   Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal).
  ///
  /// * [bool] waitIfOngoing:
  ///   If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. If set to false the flush will be skipped iff if another flush operation is already running.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<Response> indicesFlushPostWithIndexWithHttpInfo(
    String index, {
    bool? force,
    bool? waitIfOngoing,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_flush'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (force != null) {
      queryParams.addAll(_queryParams('', 'force', force));
    }
    if (waitIfOngoing != null) {
      queryParams.addAll(_queryParams('', 'wait_if_ongoing', waitIfOngoing));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Performs the flush operation on one or more indices.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] force:
  ///   Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal).
  ///
  /// * [bool] waitIfOngoing:
  ///   If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. If set to false the flush will be skipped iff if another flush operation is already running.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<void> indicesFlushPostWithIndex(
    String index, {
    bool? force,
    bool? waitIfOngoing,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    final response = await indicesFlushPostWithIndexWithHttpInfo(
      index,
      force: force,
      waitIfOngoing: waitIfOngoing,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Performs the force merge operation on one or more indices.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] flush:
  ///   Specify whether the index should be flushed after performing the operation.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [int] maxNumSegments:
  ///   The number of segments the index should be merged into (default: dynamic).
  ///
  /// * [bool] onlyExpungeDeletes:
  ///   Specify whether the operation should only expunge deleted documents.
  Future<Response> indicesForcemergeWithHttpInfo({
    bool? flush,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    int? maxNumSegments,
    bool? onlyExpungeDeletes,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_forcemerge';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (flush != null) {
      queryParams.addAll(_queryParams('', 'flush', flush));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (maxNumSegments != null) {
      queryParams.addAll(_queryParams('', 'max_num_segments', maxNumSegments));
    }
    if (onlyExpungeDeletes != null) {
      queryParams
          .addAll(_queryParams('', 'only_expunge_deletes', onlyExpungeDeletes));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Performs the force merge operation on one or more indices.
  ///
  /// Parameters:
  ///
  /// * [bool] flush:
  ///   Specify whether the index should be flushed after performing the operation.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [int] maxNumSegments:
  ///   The number of segments the index should be merged into (default: dynamic).
  ///
  /// * [bool] onlyExpungeDeletes:
  ///   Specify whether the operation should only expunge deleted documents.
  Future<void> indicesForcemerge({
    bool? flush,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    int? maxNumSegments,
    bool? onlyExpungeDeletes,
  }) async {
    final response = await indicesForcemergeWithHttpInfo(
      flush: flush,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      maxNumSegments: maxNumSegments,
      onlyExpungeDeletes: onlyExpungeDeletes,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Performs the force merge operation on one or more indices.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] flush:
  ///   Specify whether the index should be flushed after performing the operation.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [int] maxNumSegments:
  ///   The number of segments the index should be merged into (default: dynamic).
  ///
  /// * [bool] onlyExpungeDeletes:
  ///   Specify whether the operation should only expunge deleted documents.
  Future<Response> indicesForcemergeWithIndexWithHttpInfo(
    String index, {
    bool? flush,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    int? maxNumSegments,
    bool? onlyExpungeDeletes,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_forcemerge'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (flush != null) {
      queryParams.addAll(_queryParams('', 'flush', flush));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (maxNumSegments != null) {
      queryParams.addAll(_queryParams('', 'max_num_segments', maxNumSegments));
    }
    if (onlyExpungeDeletes != null) {
      queryParams
          .addAll(_queryParams('', 'only_expunge_deletes', onlyExpungeDeletes));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Performs the force merge operation on one or more indices.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] flush:
  ///   Specify whether the index should be flushed after performing the operation.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [int] maxNumSegments:
  ///   The number of segments the index should be merged into (default: dynamic).
  ///
  /// * [bool] onlyExpungeDeletes:
  ///   Specify whether the operation should only expunge deleted documents.
  Future<void> indicesForcemergeWithIndex(
    String index, {
    bool? flush,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    int? maxNumSegments,
    bool? onlyExpungeDeletes,
  }) async {
    final response = await indicesForcemergeWithIndexWithHttpInfo(
      index,
      flush: flush,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      maxNumSegments: maxNumSegments,
      onlyExpungeDeletes: onlyExpungeDeletes,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about one or more indices.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [bool] includeDefaults:
  ///   Whether to return all default setting for each of the indices.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<Response> indicesGetWithHttpInfo(
    String index, {
    bool? local,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? flatSettings,
    bool? includeDefaults,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (flatSettings != null) {
      queryParams.addAll(_queryParams('', 'flat_settings', flatSettings));
    }
    if (includeDefaults != null) {
      queryParams.addAll(_queryParams('', 'include_defaults', includeDefaults));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about one or more indices.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [bool] includeDefaults:
  ///   Whether to return all default setting for each of the indices.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<void> indicesGet(
    String index, {
    bool? local,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? flatSettings,
    bool? includeDefaults,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    final response = await indicesGetWithHttpInfo(
      index,
      local: local,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      flatSettings: flatSettings,
      includeDefaults: includeDefaults,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns an alias.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<Response> indicesGetAliasWithHttpInfo({
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? local,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_alias';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns an alias.
  ///
  /// Parameters:
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<void> indicesGetAlias({
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? local,
  }) async {
    final response = await indicesGetAliasWithHttpInfo(
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      local: local,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns an alias.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to filter aliases.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<Response> indicesGetAliasWithIndexWithHttpInfo(
    String index, {
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? local,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_alias'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns an alias.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to filter aliases.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<void> indicesGetAliasWithIndex(
    String index, {
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? local,
  }) async {
    final response = await indicesGetAliasWithIndexWithHttpInfo(
      index,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      local: local,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns an alias.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to filter aliases.
  ///
  /// * [String] name (required):
  ///   Comma-separated list of alias names.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<Response> indicesGetAliasWithIndexNameWithHttpInfo(
    String index,
    String name, {
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? local,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_alias/{name}'
        .replaceAll('{index}', index)
        .replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns an alias.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to filter aliases.
  ///
  /// * [String] name (required):
  ///   Comma-separated list of alias names.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<void> indicesGetAliasWithIndexName(
    String index,
    String name, {
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? local,
  }) async {
    final response = await indicesGetAliasWithIndexNameWithHttpInfo(
      index,
      name,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      local: local,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns an alias.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   Comma-separated list of alias names.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<Response> indicesGetAliasWithNameWithHttpInfo(
    String name, {
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? local,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_alias/{name}'.replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns an alias.
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   Comma-separated list of alias names.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<void> indicesGetAliasWithName(
    String name, {
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? local,
  }) async {
    final response = await indicesGetAliasWithNameWithHttpInfo(
      name,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      local: local,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns data streams.
  ///
  /// Note: This method returns the HTTP [Response].
  Future<Response> indicesGetDataStreamWithHttpInfo() async {
    // ignore: prefer_const_declarations
    final path = r'/_data_stream';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns data streams.
  Future<IndicesGetDataStreamResponseContent?> indicesGetDataStream() async {
    final response = await indicesGetDataStreamWithHttpInfo();
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'IndicesGetDataStreamResponseContent',
      ) as IndicesGetDataStreamResponseContent;
    }
    return null;
  }

  /// Returns data streams.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   Comma-separated list of data streams; use `_all` or empty string to perform the operation on all data streams.
  Future<Response> indicesGetDataStreamWithNameWithHttpInfo(
    String name,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_data_stream/{name}'.replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns data streams.
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   Comma-separated list of data streams; use `_all` or empty string to perform the operation on all data streams.
  Future<IndicesGetDataStreamWithNameResponseContent?>
      indicesGetDataStreamWithName(
    String name,
  ) async {
    final response = await indicesGetDataStreamWithNameWithHttpInfo(
      name,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'IndicesGetDataStreamWithNameResponseContent',
      ) as IndicesGetDataStreamWithNameResponseContent;
    }
    return null;
  }

  /// Returns mapping for one or more fields.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] fields (required):
  ///   Comma-separated list of fields.
  ///
  /// * [bool] includeDefaults:
  ///   Whether the default mapping values should be returned as well.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<Response> indicesGetFieldMappingWithHttpInfo(
    String fields, {
    bool? includeDefaults,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? local,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_mapping/field/{fields}'.replaceAll('{fields}', fields);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (includeDefaults != null) {
      queryParams.addAll(_queryParams('', 'include_defaults', includeDefaults));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns mapping for one or more fields.
  ///
  /// Parameters:
  ///
  /// * [String] fields (required):
  ///   Comma-separated list of fields.
  ///
  /// * [bool] includeDefaults:
  ///   Whether the default mapping values should be returned as well.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<void> indicesGetFieldMapping(
    String fields, {
    bool? includeDefaults,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? local,
  }) async {
    final response = await indicesGetFieldMappingWithHttpInfo(
      fields,
      includeDefaults: includeDefaults,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      local: local,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns mapping for one or more fields.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices.
  ///
  /// * [String] fields (required):
  ///   Comma-separated list of fields.
  ///
  /// * [bool] includeDefaults:
  ///   Whether the default mapping values should be returned as well.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<Response> indicesGetFieldMappingWithIndexWithHttpInfo(
    String index,
    String fields, {
    bool? includeDefaults,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? local,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_mapping/field/{fields}'
        .replaceAll('{index}', index)
        .replaceAll('{fields}', fields);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (includeDefaults != null) {
      queryParams.addAll(_queryParams('', 'include_defaults', includeDefaults));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns mapping for one or more fields.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices.
  ///
  /// * [String] fields (required):
  ///   Comma-separated list of fields.
  ///
  /// * [bool] includeDefaults:
  ///   Whether the default mapping values should be returned as well.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<void> indicesGetFieldMappingWithIndex(
    String index,
    String fields, {
    bool? includeDefaults,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? local,
  }) async {
    final response = await indicesGetFieldMappingWithIndexWithHttpInfo(
      index,
      fields,
      includeDefaults: includeDefaults,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      local: local,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns an index template.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<Response> indicesGetIndexTemplateWithHttpInfo({
    bool? flatSettings,
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? local,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_index_template';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (flatSettings != null) {
      queryParams.addAll(_queryParams('', 'flat_settings', flatSettings));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns an index template.
  ///
  /// Parameters:
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<void> indicesGetIndexTemplate({
    bool? flatSettings,
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? local,
  }) async {
    final response = await indicesGetIndexTemplateWithHttpInfo(
      flatSettings: flatSettings,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      local: local,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns an index template.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   Comma-separated names of the index templates.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<Response> indicesGetIndexTemplateWithNameWithHttpInfo(
    String name, {
    bool? flatSettings,
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? local,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_index_template/{name}'.replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (flatSettings != null) {
      queryParams.addAll(_queryParams('', 'flat_settings', flatSettings));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns an index template.
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   Comma-separated names of the index templates.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<void> indicesGetIndexTemplateWithName(
    String name, {
    bool? flatSettings,
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? local,
  }) async {
    final response = await indicesGetIndexTemplateWithNameWithHttpInfo(
      name,
      flatSettings: flatSettings,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      local: local,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns mappings for one or more indices.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<Response> indicesGetMappingWithHttpInfo({
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? local,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_mapping';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns mappings for one or more indices.
  ///
  /// Parameters:
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<void> indicesGetMapping({
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? local,
  }) async {
    final response = await indicesGetMappingWithHttpInfo(
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      local: local,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns mappings for one or more indices.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<Response> indicesGetMappingWithIndexWithHttpInfo(
    String index, {
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? local,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_mapping'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns mappings for one or more indices.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<void> indicesGetMappingWithIndex(
    String index, {
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? local,
  }) async {
    final response = await indicesGetMappingWithIndexWithHttpInfo(
      index,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      local: local,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns settings for one or more indices.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [bool] includeDefaults:
  ///   Whether to return all default setting for each of the indices.
  Future<Response> indicesGetSettingsWithHttpInfo({
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? flatSettings,
    bool? local,
    bool? includeDefaults,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_settings';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (flatSettings != null) {
      queryParams.addAll(_queryParams('', 'flat_settings', flatSettings));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (includeDefaults != null) {
      queryParams.addAll(_queryParams('', 'include_defaults', includeDefaults));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns settings for one or more indices.
  ///
  /// Parameters:
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [bool] includeDefaults:
  ///   Whether to return all default setting for each of the indices.
  Future<void> indicesGetSettings({
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? flatSettings,
    bool? local,
    bool? includeDefaults,
  }) async {
    final response = await indicesGetSettingsWithHttpInfo(
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      flatSettings: flatSettings,
      local: local,
      includeDefaults: includeDefaults,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns settings for one or more indices.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [bool] includeDefaults:
  ///   Whether to return all default setting for each of the indices.
  Future<Response> indicesGetSettingsWithIndexWithHttpInfo(
    String index, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? flatSettings,
    bool? local,
    bool? includeDefaults,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_settings'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (flatSettings != null) {
      queryParams.addAll(_queryParams('', 'flat_settings', flatSettings));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (includeDefaults != null) {
      queryParams.addAll(_queryParams('', 'include_defaults', includeDefaults));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns settings for one or more indices.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [bool] includeDefaults:
  ///   Whether to return all default setting for each of the indices.
  Future<void> indicesGetSettingsWithIndex(
    String index, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? flatSettings,
    bool? local,
    bool? includeDefaults,
  }) async {
    final response = await indicesGetSettingsWithIndexWithHttpInfo(
      index,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      flatSettings: flatSettings,
      local: local,
      includeDefaults: includeDefaults,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns settings for one or more indices.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [String] name (required):
  ///   Comma-separated list of settings.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [bool] includeDefaults:
  ///   Whether to return all default setting for each of the indices.
  Future<Response> indicesGetSettingsWithIndexNameWithHttpInfo(
    String index,
    String name, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? flatSettings,
    bool? local,
    bool? includeDefaults,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_settings/{name}'
        .replaceAll('{index}', index)
        .replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (flatSettings != null) {
      queryParams.addAll(_queryParams('', 'flat_settings', flatSettings));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (includeDefaults != null) {
      queryParams.addAll(_queryParams('', 'include_defaults', includeDefaults));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns settings for one or more indices.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [String] name (required):
  ///   Comma-separated list of settings.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [bool] includeDefaults:
  ///   Whether to return all default setting for each of the indices.
  Future<void> indicesGetSettingsWithIndexName(
    String index,
    String name, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? flatSettings,
    bool? local,
    bool? includeDefaults,
  }) async {
    final response = await indicesGetSettingsWithIndexNameWithHttpInfo(
      index,
      name,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      flatSettings: flatSettings,
      local: local,
      includeDefaults: includeDefaults,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns settings for one or more indices.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   Comma-separated list of settings.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [bool] includeDefaults:
  ///   Whether to return all default setting for each of the indices.
  Future<Response> indicesGetSettingsWithNameWithHttpInfo(
    String name, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? flatSettings,
    bool? local,
    bool? includeDefaults,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_settings/{name}'.replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (flatSettings != null) {
      queryParams.addAll(_queryParams('', 'flat_settings', flatSettings));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (includeDefaults != null) {
      queryParams.addAll(_queryParams('', 'include_defaults', includeDefaults));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns settings for one or more indices.
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   Comma-separated list of settings.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [bool] includeDefaults:
  ///   Whether to return all default setting for each of the indices.
  Future<void> indicesGetSettingsWithName(
    String name, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? flatSettings,
    bool? local,
    bool? includeDefaults,
  }) async {
    final response = await indicesGetSettingsWithNameWithHttpInfo(
      name,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      flatSettings: flatSettings,
      local: local,
      includeDefaults: includeDefaults,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns an index template.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<Response> indicesGetTemplateWithHttpInfo({
    bool? flatSettings,
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? local,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_template';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (flatSettings != null) {
      queryParams.addAll(_queryParams('', 'flat_settings', flatSettings));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns an index template.
  ///
  /// Parameters:
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<void> indicesGetTemplate({
    bool? flatSettings,
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? local,
  }) async {
    final response = await indicesGetTemplateWithHttpInfo(
      flatSettings: flatSettings,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      local: local,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns an index template.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   Comma-separated names of the index templates.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<Response> indicesGetTemplateWithNameWithHttpInfo(
    String name, {
    bool? flatSettings,
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? local,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_template/{name}'.replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (flatSettings != null) {
      queryParams.addAll(_queryParams('', 'flat_settings', flatSettings));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns an index template.
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   Comma-separated names of the index templates.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<void> indicesGetTemplateWithName(
    String name, {
    bool? flatSettings,
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? local,
  }) async {
    final response = await indicesGetTemplateWithNameWithHttpInfo(
      name,
      flatSettings: flatSettings,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      local: local,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// The _upgrade API is no longer useful and will be removed.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<Response> indicesGetUpgradeWithHttpInfo({
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_upgrade';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// The _upgrade API is no longer useful and will be removed.
  ///
  /// Parameters:
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<void> indicesGetUpgrade({
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    final response = await indicesGetUpgradeWithHttpInfo(
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// The _upgrade API is no longer useful and will be removed.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<Response> indicesGetUpgradeWithIndexWithHttpInfo(
    String index, {
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_upgrade'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// The _upgrade API is no longer useful and will be removed.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<void> indicesGetUpgradeWithIndex(
    String index, {
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    final response = await indicesGetUpgradeWithIndexWithHttpInfo(
      index,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Opens an index.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to open.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of active shards to wait for before the operation returns.
  Future<Response> indicesOpenWithHttpInfo(
    String index, {
    String? timeout,
    String? masterTimeout,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    String? waitForActiveShards,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_open'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (waitForActiveShards != null) {
      queryParams.addAll(
          _queryParams('', 'wait_for_active_shards', waitForActiveShards));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Opens an index.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to open.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of active shards to wait for before the operation returns.
  Future<void> indicesOpen(
    String index, {
    String? timeout,
    String? masterTimeout,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    String? waitForActiveShards,
  }) async {
    final response = await indicesOpenWithHttpInfo(
      index,
      timeout: timeout,
      masterTimeout: masterTimeout,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      waitForActiveShards: waitForActiveShards,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Creates or updates an alias.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [String] name (required):
  ///   The name of the alias to be created or updated.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [Object] body:
  Future<Response> indicesPutAliasPostWithHttpInfo(
    String index,
    String name, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_alias/{name}'
        .replaceAll('{index}', index)
        .replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates or updates an alias.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [String] name (required):
  ///   The name of the alias to be created or updated.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [Object] body:
  Future<void> indicesPutAliasPost(
    String index,
    String name, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
    Object? body,
  }) async {
    final response = await indicesPutAliasPostWithHttpInfo(
      index,
      name,
      timeout: timeout,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Creates or updates an alias.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [String] name (required):
  ///   The name of the alias to be created or updated.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [Object] body:
  Future<Response> indicesPutAliasPostPluralWithHttpInfo(
    String index,
    String name, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_aliases/{name}'
        .replaceAll('{index}', index)
        .replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates or updates an alias.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [String] name (required):
  ///   The name of the alias to be created or updated.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [Object] body:
  Future<void> indicesPutAliasPostPlural(
    String index,
    String name, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
    Object? body,
  }) async {
    final response = await indicesPutAliasPostPluralWithHttpInfo(
      index,
      name,
      timeout: timeout,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Creates or updates an alias.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [String] name (required):
  ///   The name of the alias to be created or updated.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [Object] body:
  Future<Response> indicesPutAliasPutWithHttpInfo(
    String index,
    String name, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_alias/{name}'
        .replaceAll('{index}', index)
        .replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates or updates an alias.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [String] name (required):
  ///   The name of the alias to be created or updated.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [Object] body:
  Future<void> indicesPutAliasPut(
    String index,
    String name, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
    Object? body,
  }) async {
    final response = await indicesPutAliasPutWithHttpInfo(
      index,
      name,
      timeout: timeout,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Creates or updates an alias.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [String] name (required):
  ///   The name of the alias to be created or updated.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [Object] body:
  Future<Response> indicesPutAliasPutPluralWithHttpInfo(
    String index,
    String name, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_aliases/{name}'
        .replaceAll('{index}', index)
        .replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates or updates an alias.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [String] name (required):
  ///   The name of the alias to be created or updated.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [Object] body:
  Future<void> indicesPutAliasPutPlural(
    String index,
    String name, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
    Object? body,
  }) async {
    final response = await indicesPutAliasPutPluralWithHttpInfo(
      index,
      name,
      timeout: timeout,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Creates or updates an index template.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The name of the template.
  ///
  /// * [Object] body (required):
  ///
  /// * [bool] create:
  ///   Whether the index template should only be added if new or can also replace an existing one.
  ///
  /// * [String] cause:
  ///   User defined reason for creating/updating the index template.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<Response> indicesPutIndexTemplatePostWithHttpInfo(
    String name,
    Object body, {
    bool? create,
    String? cause,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_index_template/{name}'.replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (create != null) {
      queryParams.addAll(_queryParams('', 'create', create));
    }
    if (cause != null) {
      queryParams.addAll(_queryParams('', 'cause', cause));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates or updates an index template.
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The name of the template.
  ///
  /// * [Object] body (required):
  ///
  /// * [bool] create:
  ///   Whether the index template should only be added if new or can also replace an existing one.
  ///
  /// * [String] cause:
  ///   User defined reason for creating/updating the index template.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<void> indicesPutIndexTemplatePost(
    String name,
    Object body, {
    bool? create,
    String? cause,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    final response = await indicesPutIndexTemplatePostWithHttpInfo(
      name,
      body,
      create: create,
      cause: cause,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Creates or updates an index template.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The name of the template.
  ///
  /// * [Object] body (required):
  ///
  /// * [bool] create:
  ///   Whether the index template should only be added if new or can also replace an existing one.
  ///
  /// * [String] cause:
  ///   User defined reason for creating/updating the index template.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<Response> indicesPutIndexTemplatePutWithHttpInfo(
    String name,
    Object body, {
    bool? create,
    String? cause,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_index_template/{name}'.replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (create != null) {
      queryParams.addAll(_queryParams('', 'create', create));
    }
    if (cause != null) {
      queryParams.addAll(_queryParams('', 'cause', cause));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates or updates an index template.
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The name of the template.
  ///
  /// * [Object] body (required):
  ///
  /// * [bool] create:
  ///   Whether the index template should only be added if new or can also replace an existing one.
  ///
  /// * [String] cause:
  ///   User defined reason for creating/updating the index template.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<void> indicesPutIndexTemplatePut(
    String name,
    Object body, {
    bool? create,
    String? cause,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    final response = await indicesPutIndexTemplatePutWithHttpInfo(
      name,
      body,
      create: create,
      cause: cause,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Updates the index mappings.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] writeIndexOnly:
  ///   When true, applies mappings only to the write index of an alias or data stream.
  Future<Response> indicesPutMappingPostWithHttpInfo(
    String index,
    Object body, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? writeIndexOnly,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_mapping'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (writeIndexOnly != null) {
      queryParams.addAll(_queryParams('', 'write_index_only', writeIndexOnly));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Updates the index mappings.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] writeIndexOnly:
  ///   When true, applies mappings only to the write index of an alias or data stream.
  Future<IndicesPutMappingPostResponseContent?> indicesPutMappingPost(
    String index,
    Object body, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? writeIndexOnly,
  }) async {
    final response = await indicesPutMappingPostWithHttpInfo(
      index,
      body,
      timeout: timeout,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      writeIndexOnly: writeIndexOnly,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'IndicesPutMappingPostResponseContent',
      ) as IndicesPutMappingPostResponseContent;
    }
    return null;
  }

  /// Updates the index mappings.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] writeIndexOnly:
  ///   When true, applies mappings only to the write index of an alias or data stream.
  Future<Response> indicesPutMappingPutWithHttpInfo(
    String index,
    Object body, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? writeIndexOnly,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_mapping'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (writeIndexOnly != null) {
      queryParams.addAll(_queryParams('', 'write_index_only', writeIndexOnly));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Updates the index mappings.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] writeIndexOnly:
  ///   When true, applies mappings only to the write index of an alias or data stream.
  Future<IndicesPutMappingPutResponseContent?> indicesPutMappingPut(
    String index,
    Object body, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? writeIndexOnly,
  }) async {
    final response = await indicesPutMappingPutWithHttpInfo(
      index,
      body,
      timeout: timeout,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      writeIndexOnly: writeIndexOnly,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'IndicesPutMappingPutResponseContent',
      ) as IndicesPutMappingPutResponseContent;
    }
    return null;
  }

  /// Updates the index settings.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [Object] body (required):
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] preserveExisting:
  ///   Whether to update existing settings. If set to `true` existing settings on an index remain unchanged.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  Future<Response> indicesPutSettingsWithHttpInfo(
    Object body, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? timeout,
    bool? preserveExisting,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? flatSettings,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_settings';

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (preserveExisting != null) {
      queryParams
          .addAll(_queryParams('', 'preserve_existing', preserveExisting));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (flatSettings != null) {
      queryParams.addAll(_queryParams('', 'flat_settings', flatSettings));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Updates the index settings.
  ///
  /// Parameters:
  ///
  /// * [Object] body (required):
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] preserveExisting:
  ///   Whether to update existing settings. If set to `true` existing settings on an index remain unchanged.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  Future<void> indicesPutSettings(
    Object body, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? timeout,
    bool? preserveExisting,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? flatSettings,
  }) async {
    final response = await indicesPutSettingsWithHttpInfo(
      body,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      timeout: timeout,
      preserveExisting: preserveExisting,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      flatSettings: flatSettings,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Updates the index settings.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] preserveExisting:
  ///   Whether to update existing settings. If set to `true` existing settings on an index remain unchanged.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  Future<Response> indicesPutSettingsWithIndexWithHttpInfo(
    String index,
    Object body, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? timeout,
    bool? preserveExisting,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? flatSettings,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_settings'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (preserveExisting != null) {
      queryParams
          .addAll(_queryParams('', 'preserve_existing', preserveExisting));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (flatSettings != null) {
      queryParams.addAll(_queryParams('', 'flat_settings', flatSettings));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Updates the index settings.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] preserveExisting:
  ///   Whether to update existing settings. If set to `true` existing settings on an index remain unchanged.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  Future<void> indicesPutSettingsWithIndex(
    String index,
    Object body, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? timeout,
    bool? preserveExisting,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? flatSettings,
  }) async {
    final response = await indicesPutSettingsWithIndexWithHttpInfo(
      index,
      body,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      timeout: timeout,
      preserveExisting: preserveExisting,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      flatSettings: flatSettings,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Creates or updates an index template.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The name of the template.
  ///
  /// * [Object] body (required):
  ///
  /// * [int] order:
  ///   The order for this template when merging multiple matching ones (higher numbers are merged later, overriding the lower numbers).
  ///
  /// * [bool] create:
  ///   Whether the index template should only be added if new or can also replace an existing one.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<Response> indicesPutTemplatePostWithHttpInfo(
    String name,
    Object body, {
    int? order,
    bool? create,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_template/{name}'.replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (order != null) {
      queryParams.addAll(_queryParams('', 'order', order));
    }
    if (create != null) {
      queryParams.addAll(_queryParams('', 'create', create));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates or updates an index template.
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The name of the template.
  ///
  /// * [Object] body (required):
  ///
  /// * [int] order:
  ///   The order for this template when merging multiple matching ones (higher numbers are merged later, overriding the lower numbers).
  ///
  /// * [bool] create:
  ///   Whether the index template should only be added if new or can also replace an existing one.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<void> indicesPutTemplatePost(
    String name,
    Object body, {
    int? order,
    bool? create,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    final response = await indicesPutTemplatePostWithHttpInfo(
      name,
      body,
      order: order,
      create: create,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Creates or updates an index template.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The name of the template.
  ///
  /// * [Object] body (required):
  ///
  /// * [int] order:
  ///   The order for this template when merging multiple matching ones (higher numbers are merged later, overriding the lower numbers).
  ///
  /// * [bool] create:
  ///   Whether the index template should only be added if new or can also replace an existing one.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<Response> indicesPutTemplatePutWithHttpInfo(
    String name,
    Object body, {
    int? order,
    bool? create,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_template/{name}'.replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (order != null) {
      queryParams.addAll(_queryParams('', 'order', order));
    }
    if (create != null) {
      queryParams.addAll(_queryParams('', 'create', create));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates or updates an index template.
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The name of the template.
  ///
  /// * [Object] body (required):
  ///
  /// * [int] order:
  ///   The order for this template when merging multiple matching ones (higher numbers are merged later, overriding the lower numbers).
  ///
  /// * [bool] create:
  ///   Whether the index template should only be added if new or can also replace an existing one.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<void> indicesPutTemplatePut(
    String name,
    Object body, {
    int? order,
    bool? create,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    final response = await indicesPutTemplatePutWithHttpInfo(
      name,
      body,
      order: order,
      create: create,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about ongoing index shard recoveries.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] detailed:
  ///   Whether to display detailed information about shard recovery.
  ///
  /// * [bool] activeOnly:
  ///   Display only those recoveries that are currently on-going.
  Future<Response> indicesRecoveryWithHttpInfo({
    bool? detailed,
    bool? activeOnly,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_recovery';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (detailed != null) {
      queryParams.addAll(_queryParams('', 'detailed', detailed));
    }
    if (activeOnly != null) {
      queryParams.addAll(_queryParams('', 'active_only', activeOnly));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about ongoing index shard recoveries.
  ///
  /// Parameters:
  ///
  /// * [bool] detailed:
  ///   Whether to display detailed information about shard recovery.
  ///
  /// * [bool] activeOnly:
  ///   Display only those recoveries that are currently on-going.
  Future<void> indicesRecovery({
    bool? detailed,
    bool? activeOnly,
  }) async {
    final response = await indicesRecoveryWithHttpInfo(
      detailed: detailed,
      activeOnly: activeOnly,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about ongoing index shard recoveries.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] detailed:
  ///   Whether to display detailed information about shard recovery.
  ///
  /// * [bool] activeOnly:
  ///   Display only those recoveries that are currently on-going.
  Future<Response> indicesRecoveryWithIndexWithHttpInfo(
    String index, {
    bool? detailed,
    bool? activeOnly,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_recovery'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (detailed != null) {
      queryParams.addAll(_queryParams('', 'detailed', detailed));
    }
    if (activeOnly != null) {
      queryParams.addAll(_queryParams('', 'active_only', activeOnly));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about ongoing index shard recoveries.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] detailed:
  ///   Whether to display detailed information about shard recovery.
  ///
  /// * [bool] activeOnly:
  ///   Display only those recoveries that are currently on-going.
  Future<void> indicesRecoveryWithIndex(
    String index, {
    bool? detailed,
    bool? activeOnly,
  }) async {
    final response = await indicesRecoveryWithIndexWithHttpInfo(
      index,
      detailed: detailed,
      activeOnly: activeOnly,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Performs the refresh operation in one or more indices.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<Response> indicesRefreshGetWithHttpInfo({
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_refresh';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Performs the refresh operation in one or more indices.
  ///
  /// Parameters:
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<void> indicesRefreshGet({
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    final response = await indicesRefreshGetWithHttpInfo(
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Performs the refresh operation in one or more indices.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<Response> indicesRefreshGetWithIndexWithHttpInfo(
    String index, {
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_refresh'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Performs the refresh operation in one or more indices.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<void> indicesRefreshGetWithIndex(
    String index, {
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    final response = await indicesRefreshGetWithIndexWithHttpInfo(
      index,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Performs the refresh operation in one or more indices.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<Response> indicesRefreshPostWithHttpInfo({
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_refresh';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Performs the refresh operation in one or more indices.
  ///
  /// Parameters:
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<void> indicesRefreshPost({
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    final response = await indicesRefreshPostWithHttpInfo(
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Performs the refresh operation in one or more indices.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<Response> indicesRefreshPostWithIndexWithHttpInfo(
    String index, {
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_refresh'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Performs the refresh operation in one or more indices.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<void> indicesRefreshPostWithIndex(
    String index, {
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    final response = await indicesRefreshPostWithIndexWithHttpInfo(
      index,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about any matching indices, aliases, and data streams.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   Comma-separated list of names or wildcard expressions.
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<Response> indicesResolveIndexWithHttpInfo(
    String name, {
    ExpandWildcards? expandWildcards,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_resolve/index/{name}'.replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about any matching indices, aliases, and data streams.
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   Comma-separated list of names or wildcard expressions.
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<void> indicesResolveIndex(
    String name, {
    ExpandWildcards? expandWildcards,
  }) async {
    final response = await indicesResolveIndexWithHttpInfo(
      name,
      expandWildcards: expandWildcards,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Updates an alias to point to a new index when the existing index is considered to be too large or too old.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] alias (required):
  ///   The name of the alias to rollover.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] dryRun:
  ///   If set to true the rollover action will only be validated but not actually performed even if a condition matches.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] waitForActiveShards:
  ///   Set the number of active shards to wait for on the newly created rollover index before the operation returns.
  ///
  /// * [Object] body:
  Future<Response> indicesRolloverWithHttpInfo(
    String alias, {
    String? timeout,
    bool? dryRun,
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? waitForActiveShards,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{alias}/_rollover'.replaceAll('{alias}', alias);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (dryRun != null) {
      queryParams.addAll(_queryParams('', 'dry_run', dryRun));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (waitForActiveShards != null) {
      queryParams.addAll(
          _queryParams('', 'wait_for_active_shards', waitForActiveShards));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Updates an alias to point to a new index when the existing index is considered to be too large or too old.
  ///
  /// Parameters:
  ///
  /// * [String] alias (required):
  ///   The name of the alias to rollover.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] dryRun:
  ///   If set to true the rollover action will only be validated but not actually performed even if a condition matches.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] waitForActiveShards:
  ///   Set the number of active shards to wait for on the newly created rollover index before the operation returns.
  ///
  /// * [Object] body:
  Future<void> indicesRollover(
    String alias, {
    String? timeout,
    bool? dryRun,
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? waitForActiveShards,
    Object? body,
  }) async {
    final response = await indicesRolloverWithHttpInfo(
      alias,
      timeout: timeout,
      dryRun: dryRun,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      waitForActiveShards: waitForActiveShards,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Updates an alias to point to a new index when the existing index is considered to be too large or too old.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] alias (required):
  ///   The name of the alias to rollover.
  ///
  /// * [String] newIndex (required):
  ///   The name of the rollover index.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] dryRun:
  ///   If set to true the rollover action will only be validated but not actually performed even if a condition matches.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] waitForActiveShards:
  ///   Set the number of active shards to wait for on the newly created rollover index before the operation returns.
  ///
  /// * [Object] body:
  Future<Response> indicesRolloverWithNewIndexWithHttpInfo(
    String alias,
    String newIndex, {
    String? timeout,
    bool? dryRun,
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? waitForActiveShards,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{alias}/_rollover/{new_index}'
        .replaceAll('{alias}', alias)
        .replaceAll('{new_index}', newIndex);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (dryRun != null) {
      queryParams.addAll(_queryParams('', 'dry_run', dryRun));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (waitForActiveShards != null) {
      queryParams.addAll(
          _queryParams('', 'wait_for_active_shards', waitForActiveShards));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Updates an alias to point to a new index when the existing index is considered to be too large or too old.
  ///
  /// Parameters:
  ///
  /// * [String] alias (required):
  ///   The name of the alias to rollover.
  ///
  /// * [String] newIndex (required):
  ///   The name of the rollover index.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] dryRun:
  ///   If set to true the rollover action will only be validated but not actually performed even if a condition matches.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] waitForActiveShards:
  ///   Set the number of active shards to wait for on the newly created rollover index before the operation returns.
  ///
  /// * [Object] body:
  Future<void> indicesRolloverWithNewIndex(
    String alias,
    String newIndex, {
    String? timeout,
    bool? dryRun,
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? waitForActiveShards,
    Object? body,
  }) async {
    final response = await indicesRolloverWithNewIndexWithHttpInfo(
      alias,
      newIndex,
      timeout: timeout,
      dryRun: dryRun,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      waitForActiveShards: waitForActiveShards,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Provides low-level information about segments in a Lucene index.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] verbose:
  ///   Includes detailed memory usage by Lucene.
  Future<Response> indicesSegmentsWithHttpInfo({
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? verbose,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_segments';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (verbose != null) {
      queryParams.addAll(_queryParams('', 'verbose', verbose));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Provides low-level information about segments in a Lucene index.
  ///
  /// Parameters:
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] verbose:
  ///   Includes detailed memory usage by Lucene.
  Future<void> indicesSegments({
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? verbose,
  }) async {
    final response = await indicesSegmentsWithHttpInfo(
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      verbose: verbose,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Provides low-level information about segments in a Lucene index.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] verbose:
  ///   Includes detailed memory usage by Lucene.
  Future<Response> indicesSegmentsWithIndexWithHttpInfo(
    String index, {
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? verbose,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_segments'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (verbose != null) {
      queryParams.addAll(_queryParams('', 'verbose', verbose));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Provides low-level information about segments in a Lucene index.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] verbose:
  ///   Includes detailed memory usage by Lucene.
  Future<void> indicesSegmentsWithIndex(
    String index, {
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? verbose,
  }) async {
    final response = await indicesSegmentsWithIndexWithHttpInfo(
      index,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      verbose: verbose,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Provides store information for shard copies of indices.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [List<StatusMember>] status:
  ///   Comma-separated list of statuses used to filter on shards to get store information for.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<Response> indicesShardStoresWithHttpInfo({
    List<StatusMember>? status,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_shard_stores';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (status != null) {
      queryParams.addAll(_queryParams('multi', 'status', status));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Provides store information for shard copies of indices.
  ///
  /// Parameters:
  ///
  /// * [List<StatusMember>] status:
  ///   Comma-separated list of statuses used to filter on shards to get store information for.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<void> indicesShardStores({
    List<StatusMember>? status,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    final response = await indicesShardStoresWithHttpInfo(
      status: status,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Provides store information for shard copies of indices.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [List<StatusMember>] status:
  ///   Comma-separated list of statuses used to filter on shards to get store information for.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<Response> indicesShardStoresWithIndexWithHttpInfo(
    String index, {
    List<StatusMember>? status,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_shard_stores'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (status != null) {
      queryParams.addAll(_queryParams('multi', 'status', status));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Provides store information for shard copies of indices.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [List<StatusMember>] status:
  ///   Comma-separated list of statuses used to filter on shards to get store information for.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<void> indicesShardStoresWithIndex(
    String index, {
    List<StatusMember>? status,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    final response = await indicesShardStoresWithIndexWithHttpInfo(
      index,
      status: status,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allow to shrink an existing index into a new index with fewer primary shards.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   The name of the source index to shrink.
  ///
  /// * [String] target (required):
  ///   The name of the target index.
  ///
  /// * [bool] copySettings:
  ///   whether or not to copy settings from the source index.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] waitForActiveShards:
  ///   Set the number of active shards to wait for on the shrunken index before the operation returns.
  ///
  /// * [Object] body:
  Future<Response> indicesShrinkPostWithHttpInfo(
    String index,
    String target, {
    bool? copySettings,
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? waitForActiveShards,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_shrink/{target}'
        .replaceAll('{index}', index)
        .replaceAll('{target}', target);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (copySettings != null) {
      queryParams.addAll(_queryParams('', 'copy_settings', copySettings));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (waitForActiveShards != null) {
      queryParams.addAll(
          _queryParams('', 'wait_for_active_shards', waitForActiveShards));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allow to shrink an existing index into a new index with fewer primary shards.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   The name of the source index to shrink.
  ///
  /// * [String] target (required):
  ///   The name of the target index.
  ///
  /// * [bool] copySettings:
  ///   whether or not to copy settings from the source index.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] waitForActiveShards:
  ///   Set the number of active shards to wait for on the shrunken index before the operation returns.
  ///
  /// * [Object] body:
  Future<void> indicesShrinkPost(
    String index,
    String target, {
    bool? copySettings,
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? waitForActiveShards,
    Object? body,
  }) async {
    final response = await indicesShrinkPostWithHttpInfo(
      index,
      target,
      copySettings: copySettings,
      timeout: timeout,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      waitForActiveShards: waitForActiveShards,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allow to shrink an existing index into a new index with fewer primary shards.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   The name of the source index to shrink.
  ///
  /// * [String] target (required):
  ///   The name of the target index.
  ///
  /// * [bool] copySettings:
  ///   whether or not to copy settings from the source index.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] waitForActiveShards:
  ///   Set the number of active shards to wait for on the shrunken index before the operation returns.
  ///
  /// * [Object] body:
  Future<Response> indicesShrinkPutWithHttpInfo(
    String index,
    String target, {
    bool? copySettings,
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? waitForActiveShards,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_shrink/{target}'
        .replaceAll('{index}', index)
        .replaceAll('{target}', target);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (copySettings != null) {
      queryParams.addAll(_queryParams('', 'copy_settings', copySettings));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (waitForActiveShards != null) {
      queryParams.addAll(
          _queryParams('', 'wait_for_active_shards', waitForActiveShards));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allow to shrink an existing index into a new index with fewer primary shards.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   The name of the source index to shrink.
  ///
  /// * [String] target (required):
  ///   The name of the target index.
  ///
  /// * [bool] copySettings:
  ///   whether or not to copy settings from the source index.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] waitForActiveShards:
  ///   Set the number of active shards to wait for on the shrunken index before the operation returns.
  ///
  /// * [Object] body:
  Future<void> indicesShrinkPut(
    String index,
    String target, {
    bool? copySettings,
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? waitForActiveShards,
    Object? body,
  }) async {
    final response = await indicesShrinkPutWithHttpInfo(
      index,
      target,
      copySettings: copySettings,
      timeout: timeout,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      waitForActiveShards: waitForActiveShards,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Simulate matching the given index name against the index templates in the system.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The name of the index (it must be a concrete index name).
  ///
  /// * [bool] create:
  ///   Whether the index template we optionally defined in the body should only be dry-run added if new or can also replace an existing one.
  ///
  /// * [String] cause:
  ///   User defined reason for dry-run creating the new template for simulation purposes.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [Object] body:
  Future<Response> indicesSimulateIndexTemplateWithHttpInfo(
    String name, {
    bool? create,
    String? cause,
    String? masterTimeout,
    String? clusterManagerTimeout,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path =
        r'/_index_template/_simulate_index/{name}'.replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (create != null) {
      queryParams.addAll(_queryParams('', 'create', create));
    }
    if (cause != null) {
      queryParams.addAll(_queryParams('', 'cause', cause));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Simulate matching the given index name against the index templates in the system.
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The name of the index (it must be a concrete index name).
  ///
  /// * [bool] create:
  ///   Whether the index template we optionally defined in the body should only be dry-run added if new or can also replace an existing one.
  ///
  /// * [String] cause:
  ///   User defined reason for dry-run creating the new template for simulation purposes.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [Object] body:
  Future<void> indicesSimulateIndexTemplate(
    String name, {
    bool? create,
    String? cause,
    String? masterTimeout,
    String? clusterManagerTimeout,
    Object? body,
  }) async {
    final response = await indicesSimulateIndexTemplateWithHttpInfo(
      name,
      create: create,
      cause: cause,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Simulate resolving the given template name or body.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] create:
  ///   Whether the index template we optionally defined in the body should only be dry-run added if new or can also replace an existing one.
  ///
  /// * [String] cause:
  ///   User defined reason for dry-run creating the new template for simulation purposes.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [Object] body:
  Future<Response> indicesSimulateTemplateWithHttpInfo({
    bool? create,
    String? cause,
    String? masterTimeout,
    String? clusterManagerTimeout,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_index_template/_simulate';

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (create != null) {
      queryParams.addAll(_queryParams('', 'create', create));
    }
    if (cause != null) {
      queryParams.addAll(_queryParams('', 'cause', cause));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Simulate resolving the given template name or body.
  ///
  /// Parameters:
  ///
  /// * [bool] create:
  ///   Whether the index template we optionally defined in the body should only be dry-run added if new or can also replace an existing one.
  ///
  /// * [String] cause:
  ///   User defined reason for dry-run creating the new template for simulation purposes.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [Object] body:
  Future<void> indicesSimulateTemplate({
    bool? create,
    String? cause,
    String? masterTimeout,
    String? clusterManagerTimeout,
    Object? body,
  }) async {
    final response = await indicesSimulateTemplateWithHttpInfo(
      create: create,
      cause: cause,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Simulate resolving the given template name or body.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The name of the template.
  ///
  /// * [bool] create:
  ///   Whether the index template we optionally defined in the body should only be dry-run added if new or can also replace an existing one.
  ///
  /// * [String] cause:
  ///   User defined reason for dry-run creating the new template for simulation purposes.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [Object] body:
  Future<Response> indicesSimulateTemplateWithNameWithHttpInfo(
    String name, {
    bool? create,
    String? cause,
    String? masterTimeout,
    String? clusterManagerTimeout,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path =
        r'/_index_template/_simulate/{name}'.replaceAll('{name}', name);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (create != null) {
      queryParams.addAll(_queryParams('', 'create', create));
    }
    if (cause != null) {
      queryParams.addAll(_queryParams('', 'cause', cause));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Simulate resolving the given template name or body.
  ///
  /// Parameters:
  ///
  /// * [String] name (required):
  ///   The name of the template.
  ///
  /// * [bool] create:
  ///   Whether the index template we optionally defined in the body should only be dry-run added if new or can also replace an existing one.
  ///
  /// * [String] cause:
  ///   User defined reason for dry-run creating the new template for simulation purposes.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [Object] body:
  Future<void> indicesSimulateTemplateWithName(
    String name, {
    bool? create,
    String? cause,
    String? masterTimeout,
    String? clusterManagerTimeout,
    Object? body,
  }) async {
    final response = await indicesSimulateTemplateWithNameWithHttpInfo(
      name,
      create: create,
      cause: cause,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows you to split an existing index into a new index with more primary shards.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   The name of the source index to split.
  ///
  /// * [String] target (required):
  ///   The name of the target index.
  ///
  /// * [bool] copySettings:
  ///   whether or not to copy settings from the source index.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] waitForActiveShards:
  ///   Set the number of active shards to wait for on the shrunken index before the operation returns.
  ///
  /// * [Object] body:
  Future<Response> indicesSplitPostWithHttpInfo(
    String index,
    String target, {
    bool? copySettings,
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? waitForActiveShards,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_split/{target}'
        .replaceAll('{index}', index)
        .replaceAll('{target}', target);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (copySettings != null) {
      queryParams.addAll(_queryParams('', 'copy_settings', copySettings));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (waitForActiveShards != null) {
      queryParams.addAll(
          _queryParams('', 'wait_for_active_shards', waitForActiveShards));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows you to split an existing index into a new index with more primary shards.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   The name of the source index to split.
  ///
  /// * [String] target (required):
  ///   The name of the target index.
  ///
  /// * [bool] copySettings:
  ///   whether or not to copy settings from the source index.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] waitForActiveShards:
  ///   Set the number of active shards to wait for on the shrunken index before the operation returns.
  ///
  /// * [Object] body:
  Future<void> indicesSplitPost(
    String index,
    String target, {
    bool? copySettings,
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? waitForActiveShards,
    Object? body,
  }) async {
    final response = await indicesSplitPostWithHttpInfo(
      index,
      target,
      copySettings: copySettings,
      timeout: timeout,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      waitForActiveShards: waitForActiveShards,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows you to split an existing index into a new index with more primary shards.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   The name of the source index to split.
  ///
  /// * [String] target (required):
  ///   The name of the target index.
  ///
  /// * [bool] copySettings:
  ///   whether or not to copy settings from the source index.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] waitForActiveShards:
  ///   Set the number of active shards to wait for on the shrunken index before the operation returns.
  ///
  /// * [Object] body:
  Future<Response> indicesSplitPutWithHttpInfo(
    String index,
    String target, {
    bool? copySettings,
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? waitForActiveShards,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_split/{target}'
        .replaceAll('{index}', index)
        .replaceAll('{target}', target);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (copySettings != null) {
      queryParams.addAll(_queryParams('', 'copy_settings', copySettings));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (waitForActiveShards != null) {
      queryParams.addAll(
          _queryParams('', 'wait_for_active_shards', waitForActiveShards));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows you to split an existing index into a new index with more primary shards.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   The name of the source index to split.
  ///
  /// * [String] target (required):
  ///   The name of the target index.
  ///
  /// * [bool] copySettings:
  ///   whether or not to copy settings from the source index.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] waitForActiveShards:
  ///   Set the number of active shards to wait for on the shrunken index before the operation returns.
  ///
  /// * [Object] body:
  Future<void> indicesSplitPut(
    String index,
    String target, {
    bool? copySettings,
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? waitForActiveShards,
    Object? body,
  }) async {
    final response = await indicesSplitPutWithHttpInfo(
      index,
      target,
      copySettings: copySettings,
      timeout: timeout,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      waitForActiveShards: waitForActiveShards,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Provides statistics on operations happening in an index.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [List<String>] completionFields:
  ///   Comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards).
  ///
  /// * [List<String>] fielddataFields:
  ///   Comma-separated list of fields for `fielddata` index metric (supports wildcards).
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards).
  ///
  /// * [List<String>] groups:
  ///   Comma-separated list of search groups for `search` index metric.
  ///
  /// * [IndiciesStatLevel] level:
  ///   Return stats aggregated at cluster, index or shard level.
  ///
  /// * [bool] includeSegmentFileSizes:
  ///   Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
  ///
  /// * [bool] includeUnloadedSegments:
  ///   If set to true segment stats will include stats for segments that are not currently loaded into memory.
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] forbidClosedIndices:
  ///   If set to false stats will also collected from closed indices if explicitly specified or if expand_wildcards expands to closed indices.
  Future<Response> indicesStatsWithHttpInfo({
    List<String>? completionFields,
    List<String>? fielddataFields,
    List<String>? fields,
    List<String>? groups,
    IndiciesStatLevel? level,
    bool? includeSegmentFileSizes,
    bool? includeUnloadedSegments,
    ExpandWildcards? expandWildcards,
    bool? forbidClosedIndices,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_stats';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (completionFields != null) {
      queryParams
          .addAll(_queryParams('multi', 'completion_fields', completionFields));
    }
    if (fielddataFields != null) {
      queryParams
          .addAll(_queryParams('multi', 'fielddata_fields', fielddataFields));
    }
    if (fields != null) {
      queryParams.addAll(_queryParams('multi', 'fields', fields));
    }
    if (groups != null) {
      queryParams.addAll(_queryParams('multi', 'groups', groups));
    }
    if (level != null) {
      queryParams.addAll(_queryParams('', 'level', level));
    }
    if (includeSegmentFileSizes != null) {
      queryParams.addAll(_queryParams(
          '', 'include_segment_file_sizes', includeSegmentFileSizes));
    }
    if (includeUnloadedSegments != null) {
      queryParams.addAll(_queryParams(
          '', 'include_unloaded_segments', includeUnloadedSegments));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (forbidClosedIndices != null) {
      queryParams.addAll(
          _queryParams('', 'forbid_closed_indices', forbidClosedIndices));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Provides statistics on operations happening in an index.
  ///
  /// Parameters:
  ///
  /// * [List<String>] completionFields:
  ///   Comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards).
  ///
  /// * [List<String>] fielddataFields:
  ///   Comma-separated list of fields for `fielddata` index metric (supports wildcards).
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards).
  ///
  /// * [List<String>] groups:
  ///   Comma-separated list of search groups for `search` index metric.
  ///
  /// * [IndiciesStatLevel] level:
  ///   Return stats aggregated at cluster, index or shard level.
  ///
  /// * [bool] includeSegmentFileSizes:
  ///   Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
  ///
  /// * [bool] includeUnloadedSegments:
  ///   If set to true segment stats will include stats for segments that are not currently loaded into memory.
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] forbidClosedIndices:
  ///   If set to false stats will also collected from closed indices if explicitly specified or if expand_wildcards expands to closed indices.
  Future<void> indicesStats({
    List<String>? completionFields,
    List<String>? fielddataFields,
    List<String>? fields,
    List<String>? groups,
    IndiciesStatLevel? level,
    bool? includeSegmentFileSizes,
    bool? includeUnloadedSegments,
    ExpandWildcards? expandWildcards,
    bool? forbidClosedIndices,
  }) async {
    final response = await indicesStatsWithHttpInfo(
      completionFields: completionFields,
      fielddataFields: fielddataFields,
      fields: fields,
      groups: groups,
      level: level,
      includeSegmentFileSizes: includeSegmentFileSizes,
      includeUnloadedSegments: includeUnloadedSegments,
      expandWildcards: expandWildcards,
      forbidClosedIndices: forbidClosedIndices,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Provides statistics on operations happening in an index.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [List<String>] completionFields:
  ///   Comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards).
  ///
  /// * [List<String>] fielddataFields:
  ///   Comma-separated list of fields for `fielddata` index metric (supports wildcards).
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards).
  ///
  /// * [List<String>] groups:
  ///   Comma-separated list of search groups for `search` index metric.
  ///
  /// * [IndiciesStatLevel] level:
  ///   Return stats aggregated at cluster, index or shard level.
  ///
  /// * [bool] includeSegmentFileSizes:
  ///   Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
  ///
  /// * [bool] includeUnloadedSegments:
  ///   If set to true segment stats will include stats for segments that are not currently loaded into memory.
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] forbidClosedIndices:
  ///   If set to false stats will also collected from closed indices if explicitly specified or if expand_wildcards expands to closed indices.
  Future<Response> indicesStatsWithIndexWithHttpInfo(
    String index, {
    List<String>? completionFields,
    List<String>? fielddataFields,
    List<String>? fields,
    List<String>? groups,
    IndiciesStatLevel? level,
    bool? includeSegmentFileSizes,
    bool? includeUnloadedSegments,
    ExpandWildcards? expandWildcards,
    bool? forbidClosedIndices,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_stats'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (completionFields != null) {
      queryParams
          .addAll(_queryParams('multi', 'completion_fields', completionFields));
    }
    if (fielddataFields != null) {
      queryParams
          .addAll(_queryParams('multi', 'fielddata_fields', fielddataFields));
    }
    if (fields != null) {
      queryParams.addAll(_queryParams('multi', 'fields', fields));
    }
    if (groups != null) {
      queryParams.addAll(_queryParams('multi', 'groups', groups));
    }
    if (level != null) {
      queryParams.addAll(_queryParams('', 'level', level));
    }
    if (includeSegmentFileSizes != null) {
      queryParams.addAll(_queryParams(
          '', 'include_segment_file_sizes', includeSegmentFileSizes));
    }
    if (includeUnloadedSegments != null) {
      queryParams.addAll(_queryParams(
          '', 'include_unloaded_segments', includeUnloadedSegments));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (forbidClosedIndices != null) {
      queryParams.addAll(
          _queryParams('', 'forbid_closed_indices', forbidClosedIndices));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Provides statistics on operations happening in an index.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [List<String>] completionFields:
  ///   Comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards).
  ///
  /// * [List<String>] fielddataFields:
  ///   Comma-separated list of fields for `fielddata` index metric (supports wildcards).
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards).
  ///
  /// * [List<String>] groups:
  ///   Comma-separated list of search groups for `search` index metric.
  ///
  /// * [IndiciesStatLevel] level:
  ///   Return stats aggregated at cluster, index or shard level.
  ///
  /// * [bool] includeSegmentFileSizes:
  ///   Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
  ///
  /// * [bool] includeUnloadedSegments:
  ///   If set to true segment stats will include stats for segments that are not currently loaded into memory.
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] forbidClosedIndices:
  ///   If set to false stats will also collected from closed indices if explicitly specified or if expand_wildcards expands to closed indices.
  Future<void> indicesStatsWithIndex(
    String index, {
    List<String>? completionFields,
    List<String>? fielddataFields,
    List<String>? fields,
    List<String>? groups,
    IndiciesStatLevel? level,
    bool? includeSegmentFileSizes,
    bool? includeUnloadedSegments,
    ExpandWildcards? expandWildcards,
    bool? forbidClosedIndices,
  }) async {
    final response = await indicesStatsWithIndexWithHttpInfo(
      index,
      completionFields: completionFields,
      fielddataFields: fielddataFields,
      fields: fields,
      groups: groups,
      level: level,
      includeSegmentFileSizes: includeSegmentFileSizes,
      includeUnloadedSegments: includeUnloadedSegments,
      expandWildcards: expandWildcards,
      forbidClosedIndices: forbidClosedIndices,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Provides statistics on operations happening in an index.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [String] metric (required):
  ///   Limit the information returned the specific metrics.
  ///
  /// * [List<String>] completionFields:
  ///   Comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards).
  ///
  /// * [List<String>] fielddataFields:
  ///   Comma-separated list of fields for `fielddata` index metric (supports wildcards).
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards).
  ///
  /// * [List<String>] groups:
  ///   Comma-separated list of search groups for `search` index metric.
  ///
  /// * [IndiciesStatLevel] level:
  ///   Return stats aggregated at cluster, index or shard level.
  ///
  /// * [bool] includeSegmentFileSizes:
  ///   Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
  ///
  /// * [bool] includeUnloadedSegments:
  ///   If set to true segment stats will include stats for segments that are not currently loaded into memory.
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] forbidClosedIndices:
  ///   If set to false stats will also collected from closed indices if explicitly specified or if expand_wildcards expands to closed indices.
  Future<Response> indicesStatsWithIndexMetricWithHttpInfo(
    String index,
    String metric, {
    List<String>? completionFields,
    List<String>? fielddataFields,
    List<String>? fields,
    List<String>? groups,
    IndiciesStatLevel? level,
    bool? includeSegmentFileSizes,
    bool? includeUnloadedSegments,
    ExpandWildcards? expandWildcards,
    bool? forbidClosedIndices,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_stats/{metric}'
        .replaceAll('{index}', index)
        .replaceAll('{metric}', metric);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (completionFields != null) {
      queryParams
          .addAll(_queryParams('multi', 'completion_fields', completionFields));
    }
    if (fielddataFields != null) {
      queryParams
          .addAll(_queryParams('multi', 'fielddata_fields', fielddataFields));
    }
    if (fields != null) {
      queryParams.addAll(_queryParams('multi', 'fields', fields));
    }
    if (groups != null) {
      queryParams.addAll(_queryParams('multi', 'groups', groups));
    }
    if (level != null) {
      queryParams.addAll(_queryParams('', 'level', level));
    }
    if (includeSegmentFileSizes != null) {
      queryParams.addAll(_queryParams(
          '', 'include_segment_file_sizes', includeSegmentFileSizes));
    }
    if (includeUnloadedSegments != null) {
      queryParams.addAll(_queryParams(
          '', 'include_unloaded_segments', includeUnloadedSegments));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (forbidClosedIndices != null) {
      queryParams.addAll(
          _queryParams('', 'forbid_closed_indices', forbidClosedIndices));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Provides statistics on operations happening in an index.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [String] metric (required):
  ///   Limit the information returned the specific metrics.
  ///
  /// * [List<String>] completionFields:
  ///   Comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards).
  ///
  /// * [List<String>] fielddataFields:
  ///   Comma-separated list of fields for `fielddata` index metric (supports wildcards).
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards).
  ///
  /// * [List<String>] groups:
  ///   Comma-separated list of search groups for `search` index metric.
  ///
  /// * [IndiciesStatLevel] level:
  ///   Return stats aggregated at cluster, index or shard level.
  ///
  /// * [bool] includeSegmentFileSizes:
  ///   Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
  ///
  /// * [bool] includeUnloadedSegments:
  ///   If set to true segment stats will include stats for segments that are not currently loaded into memory.
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] forbidClosedIndices:
  ///   If set to false stats will also collected from closed indices if explicitly specified or if expand_wildcards expands to closed indices.
  Future<void> indicesStatsWithIndexMetric(
    String index,
    String metric, {
    List<String>? completionFields,
    List<String>? fielddataFields,
    List<String>? fields,
    List<String>? groups,
    IndiciesStatLevel? level,
    bool? includeSegmentFileSizes,
    bool? includeUnloadedSegments,
    ExpandWildcards? expandWildcards,
    bool? forbidClosedIndices,
  }) async {
    final response = await indicesStatsWithIndexMetricWithHttpInfo(
      index,
      metric,
      completionFields: completionFields,
      fielddataFields: fielddataFields,
      fields: fields,
      groups: groups,
      level: level,
      includeSegmentFileSizes: includeSegmentFileSizes,
      includeUnloadedSegments: includeUnloadedSegments,
      expandWildcards: expandWildcards,
      forbidClosedIndices: forbidClosedIndices,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Provides statistics on operations happening in an index.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] metric (required):
  ///   Limit the information returned the specific metrics.
  ///
  /// * [List<String>] completionFields:
  ///   Comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards).
  ///
  /// * [List<String>] fielddataFields:
  ///   Comma-separated list of fields for `fielddata` index metric (supports wildcards).
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards).
  ///
  /// * [List<String>] groups:
  ///   Comma-separated list of search groups for `search` index metric.
  ///
  /// * [IndiciesStatLevel] level:
  ///   Return stats aggregated at cluster, index or shard level.
  ///
  /// * [bool] includeSegmentFileSizes:
  ///   Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
  ///
  /// * [bool] includeUnloadedSegments:
  ///   If set to true segment stats will include stats for segments that are not currently loaded into memory.
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] forbidClosedIndices:
  ///   If set to false stats will also collected from closed indices if explicitly specified or if expand_wildcards expands to closed indices.
  Future<Response> indicesStatsWithMetricWithHttpInfo(
    String metric, {
    List<String>? completionFields,
    List<String>? fielddataFields,
    List<String>? fields,
    List<String>? groups,
    IndiciesStatLevel? level,
    bool? includeSegmentFileSizes,
    bool? includeUnloadedSegments,
    ExpandWildcards? expandWildcards,
    bool? forbidClosedIndices,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_stats/{metric}'.replaceAll('{metric}', metric);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (completionFields != null) {
      queryParams
          .addAll(_queryParams('multi', 'completion_fields', completionFields));
    }
    if (fielddataFields != null) {
      queryParams
          .addAll(_queryParams('multi', 'fielddata_fields', fielddataFields));
    }
    if (fields != null) {
      queryParams.addAll(_queryParams('multi', 'fields', fields));
    }
    if (groups != null) {
      queryParams.addAll(_queryParams('multi', 'groups', groups));
    }
    if (level != null) {
      queryParams.addAll(_queryParams('', 'level', level));
    }
    if (includeSegmentFileSizes != null) {
      queryParams.addAll(_queryParams(
          '', 'include_segment_file_sizes', includeSegmentFileSizes));
    }
    if (includeUnloadedSegments != null) {
      queryParams.addAll(_queryParams(
          '', 'include_unloaded_segments', includeUnloadedSegments));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (forbidClosedIndices != null) {
      queryParams.addAll(
          _queryParams('', 'forbid_closed_indices', forbidClosedIndices));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Provides statistics on operations happening in an index.
  ///
  /// Parameters:
  ///
  /// * [String] metric (required):
  ///   Limit the information returned the specific metrics.
  ///
  /// * [List<String>] completionFields:
  ///   Comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards).
  ///
  /// * [List<String>] fielddataFields:
  ///   Comma-separated list of fields for `fielddata` index metric (supports wildcards).
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards).
  ///
  /// * [List<String>] groups:
  ///   Comma-separated list of search groups for `search` index metric.
  ///
  /// * [IndiciesStatLevel] level:
  ///   Return stats aggregated at cluster, index or shard level.
  ///
  /// * [bool] includeSegmentFileSizes:
  ///   Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
  ///
  /// * [bool] includeUnloadedSegments:
  ///   If set to true segment stats will include stats for segments that are not currently loaded into memory.
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] forbidClosedIndices:
  ///   If set to false stats will also collected from closed indices if explicitly specified or if expand_wildcards expands to closed indices.
  Future<void> indicesStatsWithMetric(
    String metric, {
    List<String>? completionFields,
    List<String>? fielddataFields,
    List<String>? fields,
    List<String>? groups,
    IndiciesStatLevel? level,
    bool? includeSegmentFileSizes,
    bool? includeUnloadedSegments,
    ExpandWildcards? expandWildcards,
    bool? forbidClosedIndices,
  }) async {
    final response = await indicesStatsWithMetricWithHttpInfo(
      metric,
      completionFields: completionFields,
      fielddataFields: fielddataFields,
      fields: fields,
      groups: groups,
      level: level,
      includeSegmentFileSizes: includeSegmentFileSizes,
      includeUnloadedSegments: includeUnloadedSegments,
      expandWildcards: expandWildcards,
      forbidClosedIndices: forbidClosedIndices,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Updates index aliases.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [IndicesUpdateAliasesBodyParams] indicesUpdateAliasesBodyParams (required):
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<Response> indicesUpdateAliasesWithHttpInfo(
    IndicesUpdateAliasesBodyParams indicesUpdateAliasesBodyParams, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_aliases';

    // ignore: prefer_final_locals
    Object? postBody = indicesUpdateAliasesBodyParams;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Updates index aliases.
  ///
  /// Parameters:
  ///
  /// * [IndicesUpdateAliasesBodyParams] indicesUpdateAliasesBodyParams (required):
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<IndicesUpdateAliasesResponseContent?> indicesUpdateAliases(
    IndicesUpdateAliasesBodyParams indicesUpdateAliasesBodyParams, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    final response = await indicesUpdateAliasesWithHttpInfo(
      indicesUpdateAliasesBodyParams,
      timeout: timeout,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'IndicesUpdateAliasesResponseContent',
      ) as IndicesUpdateAliasesResponseContent;
    }
    return null;
  }

  /// The _upgrade API is no longer useful and will be removed.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] waitForCompletion:
  ///   Should this request wait until the operation has completed before returning.
  ///
  /// * [bool] onlyAncientSegments:
  ///   If true, only ancient (an older Lucene major release) segments will be upgraded.
  Future<Response> indicesUpgradeWithHttpInfo({
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? ignoreUnavailable,
    bool? waitForCompletion,
    bool? onlyAncientSegments,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_upgrade';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (waitForCompletion != null) {
      queryParams
          .addAll(_queryParams('', 'wait_for_completion', waitForCompletion));
    }
    if (onlyAncientSegments != null) {
      queryParams.addAll(
          _queryParams('', 'only_ancient_segments', onlyAncientSegments));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// The _upgrade API is no longer useful and will be removed.
  ///
  /// Parameters:
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] waitForCompletion:
  ///   Should this request wait until the operation has completed before returning.
  ///
  /// * [bool] onlyAncientSegments:
  ///   If true, only ancient (an older Lucene major release) segments will be upgraded.
  Future<void> indicesUpgrade({
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? ignoreUnavailable,
    bool? waitForCompletion,
    bool? onlyAncientSegments,
  }) async {
    final response = await indicesUpgradeWithHttpInfo(
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      ignoreUnavailable: ignoreUnavailable,
      waitForCompletion: waitForCompletion,
      onlyAncientSegments: onlyAncientSegments,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// The _upgrade API is no longer useful and will be removed.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] waitForCompletion:
  ///   Should this request wait until the operation has completed before returning.
  ///
  /// * [bool] onlyAncientSegments:
  ///   If true, only ancient (an older Lucene major release) segments will be upgraded.
  Future<Response> indicesUpgradeWithIndexWithHttpInfo(
    String index, {
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? ignoreUnavailable,
    bool? waitForCompletion,
    bool? onlyAncientSegments,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_upgrade'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (waitForCompletion != null) {
      queryParams
          .addAll(_queryParams('', 'wait_for_completion', waitForCompletion));
    }
    if (onlyAncientSegments != null) {
      queryParams.addAll(
          _queryParams('', 'only_ancient_segments', onlyAncientSegments));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// The _upgrade API is no longer useful and will be removed.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] waitForCompletion:
  ///   Should this request wait until the operation has completed before returning.
  ///
  /// * [bool] onlyAncientSegments:
  ///   If true, only ancient (an older Lucene major release) segments will be upgraded.
  Future<void> indicesUpgradeWithIndex(
    String index, {
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? ignoreUnavailable,
    bool? waitForCompletion,
    bool? onlyAncientSegments,
  }) async {
    final response = await indicesUpgradeWithIndexWithHttpInfo(
      index,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      ignoreUnavailable: ignoreUnavailable,
      waitForCompletion: waitForCompletion,
      onlyAncientSegments: onlyAncientSegments,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows a user to validate a potentially expensive query without executing it.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] explain:
  ///   Return detailed information about the error.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcard and prefix queries should be analyzed.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The field to use as default where no field prefix is given in the query string.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [bool] rewrite:
  ///   Provide a more detailed explanation showing the actual Lucene query that will be executed.
  ///
  /// * [bool] allShards:
  ///   Execute validation on all shards instead of one random shard per index.
  Future<Response> indicesValidateQueryGetWithHttpInfo({
    bool? explain,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    String? q,
    String? analyzer,
    bool? analyzeWildcard,
    DefaultOperator? defaultOperator,
    String? df,
    bool? lenient,
    bool? rewrite,
    bool? allShards,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_validate/query';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (explain != null) {
      queryParams.addAll(_queryParams('', 'explain', explain));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (q != null) {
      queryParams.addAll(_queryParams('', 'q', q));
    }
    if (analyzer != null) {
      queryParams.addAll(_queryParams('', 'analyzer', analyzer));
    }
    if (analyzeWildcard != null) {
      queryParams.addAll(_queryParams('', 'analyze_wildcard', analyzeWildcard));
    }
    if (defaultOperator != null) {
      queryParams.addAll(_queryParams('', 'default_operator', defaultOperator));
    }
    if (df != null) {
      queryParams.addAll(_queryParams('', 'df', df));
    }
    if (lenient != null) {
      queryParams.addAll(_queryParams('', 'lenient', lenient));
    }
    if (rewrite != null) {
      queryParams.addAll(_queryParams('', 'rewrite', rewrite));
    }
    if (allShards != null) {
      queryParams.addAll(_queryParams('', 'all_shards', allShards));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows a user to validate a potentially expensive query without executing it.
  ///
  /// Parameters:
  ///
  /// * [bool] explain:
  ///   Return detailed information about the error.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcard and prefix queries should be analyzed.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The field to use as default where no field prefix is given in the query string.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [bool] rewrite:
  ///   Provide a more detailed explanation showing the actual Lucene query that will be executed.
  ///
  /// * [bool] allShards:
  ///   Execute validation on all shards instead of one random shard per index.
  Future<void> indicesValidateQueryGet({
    bool? explain,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    String? q,
    String? analyzer,
    bool? analyzeWildcard,
    DefaultOperator? defaultOperator,
    String? df,
    bool? lenient,
    bool? rewrite,
    bool? allShards,
  }) async {
    final response = await indicesValidateQueryGetWithHttpInfo(
      explain: explain,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      q: q,
      analyzer: analyzer,
      analyzeWildcard: analyzeWildcard,
      defaultOperator: defaultOperator,
      df: df,
      lenient: lenient,
      rewrite: rewrite,
      allShards: allShards,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows a user to validate a potentially expensive query without executing it.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] explain:
  ///   Return detailed information about the error.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcard and prefix queries should be analyzed.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The field to use as default where no field prefix is given in the query string.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [bool] rewrite:
  ///   Provide a more detailed explanation showing the actual Lucene query that will be executed.
  ///
  /// * [bool] allShards:
  ///   Execute validation on all shards instead of one random shard per index.
  Future<Response> indicesValidateQueryGetWithIndexWithHttpInfo(
    String index, {
    bool? explain,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    String? q,
    String? analyzer,
    bool? analyzeWildcard,
    DefaultOperator? defaultOperator,
    String? df,
    bool? lenient,
    bool? rewrite,
    bool? allShards,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_validate/query'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (explain != null) {
      queryParams.addAll(_queryParams('', 'explain', explain));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (q != null) {
      queryParams.addAll(_queryParams('', 'q', q));
    }
    if (analyzer != null) {
      queryParams.addAll(_queryParams('', 'analyzer', analyzer));
    }
    if (analyzeWildcard != null) {
      queryParams.addAll(_queryParams('', 'analyze_wildcard', analyzeWildcard));
    }
    if (defaultOperator != null) {
      queryParams.addAll(_queryParams('', 'default_operator', defaultOperator));
    }
    if (df != null) {
      queryParams.addAll(_queryParams('', 'df', df));
    }
    if (lenient != null) {
      queryParams.addAll(_queryParams('', 'lenient', lenient));
    }
    if (rewrite != null) {
      queryParams.addAll(_queryParams('', 'rewrite', rewrite));
    }
    if (allShards != null) {
      queryParams.addAll(_queryParams('', 'all_shards', allShards));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows a user to validate a potentially expensive query without executing it.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] explain:
  ///   Return detailed information about the error.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcard and prefix queries should be analyzed.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The field to use as default where no field prefix is given in the query string.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [bool] rewrite:
  ///   Provide a more detailed explanation showing the actual Lucene query that will be executed.
  ///
  /// * [bool] allShards:
  ///   Execute validation on all shards instead of one random shard per index.
  Future<void> indicesValidateQueryGetWithIndex(
    String index, {
    bool? explain,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    String? q,
    String? analyzer,
    bool? analyzeWildcard,
    DefaultOperator? defaultOperator,
    String? df,
    bool? lenient,
    bool? rewrite,
    bool? allShards,
  }) async {
    final response = await indicesValidateQueryGetWithIndexWithHttpInfo(
      index,
      explain: explain,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      q: q,
      analyzer: analyzer,
      analyzeWildcard: analyzeWildcard,
      defaultOperator: defaultOperator,
      df: df,
      lenient: lenient,
      rewrite: rewrite,
      allShards: allShards,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows a user to validate a potentially expensive query without executing it.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] explain:
  ///   Return detailed information about the error.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcard and prefix queries should be analyzed.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The field to use as default where no field prefix is given in the query string.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [bool] rewrite:
  ///   Provide a more detailed explanation showing the actual Lucene query that will be executed.
  ///
  /// * [bool] allShards:
  ///   Execute validation on all shards instead of one random shard per index.
  ///
  /// * [Object] body:
  Future<Response> indicesValidateQueryPostWithHttpInfo({
    bool? explain,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    String? q,
    String? analyzer,
    bool? analyzeWildcard,
    DefaultOperator? defaultOperator,
    String? df,
    bool? lenient,
    bool? rewrite,
    bool? allShards,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_validate/query';

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (explain != null) {
      queryParams.addAll(_queryParams('', 'explain', explain));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (q != null) {
      queryParams.addAll(_queryParams('', 'q', q));
    }
    if (analyzer != null) {
      queryParams.addAll(_queryParams('', 'analyzer', analyzer));
    }
    if (analyzeWildcard != null) {
      queryParams.addAll(_queryParams('', 'analyze_wildcard', analyzeWildcard));
    }
    if (defaultOperator != null) {
      queryParams.addAll(_queryParams('', 'default_operator', defaultOperator));
    }
    if (df != null) {
      queryParams.addAll(_queryParams('', 'df', df));
    }
    if (lenient != null) {
      queryParams.addAll(_queryParams('', 'lenient', lenient));
    }
    if (rewrite != null) {
      queryParams.addAll(_queryParams('', 'rewrite', rewrite));
    }
    if (allShards != null) {
      queryParams.addAll(_queryParams('', 'all_shards', allShards));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows a user to validate a potentially expensive query without executing it.
  ///
  /// Parameters:
  ///
  /// * [bool] explain:
  ///   Return detailed information about the error.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcard and prefix queries should be analyzed.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The field to use as default where no field prefix is given in the query string.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [bool] rewrite:
  ///   Provide a more detailed explanation showing the actual Lucene query that will be executed.
  ///
  /// * [bool] allShards:
  ///   Execute validation on all shards instead of one random shard per index.
  ///
  /// * [Object] body:
  Future<void> indicesValidateQueryPost({
    bool? explain,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    String? q,
    String? analyzer,
    bool? analyzeWildcard,
    DefaultOperator? defaultOperator,
    String? df,
    bool? lenient,
    bool? rewrite,
    bool? allShards,
    Object? body,
  }) async {
    final response = await indicesValidateQueryPostWithHttpInfo(
      explain: explain,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      q: q,
      analyzer: analyzer,
      analyzeWildcard: analyzeWildcard,
      defaultOperator: defaultOperator,
      df: df,
      lenient: lenient,
      rewrite: rewrite,
      allShards: allShards,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows a user to validate a potentially expensive query without executing it.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] explain:
  ///   Return detailed information about the error.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcard and prefix queries should be analyzed.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The field to use as default where no field prefix is given in the query string.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [bool] rewrite:
  ///   Provide a more detailed explanation showing the actual Lucene query that will be executed.
  ///
  /// * [bool] allShards:
  ///   Execute validation on all shards instead of one random shard per index.
  ///
  /// * [Object] body:
  Future<Response> indicesValidateQueryPostWithIndexWithHttpInfo(
    String index, {
    bool? explain,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    String? q,
    String? analyzer,
    bool? analyzeWildcard,
    DefaultOperator? defaultOperator,
    String? df,
    bool? lenient,
    bool? rewrite,
    bool? allShards,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_validate/query'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (explain != null) {
      queryParams.addAll(_queryParams('', 'explain', explain));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (q != null) {
      queryParams.addAll(_queryParams('', 'q', q));
    }
    if (analyzer != null) {
      queryParams.addAll(_queryParams('', 'analyzer', analyzer));
    }
    if (analyzeWildcard != null) {
      queryParams.addAll(_queryParams('', 'analyze_wildcard', analyzeWildcard));
    }
    if (defaultOperator != null) {
      queryParams.addAll(_queryParams('', 'default_operator', defaultOperator));
    }
    if (df != null) {
      queryParams.addAll(_queryParams('', 'df', df));
    }
    if (lenient != null) {
      queryParams.addAll(_queryParams('', 'lenient', lenient));
    }
    if (rewrite != null) {
      queryParams.addAll(_queryParams('', 'rewrite', rewrite));
    }
    if (allShards != null) {
      queryParams.addAll(_queryParams('', 'all_shards', allShards));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows a user to validate a potentially expensive query without executing it.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] explain:
  ///   Return detailed information about the error.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcard and prefix queries should be analyzed.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The field to use as default where no field prefix is given in the query string.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [bool] rewrite:
  ///   Provide a more detailed explanation showing the actual Lucene query that will be executed.
  ///
  /// * [bool] allShards:
  ///   Execute validation on all shards instead of one random shard per index.
  ///
  /// * [Object] body:
  Future<void> indicesValidateQueryPostWithIndex(
    String index, {
    bool? explain,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    String? q,
    String? analyzer,
    bool? analyzeWildcard,
    DefaultOperator? defaultOperator,
    String? df,
    bool? lenient,
    bool? rewrite,
    bool? allShards,
    Object? body,
  }) async {
    final response = await indicesValidateQueryPostWithIndexWithHttpInfo(
      index,
      explain: explain,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      q: q,
      analyzer: analyzer,
      analyzeWildcard: analyzeWildcard,
      defaultOperator: defaultOperator,
      df: df,
      lenient: lenient,
      rewrite: rewrite,
      allShards: allShards,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns basic information about the cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  Future<Response> infoWithHttpInfo() async {
    // ignore: prefer_const_declarations
    final path = r'/';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns basic information about the cluster.
  Future<InfoResponseContent?> info() async {
    final response = await infoWithHttpInfo();
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'InfoResponseContent',
      ) as InfoResponseContent;
    }
    return null;
  }

  /// Deletes a pipeline.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Pipeline ID.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<Response> ingestDeletePipelineWithHttpInfo(
    String id, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? timeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_ingest/pipeline/{id}'.replaceAll('{id}', id);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'DELETE',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Deletes a pipeline.
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Pipeline ID.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<void> ingestDeletePipeline(
    String id, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? timeout,
  }) async {
    final response = await ingestDeletePipelineWithHttpInfo(
      id,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      timeout: timeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns a pipeline.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<Response> ingestGetPipelineWithHttpInfo({
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_ingest/pipeline';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns a pipeline.
  ///
  /// Parameters:
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<void> ingestGetPipeline({
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    final response = await ingestGetPipelineWithHttpInfo(
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns a pipeline.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Comma-separated list of pipeline ids. Wildcards supported.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<Response> ingestGetPipelineWithIdWithHttpInfo(
    String id, {
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_ingest/pipeline/{id}'.replaceAll('{id}', id);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns a pipeline.
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Comma-separated list of pipeline ids. Wildcards supported.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<void> ingestGetPipelineWithId(
    String id, {
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    final response = await ingestGetPipelineWithIdWithHttpInfo(
      id,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns a list of the built-in patterns.
  ///
  /// Note: This method returns the HTTP [Response].
  Future<Response> ingestProcessorGrokWithHttpInfo() async {
    // ignore: prefer_const_declarations
    final path = r'/_ingest/processor/grok';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns a list of the built-in patterns.
  Future<void> ingestProcessorGrok() async {
    final response = await ingestProcessorGrokWithHttpInfo();
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Creates or updates a pipeline.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Pipeline ID.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<Response> ingestPutPipelineWithHttpInfo(
    String id,
    Object body, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? timeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_ingest/pipeline/{id}'.replaceAll('{id}', id);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates or updates a pipeline.
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Pipeline ID.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<void> ingestPutPipeline(
    String id,
    Object body, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? timeout,
  }) async {
    final response = await ingestPutPipelineWithHttpInfo(
      id,
      body,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      timeout: timeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to simulate a pipeline with example documents.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] verbose:
  ///   Verbose mode. Display data output for each processor in executed pipeline.
  Future<Response> ingestSimulateGetWithHttpInfo({
    bool? verbose,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_ingest/pipeline/_simulate';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (verbose != null) {
      queryParams.addAll(_queryParams('', 'verbose', verbose));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to simulate a pipeline with example documents.
  ///
  /// Parameters:
  ///
  /// * [bool] verbose:
  ///   Verbose mode. Display data output for each processor in executed pipeline.
  Future<void> ingestSimulateGet({
    bool? verbose,
  }) async {
    final response = await ingestSimulateGetWithHttpInfo(
      verbose: verbose,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to simulate a pipeline with example documents.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Pipeline ID.
  ///
  /// * [bool] verbose:
  ///   Verbose mode. Display data output for each processor in executed pipeline.
  Future<Response> ingestSimulateGetWithIdWithHttpInfo(
    String id, {
    bool? verbose,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_ingest/pipeline/{id}/_simulate'.replaceAll('{id}', id);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (verbose != null) {
      queryParams.addAll(_queryParams('', 'verbose', verbose));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to simulate a pipeline with example documents.
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Pipeline ID.
  ///
  /// * [bool] verbose:
  ///   Verbose mode. Display data output for each processor in executed pipeline.
  Future<void> ingestSimulateGetWithId(
    String id, {
    bool? verbose,
  }) async {
    final response = await ingestSimulateGetWithIdWithHttpInfo(
      id,
      verbose: verbose,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to simulate a pipeline with example documents.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [Object] body (required):
  ///
  /// * [bool] verbose:
  ///   Verbose mode. Display data output for each processor in executed pipeline.
  Future<Response> ingestSimulatePostWithHttpInfo(
    Object body, {
    bool? verbose,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_ingest/pipeline/_simulate';

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (verbose != null) {
      queryParams.addAll(_queryParams('', 'verbose', verbose));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to simulate a pipeline with example documents.
  ///
  /// Parameters:
  ///
  /// * [Object] body (required):
  ///
  /// * [bool] verbose:
  ///   Verbose mode. Display data output for each processor in executed pipeline.
  Future<void> ingestSimulatePost(
    Object body, {
    bool? verbose,
  }) async {
    final response = await ingestSimulatePostWithHttpInfo(
      body,
      verbose: verbose,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to simulate a pipeline with example documents.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Pipeline ID.
  ///
  /// * [Object] body (required):
  ///
  /// * [bool] verbose:
  ///   Verbose mode. Display data output for each processor in executed pipeline.
  Future<Response> ingestSimulatePostWithIdWithHttpInfo(
    String id,
    Object body, {
    bool? verbose,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_ingest/pipeline/{id}/_simulate'.replaceAll('{id}', id);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (verbose != null) {
      queryParams.addAll(_queryParams('', 'verbose', verbose));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to simulate a pipeline with example documents.
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Pipeline ID.
  ///
  /// * [Object] body (required):
  ///
  /// * [bool] verbose:
  ///   Verbose mode. Display data output for each processor in executed pipeline.
  Future<void> ingestSimulatePostWithId(
    String id,
    Object body, {
    bool? verbose,
  }) async {
    final response = await ingestSimulatePostWithIdWithHttpInfo(
      id,
      body,
      verbose: verbose,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to get multiple documents in one request.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [List<String>] storedFields:
  ///   Comma-separated list of stored fields to return.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [bool] realtime:
  ///   Specify whether to perform the operation in realtime or search mode.
  ///
  /// * [bool] refresh:
  ///   Refresh the shard containing the document before performing the operation.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  Future<Response> mgetGetWithHttpInfo({
    List<String>? storedFields,
    String? preference,
    bool? realtime,
    bool? refresh,
    String? routing,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_mget';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (storedFields != null) {
      queryParams.addAll(_queryParams('multi', 'stored_fields', storedFields));
    }
    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (realtime != null) {
      queryParams.addAll(_queryParams('', 'realtime', realtime));
    }
    if (refresh != null) {
      queryParams.addAll(_queryParams('', 'refresh', refresh));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (source_ != null) {
      queryParams.addAll(_queryParams('multi', '_source', source_));
    }
    if (sourceExcludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_excludes', sourceExcludes));
    }
    if (sourceIncludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_includes', sourceIncludes));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to get multiple documents in one request.
  ///
  /// Parameters:
  ///
  /// * [List<String>] storedFields:
  ///   Comma-separated list of stored fields to return.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [bool] realtime:
  ///   Specify whether to perform the operation in realtime or search mode.
  ///
  /// * [bool] refresh:
  ///   Refresh the shard containing the document before performing the operation.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  Future<void> mgetGet({
    List<String>? storedFields,
    String? preference,
    bool? realtime,
    bool? refresh,
    String? routing,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
  }) async {
    final response = await mgetGetWithHttpInfo(
      storedFields: storedFields,
      preference: preference,
      realtime: realtime,
      refresh: refresh,
      routing: routing,
      source_: source_,
      sourceExcludes: sourceExcludes,
      sourceIncludes: sourceIncludes,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to get multiple documents in one request.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [List<String>] storedFields:
  ///   Comma-separated list of stored fields to return.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [bool] realtime:
  ///   Specify whether to perform the operation in realtime or search mode.
  ///
  /// * [bool] refresh:
  ///   Refresh the shard containing the document before performing the operation.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  Future<Response> mgetGetWithIndexWithHttpInfo(
    String index, {
    List<String>? storedFields,
    String? preference,
    bool? realtime,
    bool? refresh,
    String? routing,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_mget'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (storedFields != null) {
      queryParams.addAll(_queryParams('multi', 'stored_fields', storedFields));
    }
    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (realtime != null) {
      queryParams.addAll(_queryParams('', 'realtime', realtime));
    }
    if (refresh != null) {
      queryParams.addAll(_queryParams('', 'refresh', refresh));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (source_ != null) {
      queryParams.addAll(_queryParams('multi', '_source', source_));
    }
    if (sourceExcludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_excludes', sourceExcludes));
    }
    if (sourceIncludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_includes', sourceIncludes));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to get multiple documents in one request.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [List<String>] storedFields:
  ///   Comma-separated list of stored fields to return.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [bool] realtime:
  ///   Specify whether to perform the operation in realtime or search mode.
  ///
  /// * [bool] refresh:
  ///   Refresh the shard containing the document before performing the operation.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  Future<void> mgetGetWithIndex(
    String index, {
    List<String>? storedFields,
    String? preference,
    bool? realtime,
    bool? refresh,
    String? routing,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
  }) async {
    final response = await mgetGetWithIndexWithHttpInfo(
      index,
      storedFields: storedFields,
      preference: preference,
      realtime: realtime,
      refresh: refresh,
      routing: routing,
      source_: source_,
      sourceExcludes: sourceExcludes,
      sourceIncludes: sourceIncludes,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to get multiple documents in one request.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [Object] body (required):
  ///
  /// * [List<String>] storedFields:
  ///   Comma-separated list of stored fields to return.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [bool] realtime:
  ///   Specify whether to perform the operation in realtime or search mode.
  ///
  /// * [bool] refresh:
  ///   Refresh the shard containing the document before performing the operation.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  Future<Response> mgetPostWithHttpInfo(
    Object body, {
    List<String>? storedFields,
    String? preference,
    bool? realtime,
    bool? refresh,
    String? routing,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_mget';

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (storedFields != null) {
      queryParams.addAll(_queryParams('multi', 'stored_fields', storedFields));
    }
    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (realtime != null) {
      queryParams.addAll(_queryParams('', 'realtime', realtime));
    }
    if (refresh != null) {
      queryParams.addAll(_queryParams('', 'refresh', refresh));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (source_ != null) {
      queryParams.addAll(_queryParams('multi', '_source', source_));
    }
    if (sourceExcludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_excludes', sourceExcludes));
    }
    if (sourceIncludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_includes', sourceIncludes));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to get multiple documents in one request.
  ///
  /// Parameters:
  ///
  /// * [Object] body (required):
  ///
  /// * [List<String>] storedFields:
  ///   Comma-separated list of stored fields to return.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [bool] realtime:
  ///   Specify whether to perform the operation in realtime or search mode.
  ///
  /// * [bool] refresh:
  ///   Refresh the shard containing the document before performing the operation.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  Future<void> mgetPost(
    Object body, {
    List<String>? storedFields,
    String? preference,
    bool? realtime,
    bool? refresh,
    String? routing,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
  }) async {
    final response = await mgetPostWithHttpInfo(
      body,
      storedFields: storedFields,
      preference: preference,
      realtime: realtime,
      refresh: refresh,
      routing: routing,
      source_: source_,
      sourceExcludes: sourceExcludes,
      sourceIncludes: sourceIncludes,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to get multiple documents in one request.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [Object] body (required):
  ///
  /// * [List<String>] storedFields:
  ///   Comma-separated list of stored fields to return.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [bool] realtime:
  ///   Specify whether to perform the operation in realtime or search mode.
  ///
  /// * [bool] refresh:
  ///   Refresh the shard containing the document before performing the operation.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  Future<Response> mgetPostWithIndexWithHttpInfo(
    String index,
    Object body, {
    List<String>? storedFields,
    String? preference,
    bool? realtime,
    bool? refresh,
    String? routing,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_mget'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (storedFields != null) {
      queryParams.addAll(_queryParams('multi', 'stored_fields', storedFields));
    }
    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (realtime != null) {
      queryParams.addAll(_queryParams('', 'realtime', realtime));
    }
    if (refresh != null) {
      queryParams.addAll(_queryParams('', 'refresh', refresh));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (source_ != null) {
      queryParams.addAll(_queryParams('multi', '_source', source_));
    }
    if (sourceExcludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_excludes', sourceExcludes));
    }
    if (sourceIncludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_includes', sourceIncludes));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to get multiple documents in one request.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [Object] body (required):
  ///
  /// * [List<String>] storedFields:
  ///   Comma-separated list of stored fields to return.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [bool] realtime:
  ///   Specify whether to perform the operation in realtime or search mode.
  ///
  /// * [bool] refresh:
  ///   Refresh the shard containing the document before performing the operation.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  Future<void> mgetPostWithIndex(
    String index,
    Object body, {
    List<String>? storedFields,
    String? preference,
    bool? realtime,
    bool? refresh,
    String? routing,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
  }) async {
    final response = await mgetPostWithIndexWithHttpInfo(
      index,
      body,
      storedFields: storedFields,
      preference: preference,
      realtime: realtime,
      refresh: refresh,
      routing: routing,
      source_: source_,
      sourceExcludes: sourceExcludes,
      sourceIncludes: sourceIncludes,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to execute several search operations in one request.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [SearchTypeMulti] searchType:
  ///   Search operation type.
  ///
  /// * [int] maxConcurrentSearches:
  ///   Controls the maximum number of concurrent searches the multi search api will execute.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [int] preFilterShardSize:
  ///   Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
  ///
  /// * [int] maxConcurrentShardRequests:
  ///   The number of concurrent shard requests each sub search executes concurrently per node. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  Future<Response> msearchGetWithHttpInfo({
    SearchTypeMulti? searchType,
    int? maxConcurrentSearches,
    bool? typedKeys,
    int? preFilterShardSize,
    int? maxConcurrentShardRequests,
    bool? restTotalHitsAsInt,
    bool? ccsMinimizeRoundtrips,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_msearch';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (searchType != null) {
      queryParams.addAll(_queryParams('', 'search_type', searchType));
    }
    if (maxConcurrentSearches != null) {
      queryParams.addAll(
          _queryParams('', 'max_concurrent_searches', maxConcurrentSearches));
    }
    if (typedKeys != null) {
      queryParams.addAll(_queryParams('', 'typed_keys', typedKeys));
    }
    if (preFilterShardSize != null) {
      queryParams.addAll(
          _queryParams('', 'pre_filter_shard_size', preFilterShardSize));
    }
    if (maxConcurrentShardRequests != null) {
      queryParams.addAll(_queryParams(
          '', 'max_concurrent_shard_requests', maxConcurrentShardRequests));
    }
    if (restTotalHitsAsInt != null) {
      queryParams.addAll(
          _queryParams('', 'rest_total_hits_as_int', restTotalHitsAsInt));
    }
    if (ccsMinimizeRoundtrips != null) {
      queryParams.addAll(
          _queryParams('', 'ccs_minimize_roundtrips', ccsMinimizeRoundtrips));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to execute several search operations in one request.
  ///
  /// Parameters:
  ///
  /// * [SearchTypeMulti] searchType:
  ///   Search operation type.
  ///
  /// * [int] maxConcurrentSearches:
  ///   Controls the maximum number of concurrent searches the multi search api will execute.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [int] preFilterShardSize:
  ///   Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
  ///
  /// * [int] maxConcurrentShardRequests:
  ///   The number of concurrent shard requests each sub search executes concurrently per node. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  Future<void> msearchGet({
    SearchTypeMulti? searchType,
    int? maxConcurrentSearches,
    bool? typedKeys,
    int? preFilterShardSize,
    int? maxConcurrentShardRequests,
    bool? restTotalHitsAsInt,
    bool? ccsMinimizeRoundtrips,
  }) async {
    final response = await msearchGetWithHttpInfo(
      searchType: searchType,
      maxConcurrentSearches: maxConcurrentSearches,
      typedKeys: typedKeys,
      preFilterShardSize: preFilterShardSize,
      maxConcurrentShardRequests: maxConcurrentShardRequests,
      restTotalHitsAsInt: restTotalHitsAsInt,
      ccsMinimizeRoundtrips: ccsMinimizeRoundtrips,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to execute several search operations in one request.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to use as default.
  ///
  /// * [SearchTypeMulti] searchType:
  ///   Search operation type.
  ///
  /// * [int] maxConcurrentSearches:
  ///   Controls the maximum number of concurrent searches the multi search api will execute.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [int] preFilterShardSize:
  ///   Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
  ///
  /// * [int] maxConcurrentShardRequests:
  ///   The number of concurrent shard requests each sub search executes concurrently per node. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  Future<Response> msearchGetWithIndexWithHttpInfo(
    String index, {
    SearchTypeMulti? searchType,
    int? maxConcurrentSearches,
    bool? typedKeys,
    int? preFilterShardSize,
    int? maxConcurrentShardRequests,
    bool? restTotalHitsAsInt,
    bool? ccsMinimizeRoundtrips,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_msearch'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (searchType != null) {
      queryParams.addAll(_queryParams('', 'search_type', searchType));
    }
    if (maxConcurrentSearches != null) {
      queryParams.addAll(
          _queryParams('', 'max_concurrent_searches', maxConcurrentSearches));
    }
    if (typedKeys != null) {
      queryParams.addAll(_queryParams('', 'typed_keys', typedKeys));
    }
    if (preFilterShardSize != null) {
      queryParams.addAll(
          _queryParams('', 'pre_filter_shard_size', preFilterShardSize));
    }
    if (maxConcurrentShardRequests != null) {
      queryParams.addAll(_queryParams(
          '', 'max_concurrent_shard_requests', maxConcurrentShardRequests));
    }
    if (restTotalHitsAsInt != null) {
      queryParams.addAll(
          _queryParams('', 'rest_total_hits_as_int', restTotalHitsAsInt));
    }
    if (ccsMinimizeRoundtrips != null) {
      queryParams.addAll(
          _queryParams('', 'ccs_minimize_roundtrips', ccsMinimizeRoundtrips));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to execute several search operations in one request.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to use as default.
  ///
  /// * [SearchTypeMulti] searchType:
  ///   Search operation type.
  ///
  /// * [int] maxConcurrentSearches:
  ///   Controls the maximum number of concurrent searches the multi search api will execute.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [int] preFilterShardSize:
  ///   Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
  ///
  /// * [int] maxConcurrentShardRequests:
  ///   The number of concurrent shard requests each sub search executes concurrently per node. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  Future<void> msearchGetWithIndex(
    String index, {
    SearchTypeMulti? searchType,
    int? maxConcurrentSearches,
    bool? typedKeys,
    int? preFilterShardSize,
    int? maxConcurrentShardRequests,
    bool? restTotalHitsAsInt,
    bool? ccsMinimizeRoundtrips,
  }) async {
    final response = await msearchGetWithIndexWithHttpInfo(
      index,
      searchType: searchType,
      maxConcurrentSearches: maxConcurrentSearches,
      typedKeys: typedKeys,
      preFilterShardSize: preFilterShardSize,
      maxConcurrentShardRequests: maxConcurrentShardRequests,
      restTotalHitsAsInt: restTotalHitsAsInt,
      ccsMinimizeRoundtrips: ccsMinimizeRoundtrips,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to execute several search operations in one request.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [Object] body (required):
  ///
  /// * [SearchTypeMulti] searchType:
  ///   Search operation type.
  ///
  /// * [int] maxConcurrentSearches:
  ///   Controls the maximum number of concurrent searches the multi search api will execute.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [int] preFilterShardSize:
  ///   Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
  ///
  /// * [int] maxConcurrentShardRequests:
  ///   The number of concurrent shard requests each sub search executes concurrently per node. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  Future<Response> msearchPostWithHttpInfo(
    Object body, {
    SearchTypeMulti? searchType,
    int? maxConcurrentSearches,
    bool? typedKeys,
    int? preFilterShardSize,
    int? maxConcurrentShardRequests,
    bool? restTotalHitsAsInt,
    bool? ccsMinimizeRoundtrips,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_msearch';

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (searchType != null) {
      queryParams.addAll(_queryParams('', 'search_type', searchType));
    }
    if (maxConcurrentSearches != null) {
      queryParams.addAll(
          _queryParams('', 'max_concurrent_searches', maxConcurrentSearches));
    }
    if (typedKeys != null) {
      queryParams.addAll(_queryParams('', 'typed_keys', typedKeys));
    }
    if (preFilterShardSize != null) {
      queryParams.addAll(
          _queryParams('', 'pre_filter_shard_size', preFilterShardSize));
    }
    if (maxConcurrentShardRequests != null) {
      queryParams.addAll(_queryParams(
          '', 'max_concurrent_shard_requests', maxConcurrentShardRequests));
    }
    if (restTotalHitsAsInt != null) {
      queryParams.addAll(
          _queryParams('', 'rest_total_hits_as_int', restTotalHitsAsInt));
    }
    if (ccsMinimizeRoundtrips != null) {
      queryParams.addAll(
          _queryParams('', 'ccs_minimize_roundtrips', ccsMinimizeRoundtrips));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to execute several search operations in one request.
  ///
  /// Parameters:
  ///
  /// * [Object] body (required):
  ///
  /// * [SearchTypeMulti] searchType:
  ///   Search operation type.
  ///
  /// * [int] maxConcurrentSearches:
  ///   Controls the maximum number of concurrent searches the multi search api will execute.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [int] preFilterShardSize:
  ///   Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
  ///
  /// * [int] maxConcurrentShardRequests:
  ///   The number of concurrent shard requests each sub search executes concurrently per node. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  Future<void> msearchPost(
    Object body, {
    SearchTypeMulti? searchType,
    int? maxConcurrentSearches,
    bool? typedKeys,
    int? preFilterShardSize,
    int? maxConcurrentShardRequests,
    bool? restTotalHitsAsInt,
    bool? ccsMinimizeRoundtrips,
  }) async {
    final response = await msearchPostWithHttpInfo(
      body,
      searchType: searchType,
      maxConcurrentSearches: maxConcurrentSearches,
      typedKeys: typedKeys,
      preFilterShardSize: preFilterShardSize,
      maxConcurrentShardRequests: maxConcurrentShardRequests,
      restTotalHitsAsInt: restTotalHitsAsInt,
      ccsMinimizeRoundtrips: ccsMinimizeRoundtrips,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to execute several search operations in one request.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to use as default.
  ///
  /// * [Object] body (required):
  ///
  /// * [SearchTypeMulti] searchType:
  ///   Search operation type.
  ///
  /// * [int] maxConcurrentSearches:
  ///   Controls the maximum number of concurrent searches the multi search api will execute.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [int] preFilterShardSize:
  ///   Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
  ///
  /// * [int] maxConcurrentShardRequests:
  ///   The number of concurrent shard requests each sub search executes concurrently per node. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  Future<Response> msearchPostWithIndexWithHttpInfo(
    String index,
    Object body, {
    SearchTypeMulti? searchType,
    int? maxConcurrentSearches,
    bool? typedKeys,
    int? preFilterShardSize,
    int? maxConcurrentShardRequests,
    bool? restTotalHitsAsInt,
    bool? ccsMinimizeRoundtrips,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_msearch'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (searchType != null) {
      queryParams.addAll(_queryParams('', 'search_type', searchType));
    }
    if (maxConcurrentSearches != null) {
      queryParams.addAll(
          _queryParams('', 'max_concurrent_searches', maxConcurrentSearches));
    }
    if (typedKeys != null) {
      queryParams.addAll(_queryParams('', 'typed_keys', typedKeys));
    }
    if (preFilterShardSize != null) {
      queryParams.addAll(
          _queryParams('', 'pre_filter_shard_size', preFilterShardSize));
    }
    if (maxConcurrentShardRequests != null) {
      queryParams.addAll(_queryParams(
          '', 'max_concurrent_shard_requests', maxConcurrentShardRequests));
    }
    if (restTotalHitsAsInt != null) {
      queryParams.addAll(
          _queryParams('', 'rest_total_hits_as_int', restTotalHitsAsInt));
    }
    if (ccsMinimizeRoundtrips != null) {
      queryParams.addAll(
          _queryParams('', 'ccs_minimize_roundtrips', ccsMinimizeRoundtrips));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to execute several search operations in one request.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to use as default.
  ///
  /// * [Object] body (required):
  ///
  /// * [SearchTypeMulti] searchType:
  ///   Search operation type.
  ///
  /// * [int] maxConcurrentSearches:
  ///   Controls the maximum number of concurrent searches the multi search api will execute.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [int] preFilterShardSize:
  ///   Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
  ///
  /// * [int] maxConcurrentShardRequests:
  ///   The number of concurrent shard requests each sub search executes concurrently per node. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  Future<void> msearchPostWithIndex(
    String index,
    Object body, {
    SearchTypeMulti? searchType,
    int? maxConcurrentSearches,
    bool? typedKeys,
    int? preFilterShardSize,
    int? maxConcurrentShardRequests,
    bool? restTotalHitsAsInt,
    bool? ccsMinimizeRoundtrips,
  }) async {
    final response = await msearchPostWithIndexWithHttpInfo(
      index,
      body,
      searchType: searchType,
      maxConcurrentSearches: maxConcurrentSearches,
      typedKeys: typedKeys,
      preFilterShardSize: preFilterShardSize,
      maxConcurrentShardRequests: maxConcurrentShardRequests,
      restTotalHitsAsInt: restTotalHitsAsInt,
      ccsMinimizeRoundtrips: ccsMinimizeRoundtrips,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to execute several search template operations in one request.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [SearchTypeMulti] searchType:
  ///   Search operation type.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [int] maxConcurrentSearches:
  ///   Controls the maximum number of concurrent searches the multi search api will execute.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  Future<Response> msearchTemplateGetWithHttpInfo({
    SearchTypeMulti? searchType,
    bool? typedKeys,
    int? maxConcurrentSearches,
    bool? restTotalHitsAsInt,
    bool? ccsMinimizeRoundtrips,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_msearch/template';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (searchType != null) {
      queryParams.addAll(_queryParams('', 'search_type', searchType));
    }
    if (typedKeys != null) {
      queryParams.addAll(_queryParams('', 'typed_keys', typedKeys));
    }
    if (maxConcurrentSearches != null) {
      queryParams.addAll(
          _queryParams('', 'max_concurrent_searches', maxConcurrentSearches));
    }
    if (restTotalHitsAsInt != null) {
      queryParams.addAll(
          _queryParams('', 'rest_total_hits_as_int', restTotalHitsAsInt));
    }
    if (ccsMinimizeRoundtrips != null) {
      queryParams.addAll(
          _queryParams('', 'ccs_minimize_roundtrips', ccsMinimizeRoundtrips));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to execute several search template operations in one request.
  ///
  /// Parameters:
  ///
  /// * [SearchTypeMulti] searchType:
  ///   Search operation type.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [int] maxConcurrentSearches:
  ///   Controls the maximum number of concurrent searches the multi search api will execute.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  Future<void> msearchTemplateGet({
    SearchTypeMulti? searchType,
    bool? typedKeys,
    int? maxConcurrentSearches,
    bool? restTotalHitsAsInt,
    bool? ccsMinimizeRoundtrips,
  }) async {
    final response = await msearchTemplateGetWithHttpInfo(
      searchType: searchType,
      typedKeys: typedKeys,
      maxConcurrentSearches: maxConcurrentSearches,
      restTotalHitsAsInt: restTotalHitsAsInt,
      ccsMinimizeRoundtrips: ccsMinimizeRoundtrips,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to execute several search template operations in one request.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to use as default.
  ///
  /// * [SearchTypeMulti] searchType:
  ///   Search operation type.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [int] maxConcurrentSearches:
  ///   Controls the maximum number of concurrent searches the multi search api will execute.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  Future<Response> msearchTemplateGetWithIndexWithHttpInfo(
    String index, {
    SearchTypeMulti? searchType,
    bool? typedKeys,
    int? maxConcurrentSearches,
    bool? restTotalHitsAsInt,
    bool? ccsMinimizeRoundtrips,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_msearch/template'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (searchType != null) {
      queryParams.addAll(_queryParams('', 'search_type', searchType));
    }
    if (typedKeys != null) {
      queryParams.addAll(_queryParams('', 'typed_keys', typedKeys));
    }
    if (maxConcurrentSearches != null) {
      queryParams.addAll(
          _queryParams('', 'max_concurrent_searches', maxConcurrentSearches));
    }
    if (restTotalHitsAsInt != null) {
      queryParams.addAll(
          _queryParams('', 'rest_total_hits_as_int', restTotalHitsAsInt));
    }
    if (ccsMinimizeRoundtrips != null) {
      queryParams.addAll(
          _queryParams('', 'ccs_minimize_roundtrips', ccsMinimizeRoundtrips));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to execute several search template operations in one request.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to use as default.
  ///
  /// * [SearchTypeMulti] searchType:
  ///   Search operation type.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [int] maxConcurrentSearches:
  ///   Controls the maximum number of concurrent searches the multi search api will execute.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  Future<void> msearchTemplateGetWithIndex(
    String index, {
    SearchTypeMulti? searchType,
    bool? typedKeys,
    int? maxConcurrentSearches,
    bool? restTotalHitsAsInt,
    bool? ccsMinimizeRoundtrips,
  }) async {
    final response = await msearchTemplateGetWithIndexWithHttpInfo(
      index,
      searchType: searchType,
      typedKeys: typedKeys,
      maxConcurrentSearches: maxConcurrentSearches,
      restTotalHitsAsInt: restTotalHitsAsInt,
      ccsMinimizeRoundtrips: ccsMinimizeRoundtrips,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to execute several search template operations in one request.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [Object] body (required):
  ///
  /// * [SearchTypeMulti] searchType:
  ///   Search operation type.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [int] maxConcurrentSearches:
  ///   Controls the maximum number of concurrent searches the multi search api will execute.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  Future<Response> msearchTemplatePostWithHttpInfo(
    Object body, {
    SearchTypeMulti? searchType,
    bool? typedKeys,
    int? maxConcurrentSearches,
    bool? restTotalHitsAsInt,
    bool? ccsMinimizeRoundtrips,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_msearch/template';

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (searchType != null) {
      queryParams.addAll(_queryParams('', 'search_type', searchType));
    }
    if (typedKeys != null) {
      queryParams.addAll(_queryParams('', 'typed_keys', typedKeys));
    }
    if (maxConcurrentSearches != null) {
      queryParams.addAll(
          _queryParams('', 'max_concurrent_searches', maxConcurrentSearches));
    }
    if (restTotalHitsAsInt != null) {
      queryParams.addAll(
          _queryParams('', 'rest_total_hits_as_int', restTotalHitsAsInt));
    }
    if (ccsMinimizeRoundtrips != null) {
      queryParams.addAll(
          _queryParams('', 'ccs_minimize_roundtrips', ccsMinimizeRoundtrips));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to execute several search template operations in one request.
  ///
  /// Parameters:
  ///
  /// * [Object] body (required):
  ///
  /// * [SearchTypeMulti] searchType:
  ///   Search operation type.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [int] maxConcurrentSearches:
  ///   Controls the maximum number of concurrent searches the multi search api will execute.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  Future<void> msearchTemplatePost(
    Object body, {
    SearchTypeMulti? searchType,
    bool? typedKeys,
    int? maxConcurrentSearches,
    bool? restTotalHitsAsInt,
    bool? ccsMinimizeRoundtrips,
  }) async {
    final response = await msearchTemplatePostWithHttpInfo(
      body,
      searchType: searchType,
      typedKeys: typedKeys,
      maxConcurrentSearches: maxConcurrentSearches,
      restTotalHitsAsInt: restTotalHitsAsInt,
      ccsMinimizeRoundtrips: ccsMinimizeRoundtrips,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to execute several search template operations in one request.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to use as default.
  ///
  /// * [Object] body (required):
  ///
  /// * [SearchTypeMulti] searchType:
  ///   Search operation type.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [int] maxConcurrentSearches:
  ///   Controls the maximum number of concurrent searches the multi search api will execute.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  Future<Response> msearchTemplatePostWithIndexWithHttpInfo(
    String index,
    Object body, {
    SearchTypeMulti? searchType,
    bool? typedKeys,
    int? maxConcurrentSearches,
    bool? restTotalHitsAsInt,
    bool? ccsMinimizeRoundtrips,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_msearch/template'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (searchType != null) {
      queryParams.addAll(_queryParams('', 'search_type', searchType));
    }
    if (typedKeys != null) {
      queryParams.addAll(_queryParams('', 'typed_keys', typedKeys));
    }
    if (maxConcurrentSearches != null) {
      queryParams.addAll(
          _queryParams('', 'max_concurrent_searches', maxConcurrentSearches));
    }
    if (restTotalHitsAsInt != null) {
      queryParams.addAll(
          _queryParams('', 'rest_total_hits_as_int', restTotalHitsAsInt));
    }
    if (ccsMinimizeRoundtrips != null) {
      queryParams.addAll(
          _queryParams('', 'ccs_minimize_roundtrips', ccsMinimizeRoundtrips));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to execute several search template operations in one request.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices to use as default.
  ///
  /// * [Object] body (required):
  ///
  /// * [SearchTypeMulti] searchType:
  ///   Search operation type.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [int] maxConcurrentSearches:
  ///   Controls the maximum number of concurrent searches the multi search api will execute.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  Future<void> msearchTemplatePostWithIndex(
    String index,
    Object body, {
    SearchTypeMulti? searchType,
    bool? typedKeys,
    int? maxConcurrentSearches,
    bool? restTotalHitsAsInt,
    bool? ccsMinimizeRoundtrips,
  }) async {
    final response = await msearchTemplatePostWithIndexWithHttpInfo(
      index,
      body,
      searchType: searchType,
      typedKeys: typedKeys,
      maxConcurrentSearches: maxConcurrentSearches,
      restTotalHitsAsInt: restTotalHitsAsInt,
      ccsMinimizeRoundtrips: ccsMinimizeRoundtrips,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns multiple termvectors in one request.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [List<String>] ids:
  ///   Comma-separated list of documents ids. You must define ids as parameter or set 'ids' or 'docs' in the request body.
  ///
  /// * [bool] termStatistics:
  ///   Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] fieldStatistics:
  ///   Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] offsets:
  ///   Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] positions:
  ///   Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] payloads:
  ///   Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [String] routing:
  ///   Routing value. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] realtime:
  ///   Specifies if requests are real-time as opposed to near-real-time.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  Future<Response> mtermvectorsGetWithHttpInfo({
    List<String>? ids,
    bool? termStatistics,
    bool? fieldStatistics,
    List<String>? fields,
    bool? offsets,
    bool? positions,
    bool? payloads,
    String? preference,
    String? routing,
    bool? realtime,
    int? version,
    VersionType? versionType,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_mtermvectors';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ids != null) {
      queryParams.addAll(_queryParams('multi', 'ids', ids));
    }
    if (termStatistics != null) {
      queryParams.addAll(_queryParams('', 'term_statistics', termStatistics));
    }
    if (fieldStatistics != null) {
      queryParams.addAll(_queryParams('', 'field_statistics', fieldStatistics));
    }
    if (fields != null) {
      queryParams.addAll(_queryParams('multi', 'fields', fields));
    }
    if (offsets != null) {
      queryParams.addAll(_queryParams('', 'offsets', offsets));
    }
    if (positions != null) {
      queryParams.addAll(_queryParams('', 'positions', positions));
    }
    if (payloads != null) {
      queryParams.addAll(_queryParams('', 'payloads', payloads));
    }
    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (realtime != null) {
      queryParams.addAll(_queryParams('', 'realtime', realtime));
    }
    if (version != null) {
      queryParams.addAll(_queryParams('', 'version', version));
    }
    if (versionType != null) {
      queryParams.addAll(_queryParams('', 'version_type', versionType));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns multiple termvectors in one request.
  ///
  /// Parameters:
  ///
  /// * [List<String>] ids:
  ///   Comma-separated list of documents ids. You must define ids as parameter or set 'ids' or 'docs' in the request body.
  ///
  /// * [bool] termStatistics:
  ///   Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] fieldStatistics:
  ///   Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] offsets:
  ///   Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] positions:
  ///   Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] payloads:
  ///   Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [String] routing:
  ///   Routing value. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] realtime:
  ///   Specifies if requests are real-time as opposed to near-real-time.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  Future<void> mtermvectorsGet({
    List<String>? ids,
    bool? termStatistics,
    bool? fieldStatistics,
    List<String>? fields,
    bool? offsets,
    bool? positions,
    bool? payloads,
    String? preference,
    String? routing,
    bool? realtime,
    int? version,
    VersionType? versionType,
  }) async {
    final response = await mtermvectorsGetWithHttpInfo(
      ids: ids,
      termStatistics: termStatistics,
      fieldStatistics: fieldStatistics,
      fields: fields,
      offsets: offsets,
      positions: positions,
      payloads: payloads,
      preference: preference,
      routing: routing,
      realtime: realtime,
      version: version,
      versionType: versionType,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns multiple termvectors in one request.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   The index in which the document resides.
  ///
  /// * [List<String>] ids:
  ///   Comma-separated list of documents ids. You must define ids as parameter or set 'ids' or 'docs' in the request body.
  ///
  /// * [bool] termStatistics:
  ///   Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] fieldStatistics:
  ///   Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] offsets:
  ///   Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] positions:
  ///   Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] payloads:
  ///   Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [String] routing:
  ///   Routing value. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] realtime:
  ///   Specifies if requests are real-time as opposed to near-real-time.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  Future<Response> mtermvectorsGetWithIndexWithHttpInfo(
    String index, {
    List<String>? ids,
    bool? termStatistics,
    bool? fieldStatistics,
    List<String>? fields,
    bool? offsets,
    bool? positions,
    bool? payloads,
    String? preference,
    String? routing,
    bool? realtime,
    int? version,
    VersionType? versionType,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_mtermvectors'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ids != null) {
      queryParams.addAll(_queryParams('multi', 'ids', ids));
    }
    if (termStatistics != null) {
      queryParams.addAll(_queryParams('', 'term_statistics', termStatistics));
    }
    if (fieldStatistics != null) {
      queryParams.addAll(_queryParams('', 'field_statistics', fieldStatistics));
    }
    if (fields != null) {
      queryParams.addAll(_queryParams('multi', 'fields', fields));
    }
    if (offsets != null) {
      queryParams.addAll(_queryParams('', 'offsets', offsets));
    }
    if (positions != null) {
      queryParams.addAll(_queryParams('', 'positions', positions));
    }
    if (payloads != null) {
      queryParams.addAll(_queryParams('', 'payloads', payloads));
    }
    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (realtime != null) {
      queryParams.addAll(_queryParams('', 'realtime', realtime));
    }
    if (version != null) {
      queryParams.addAll(_queryParams('', 'version', version));
    }
    if (versionType != null) {
      queryParams.addAll(_queryParams('', 'version_type', versionType));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns multiple termvectors in one request.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   The index in which the document resides.
  ///
  /// * [List<String>] ids:
  ///   Comma-separated list of documents ids. You must define ids as parameter or set 'ids' or 'docs' in the request body.
  ///
  /// * [bool] termStatistics:
  ///   Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] fieldStatistics:
  ///   Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] offsets:
  ///   Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] positions:
  ///   Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] payloads:
  ///   Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [String] routing:
  ///   Routing value. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] realtime:
  ///   Specifies if requests are real-time as opposed to near-real-time.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  Future<void> mtermvectorsGetWithIndex(
    String index, {
    List<String>? ids,
    bool? termStatistics,
    bool? fieldStatistics,
    List<String>? fields,
    bool? offsets,
    bool? positions,
    bool? payloads,
    String? preference,
    String? routing,
    bool? realtime,
    int? version,
    VersionType? versionType,
  }) async {
    final response = await mtermvectorsGetWithIndexWithHttpInfo(
      index,
      ids: ids,
      termStatistics: termStatistics,
      fieldStatistics: fieldStatistics,
      fields: fields,
      offsets: offsets,
      positions: positions,
      payloads: payloads,
      preference: preference,
      routing: routing,
      realtime: realtime,
      version: version,
      versionType: versionType,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns multiple termvectors in one request.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [List<String>] ids:
  ///   Comma-separated list of documents ids. You must define ids as parameter or set 'ids' or 'docs' in the request body.
  ///
  /// * [bool] termStatistics:
  ///   Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] fieldStatistics:
  ///   Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] offsets:
  ///   Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] positions:
  ///   Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] payloads:
  ///   Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [String] routing:
  ///   Routing value. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] realtime:
  ///   Specifies if requests are real-time as opposed to near-real-time.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  ///
  /// * [Object] body:
  Future<Response> mtermvectorsPostWithHttpInfo({
    List<String>? ids,
    bool? termStatistics,
    bool? fieldStatistics,
    List<String>? fields,
    bool? offsets,
    bool? positions,
    bool? payloads,
    String? preference,
    String? routing,
    bool? realtime,
    int? version,
    VersionType? versionType,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_mtermvectors';

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ids != null) {
      queryParams.addAll(_queryParams('multi', 'ids', ids));
    }
    if (termStatistics != null) {
      queryParams.addAll(_queryParams('', 'term_statistics', termStatistics));
    }
    if (fieldStatistics != null) {
      queryParams.addAll(_queryParams('', 'field_statistics', fieldStatistics));
    }
    if (fields != null) {
      queryParams.addAll(_queryParams('multi', 'fields', fields));
    }
    if (offsets != null) {
      queryParams.addAll(_queryParams('', 'offsets', offsets));
    }
    if (positions != null) {
      queryParams.addAll(_queryParams('', 'positions', positions));
    }
    if (payloads != null) {
      queryParams.addAll(_queryParams('', 'payloads', payloads));
    }
    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (realtime != null) {
      queryParams.addAll(_queryParams('', 'realtime', realtime));
    }
    if (version != null) {
      queryParams.addAll(_queryParams('', 'version', version));
    }
    if (versionType != null) {
      queryParams.addAll(_queryParams('', 'version_type', versionType));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns multiple termvectors in one request.
  ///
  /// Parameters:
  ///
  /// * [List<String>] ids:
  ///   Comma-separated list of documents ids. You must define ids as parameter or set 'ids' or 'docs' in the request body.
  ///
  /// * [bool] termStatistics:
  ///   Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] fieldStatistics:
  ///   Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] offsets:
  ///   Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] positions:
  ///   Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] payloads:
  ///   Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [String] routing:
  ///   Routing value. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] realtime:
  ///   Specifies if requests are real-time as opposed to near-real-time.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  ///
  /// * [Object] body:
  Future<void> mtermvectorsPost({
    List<String>? ids,
    bool? termStatistics,
    bool? fieldStatistics,
    List<String>? fields,
    bool? offsets,
    bool? positions,
    bool? payloads,
    String? preference,
    String? routing,
    bool? realtime,
    int? version,
    VersionType? versionType,
    Object? body,
  }) async {
    final response = await mtermvectorsPostWithHttpInfo(
      ids: ids,
      termStatistics: termStatistics,
      fieldStatistics: fieldStatistics,
      fields: fields,
      offsets: offsets,
      positions: positions,
      payloads: payloads,
      preference: preference,
      routing: routing,
      realtime: realtime,
      version: version,
      versionType: versionType,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns multiple termvectors in one request.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   The index in which the document resides.
  ///
  /// * [List<String>] ids:
  ///   Comma-separated list of documents ids. You must define ids as parameter or set 'ids' or 'docs' in the request body.
  ///
  /// * [bool] termStatistics:
  ///   Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] fieldStatistics:
  ///   Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] offsets:
  ///   Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] positions:
  ///   Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] payloads:
  ///   Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [String] routing:
  ///   Routing value. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] realtime:
  ///   Specifies if requests are real-time as opposed to near-real-time.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  ///
  /// * [Object] body:
  Future<Response> mtermvectorsPostWithIndexWithHttpInfo(
    String index, {
    List<String>? ids,
    bool? termStatistics,
    bool? fieldStatistics,
    List<String>? fields,
    bool? offsets,
    bool? positions,
    bool? payloads,
    String? preference,
    String? routing,
    bool? realtime,
    int? version,
    VersionType? versionType,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_mtermvectors'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ids != null) {
      queryParams.addAll(_queryParams('multi', 'ids', ids));
    }
    if (termStatistics != null) {
      queryParams.addAll(_queryParams('', 'term_statistics', termStatistics));
    }
    if (fieldStatistics != null) {
      queryParams.addAll(_queryParams('', 'field_statistics', fieldStatistics));
    }
    if (fields != null) {
      queryParams.addAll(_queryParams('multi', 'fields', fields));
    }
    if (offsets != null) {
      queryParams.addAll(_queryParams('', 'offsets', offsets));
    }
    if (positions != null) {
      queryParams.addAll(_queryParams('', 'positions', positions));
    }
    if (payloads != null) {
      queryParams.addAll(_queryParams('', 'payloads', payloads));
    }
    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (realtime != null) {
      queryParams.addAll(_queryParams('', 'realtime', realtime));
    }
    if (version != null) {
      queryParams.addAll(_queryParams('', 'version', version));
    }
    if (versionType != null) {
      queryParams.addAll(_queryParams('', 'version_type', versionType));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns multiple termvectors in one request.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   The index in which the document resides.
  ///
  /// * [List<String>] ids:
  ///   Comma-separated list of documents ids. You must define ids as parameter or set 'ids' or 'docs' in the request body.
  ///
  /// * [bool] termStatistics:
  ///   Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] fieldStatistics:
  ///   Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] offsets:
  ///   Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] positions:
  ///   Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] payloads:
  ///   Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [String] routing:
  ///   Routing value. Applies to all returned documents unless otherwise specified in body 'params' or 'docs'.
  ///
  /// * [bool] realtime:
  ///   Specifies if requests are real-time as opposed to near-real-time.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  ///
  /// * [Object] body:
  Future<void> mtermvectorsPostWithIndex(
    String index, {
    List<String>? ids,
    bool? termStatistics,
    bool? fieldStatistics,
    List<String>? fields,
    bool? offsets,
    bool? positions,
    bool? payloads,
    String? preference,
    String? routing,
    bool? realtime,
    int? version,
    VersionType? versionType,
    Object? body,
  }) async {
    final response = await mtermvectorsPostWithIndexWithHttpInfo(
      index,
      ids: ids,
      termStatistics: termStatistics,
      fieldStatistics: fieldStatistics,
      fields: fields,
      offsets: offsets,
      positions: positions,
      payloads: payloads,
      preference: preference,
      routing: routing,
      realtime: realtime,
      version: version,
      versionType: versionType,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about hot threads on each node in the cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] interval:
  ///   The interval for the second sampling of threads.
  ///
  /// * [int] snapshots:
  ///   Number of samples of thread stacktrace.
  ///
  /// * [int] threads:
  ///   Specify the number of threads to provide information for.
  ///
  /// * [bool] ignoreIdleThreads:
  ///   Don't show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
  ///
  /// * [SampleType] type:
  ///   The type to sample.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<Response> nodesHotThreadsWithHttpInfo({
    String? interval,
    int? snapshots,
    int? threads,
    bool? ignoreIdleThreads,
    SampleType? type,
    String? timeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_nodes/hot_threads';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (interval != null) {
      queryParams.addAll(_queryParams('', 'interval', interval));
    }
    if (snapshots != null) {
      queryParams.addAll(_queryParams('', 'snapshots', snapshots));
    }
    if (threads != null) {
      queryParams.addAll(_queryParams('', 'threads', threads));
    }
    if (ignoreIdleThreads != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_idle_threads', ignoreIdleThreads));
    }
    if (type != null) {
      queryParams.addAll(_queryParams('', 'type', type));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about hot threads on each node in the cluster.
  ///
  /// Parameters:
  ///
  /// * [String] interval:
  ///   The interval for the second sampling of threads.
  ///
  /// * [int] snapshots:
  ///   Number of samples of thread stacktrace.
  ///
  /// * [int] threads:
  ///   Specify the number of threads to provide information for.
  ///
  /// * [bool] ignoreIdleThreads:
  ///   Don't show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
  ///
  /// * [SampleType] type:
  ///   The type to sample.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<void> nodesHotThreads({
    String? interval,
    int? snapshots,
    int? threads,
    bool? ignoreIdleThreads,
    SampleType? type,
    String? timeout,
  }) async {
    final response = await nodesHotThreadsWithHttpInfo(
      interval: interval,
      snapshots: snapshots,
      threads: threads,
      ignoreIdleThreads: ignoreIdleThreads,
      type: type,
      timeout: timeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about hot threads on each node in the cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] interval:
  ///   The interval for the second sampling of threads.
  ///
  /// * [int] snapshots:
  ///   Number of samples of thread stacktrace.
  ///
  /// * [int] threads:
  ///   Specify the number of threads to provide information for.
  ///
  /// * [bool] ignoreIdleThreads:
  ///   Don't show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
  ///
  /// * [SampleType] type:
  ///   The type to sample.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<Response> nodesHotThreadsDeprecatedWithHttpInfo({
    String? interval,
    int? snapshots,
    int? threads,
    bool? ignoreIdleThreads,
    SampleType? type,
    String? timeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_nodes/hotthreads';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (interval != null) {
      queryParams.addAll(_queryParams('', 'interval', interval));
    }
    if (snapshots != null) {
      queryParams.addAll(_queryParams('', 'snapshots', snapshots));
    }
    if (threads != null) {
      queryParams.addAll(_queryParams('', 'threads', threads));
    }
    if (ignoreIdleThreads != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_idle_threads', ignoreIdleThreads));
    }
    if (type != null) {
      queryParams.addAll(_queryParams('', 'type', type));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about hot threads on each node in the cluster.
  ///
  /// Parameters:
  ///
  /// * [String] interval:
  ///   The interval for the second sampling of threads.
  ///
  /// * [int] snapshots:
  ///   Number of samples of thread stacktrace.
  ///
  /// * [int] threads:
  ///   Specify the number of threads to provide information for.
  ///
  /// * [bool] ignoreIdleThreads:
  ///   Don't show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
  ///
  /// * [SampleType] type:
  ///   The type to sample.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<void> nodesHotThreadsDeprecated({
    String? interval,
    int? snapshots,
    int? threads,
    bool? ignoreIdleThreads,
    SampleType? type,
    String? timeout,
  }) async {
    final response = await nodesHotThreadsDeprecatedWithHttpInfo(
      interval: interval,
      snapshots: snapshots,
      threads: threads,
      ignoreIdleThreads: ignoreIdleThreads,
      type: type,
      timeout: timeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about hot threads on each node in the cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] interval:
  ///   The interval for the second sampling of threads.
  ///
  /// * [int] snapshots:
  ///   Number of samples of thread stacktrace.
  ///
  /// * [int] threads:
  ///   Specify the number of threads to provide information for.
  ///
  /// * [bool] ignoreIdleThreads:
  ///   Don't show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
  ///
  /// * [SampleType] type:
  ///   The type to sample.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<Response> nodesHotThreadsDeprecatedClusterWithHttpInfo({
    String? interval,
    int? snapshots,
    int? threads,
    bool? ignoreIdleThreads,
    SampleType? type,
    String? timeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cluster/nodes/hotthreads';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (interval != null) {
      queryParams.addAll(_queryParams('', 'interval', interval));
    }
    if (snapshots != null) {
      queryParams.addAll(_queryParams('', 'snapshots', snapshots));
    }
    if (threads != null) {
      queryParams.addAll(_queryParams('', 'threads', threads));
    }
    if (ignoreIdleThreads != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_idle_threads', ignoreIdleThreads));
    }
    if (type != null) {
      queryParams.addAll(_queryParams('', 'type', type));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about hot threads on each node in the cluster.
  ///
  /// Parameters:
  ///
  /// * [String] interval:
  ///   The interval for the second sampling of threads.
  ///
  /// * [int] snapshots:
  ///   Number of samples of thread stacktrace.
  ///
  /// * [int] threads:
  ///   Specify the number of threads to provide information for.
  ///
  /// * [bool] ignoreIdleThreads:
  ///   Don't show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
  ///
  /// * [SampleType] type:
  ///   The type to sample.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<void> nodesHotThreadsDeprecatedCluster({
    String? interval,
    int? snapshots,
    int? threads,
    bool? ignoreIdleThreads,
    SampleType? type,
    String? timeout,
  }) async {
    final response = await nodesHotThreadsDeprecatedClusterWithHttpInfo(
      interval: interval,
      snapshots: snapshots,
      threads: threads,
      ignoreIdleThreads: ignoreIdleThreads,
      type: type,
      timeout: timeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about hot threads on each node in the cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] interval:
  ///   The interval for the second sampling of threads.
  ///
  /// * [int] snapshots:
  ///   Number of samples of thread stacktrace.
  ///
  /// * [int] threads:
  ///   Specify the number of threads to provide information for.
  ///
  /// * [bool] ignoreIdleThreads:
  ///   Don't show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
  ///
  /// * [SampleType] type:
  ///   The type to sample.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<Response> nodesHotThreadsDeprecatedDashWithHttpInfo({
    String? interval,
    int? snapshots,
    int? threads,
    bool? ignoreIdleThreads,
    SampleType? type,
    String? timeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cluster/nodes/hot_threads';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (interval != null) {
      queryParams.addAll(_queryParams('', 'interval', interval));
    }
    if (snapshots != null) {
      queryParams.addAll(_queryParams('', 'snapshots', snapshots));
    }
    if (threads != null) {
      queryParams.addAll(_queryParams('', 'threads', threads));
    }
    if (ignoreIdleThreads != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_idle_threads', ignoreIdleThreads));
    }
    if (type != null) {
      queryParams.addAll(_queryParams('', 'type', type));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about hot threads on each node in the cluster.
  ///
  /// Parameters:
  ///
  /// * [String] interval:
  ///   The interval for the second sampling of threads.
  ///
  /// * [int] snapshots:
  ///   Number of samples of thread stacktrace.
  ///
  /// * [int] threads:
  ///   Specify the number of threads to provide information for.
  ///
  /// * [bool] ignoreIdleThreads:
  ///   Don't show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
  ///
  /// * [SampleType] type:
  ///   The type to sample.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<void> nodesHotThreadsDeprecatedDash({
    String? interval,
    int? snapshots,
    int? threads,
    bool? ignoreIdleThreads,
    SampleType? type,
    String? timeout,
  }) async {
    final response = await nodesHotThreadsDeprecatedDashWithHttpInfo(
      interval: interval,
      snapshots: snapshots,
      threads: threads,
      ignoreIdleThreads: ignoreIdleThreads,
      type: type,
      timeout: timeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about hot threads on each node in the cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] nodeId (required):
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [String] interval:
  ///   The interval for the second sampling of threads.
  ///
  /// * [int] snapshots:
  ///   Number of samples of thread stacktrace.
  ///
  /// * [int] threads:
  ///   Specify the number of threads to provide information for.
  ///
  /// * [bool] ignoreIdleThreads:
  ///   Don't show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
  ///
  /// * [SampleType] type:
  ///   The type to sample.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<Response> nodesHotThreadsWithNodeIdWithHttpInfo(
    String nodeId, {
    String? interval,
    int? snapshots,
    int? threads,
    bool? ignoreIdleThreads,
    SampleType? type,
    String? timeout,
  }) async {
    // ignore: prefer_const_declarations
    final path =
        r'/_nodes/{node_id}/hot_threads'.replaceAll('{node_id}', nodeId);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (interval != null) {
      queryParams.addAll(_queryParams('', 'interval', interval));
    }
    if (snapshots != null) {
      queryParams.addAll(_queryParams('', 'snapshots', snapshots));
    }
    if (threads != null) {
      queryParams.addAll(_queryParams('', 'threads', threads));
    }
    if (ignoreIdleThreads != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_idle_threads', ignoreIdleThreads));
    }
    if (type != null) {
      queryParams.addAll(_queryParams('', 'type', type));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about hot threads on each node in the cluster.
  ///
  /// Parameters:
  ///
  /// * [String] nodeId (required):
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [String] interval:
  ///   The interval for the second sampling of threads.
  ///
  /// * [int] snapshots:
  ///   Number of samples of thread stacktrace.
  ///
  /// * [int] threads:
  ///   Specify the number of threads to provide information for.
  ///
  /// * [bool] ignoreIdleThreads:
  ///   Don't show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
  ///
  /// * [SampleType] type:
  ///   The type to sample.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<void> nodesHotThreadsWithNodeId(
    String nodeId, {
    String? interval,
    int? snapshots,
    int? threads,
    bool? ignoreIdleThreads,
    SampleType? type,
    String? timeout,
  }) async {
    final response = await nodesHotThreadsWithNodeIdWithHttpInfo(
      nodeId,
      interval: interval,
      snapshots: snapshots,
      threads: threads,
      ignoreIdleThreads: ignoreIdleThreads,
      type: type,
      timeout: timeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about hot threads on each node in the cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] nodeId (required):
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [String] interval:
  ///   The interval for the second sampling of threads.
  ///
  /// * [int] snapshots:
  ///   Number of samples of thread stacktrace.
  ///
  /// * [int] threads:
  ///   Specify the number of threads to provide information for.
  ///
  /// * [bool] ignoreIdleThreads:
  ///   Don't show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
  ///
  /// * [SampleType] type:
  ///   The type to sample.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<Response> nodesHotThreadsWithNodeIdDeprecatedWithHttpInfo(
    String nodeId, {
    String? interval,
    int? snapshots,
    int? threads,
    bool? ignoreIdleThreads,
    SampleType? type,
    String? timeout,
  }) async {
    // ignore: prefer_const_declarations
    final path =
        r'/_nodes/{node_id}/hotthreads'.replaceAll('{node_id}', nodeId);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (interval != null) {
      queryParams.addAll(_queryParams('', 'interval', interval));
    }
    if (snapshots != null) {
      queryParams.addAll(_queryParams('', 'snapshots', snapshots));
    }
    if (threads != null) {
      queryParams.addAll(_queryParams('', 'threads', threads));
    }
    if (ignoreIdleThreads != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_idle_threads', ignoreIdleThreads));
    }
    if (type != null) {
      queryParams.addAll(_queryParams('', 'type', type));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about hot threads on each node in the cluster.
  ///
  /// Parameters:
  ///
  /// * [String] nodeId (required):
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [String] interval:
  ///   The interval for the second sampling of threads.
  ///
  /// * [int] snapshots:
  ///   Number of samples of thread stacktrace.
  ///
  /// * [int] threads:
  ///   Specify the number of threads to provide information for.
  ///
  /// * [bool] ignoreIdleThreads:
  ///   Don't show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
  ///
  /// * [SampleType] type:
  ///   The type to sample.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<void> nodesHotThreadsWithNodeIdDeprecated(
    String nodeId, {
    String? interval,
    int? snapshots,
    int? threads,
    bool? ignoreIdleThreads,
    SampleType? type,
    String? timeout,
  }) async {
    final response = await nodesHotThreadsWithNodeIdDeprecatedWithHttpInfo(
      nodeId,
      interval: interval,
      snapshots: snapshots,
      threads: threads,
      ignoreIdleThreads: ignoreIdleThreads,
      type: type,
      timeout: timeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about hot threads on each node in the cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] nodeId (required):
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [String] interval:
  ///   The interval for the second sampling of threads.
  ///
  /// * [int] snapshots:
  ///   Number of samples of thread stacktrace.
  ///
  /// * [int] threads:
  ///   Specify the number of threads to provide information for.
  ///
  /// * [bool] ignoreIdleThreads:
  ///   Don't show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
  ///
  /// * [SampleType] type:
  ///   The type to sample.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<Response> nodesHotThreadsWithNodeIdDeprecatedClusterWithHttpInfo(
    String nodeId, {
    String? interval,
    int? snapshots,
    int? threads,
    bool? ignoreIdleThreads,
    SampleType? type,
    String? timeout,
  }) async {
    // ignore: prefer_const_declarations
    final path =
        r'/_cluster/nodes/{node_id}/hotthreads'.replaceAll('{node_id}', nodeId);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (interval != null) {
      queryParams.addAll(_queryParams('', 'interval', interval));
    }
    if (snapshots != null) {
      queryParams.addAll(_queryParams('', 'snapshots', snapshots));
    }
    if (threads != null) {
      queryParams.addAll(_queryParams('', 'threads', threads));
    }
    if (ignoreIdleThreads != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_idle_threads', ignoreIdleThreads));
    }
    if (type != null) {
      queryParams.addAll(_queryParams('', 'type', type));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about hot threads on each node in the cluster.
  ///
  /// Parameters:
  ///
  /// * [String] nodeId (required):
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [String] interval:
  ///   The interval for the second sampling of threads.
  ///
  /// * [int] snapshots:
  ///   Number of samples of thread stacktrace.
  ///
  /// * [int] threads:
  ///   Specify the number of threads to provide information for.
  ///
  /// * [bool] ignoreIdleThreads:
  ///   Don't show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
  ///
  /// * [SampleType] type:
  ///   The type to sample.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<void> nodesHotThreadsWithNodeIdDeprecatedCluster(
    String nodeId, {
    String? interval,
    int? snapshots,
    int? threads,
    bool? ignoreIdleThreads,
    SampleType? type,
    String? timeout,
  }) async {
    final response =
        await nodesHotThreadsWithNodeIdDeprecatedClusterWithHttpInfo(
      nodeId,
      interval: interval,
      snapshots: snapshots,
      threads: threads,
      ignoreIdleThreads: ignoreIdleThreads,
      type: type,
      timeout: timeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about hot threads on each node in the cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] nodeId (required):
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [String] interval:
  ///   The interval for the second sampling of threads.
  ///
  /// * [int] snapshots:
  ///   Number of samples of thread stacktrace.
  ///
  /// * [int] threads:
  ///   Specify the number of threads to provide information for.
  ///
  /// * [bool] ignoreIdleThreads:
  ///   Don't show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
  ///
  /// * [SampleType] type:
  ///   The type to sample.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<Response> nodesHotThreadsWithNodeIdDeprecatedDashWithHttpInfo(
    String nodeId, {
    String? interval,
    int? snapshots,
    int? threads,
    bool? ignoreIdleThreads,
    SampleType? type,
    String? timeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_cluster/nodes/{node_id}/hot_threads'
        .replaceAll('{node_id}', nodeId);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (interval != null) {
      queryParams.addAll(_queryParams('', 'interval', interval));
    }
    if (snapshots != null) {
      queryParams.addAll(_queryParams('', 'snapshots', snapshots));
    }
    if (threads != null) {
      queryParams.addAll(_queryParams('', 'threads', threads));
    }
    if (ignoreIdleThreads != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_idle_threads', ignoreIdleThreads));
    }
    if (type != null) {
      queryParams.addAll(_queryParams('', 'type', type));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about hot threads on each node in the cluster.
  ///
  /// Parameters:
  ///
  /// * [String] nodeId (required):
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [String] interval:
  ///   The interval for the second sampling of threads.
  ///
  /// * [int] snapshots:
  ///   Number of samples of thread stacktrace.
  ///
  /// * [int] threads:
  ///   Specify the number of threads to provide information for.
  ///
  /// * [bool] ignoreIdleThreads:
  ///   Don't show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue.
  ///
  /// * [SampleType] type:
  ///   The type to sample.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<void> nodesHotThreadsWithNodeIdDeprecatedDash(
    String nodeId, {
    String? interval,
    int? snapshots,
    int? threads,
    bool? ignoreIdleThreads,
    SampleType? type,
    String? timeout,
  }) async {
    final response = await nodesHotThreadsWithNodeIdDeprecatedDashWithHttpInfo(
      nodeId,
      interval: interval,
      snapshots: snapshots,
      threads: threads,
      ignoreIdleThreads: ignoreIdleThreads,
      type: type,
      timeout: timeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about nodes in the cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<Response> nodesInfoWithHttpInfo({
    bool? flatSettings,
    String? timeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_nodes';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (flatSettings != null) {
      queryParams.addAll(_queryParams('', 'flat_settings', flatSettings));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about nodes in the cluster.
  ///
  /// Parameters:
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<void> nodesInfo({
    bool? flatSettings,
    String? timeout,
  }) async {
    final response = await nodesInfoWithHttpInfo(
      flatSettings: flatSettings,
      timeout: timeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about nodes in the cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] nodeId (required):
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [String] metric (required):
  ///   Comma-separated list of metrics you wish returned. Leave empty to return all.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<Response> nodesInfoWithMetricNodeIdWithHttpInfo(
    String nodeId,
    String metric, {
    bool? flatSettings,
    String? timeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_nodes/{node_id}/{metric}'
        .replaceAll('{node_id}', nodeId)
        .replaceAll('{metric}', metric);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (flatSettings != null) {
      queryParams.addAll(_queryParams('', 'flat_settings', flatSettings));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about nodes in the cluster.
  ///
  /// Parameters:
  ///
  /// * [String] nodeId (required):
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [String] metric (required):
  ///   Comma-separated list of metrics you wish returned. Leave empty to return all.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<void> nodesInfoWithMetricNodeId(
    String nodeId,
    String metric, {
    bool? flatSettings,
    String? timeout,
  }) async {
    final response = await nodesInfoWithMetricNodeIdWithHttpInfo(
      nodeId,
      metric,
      flatSettings: flatSettings,
      timeout: timeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about nodes in the cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] nodeId (required):
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<Response> nodesInfoWithNodeIdWithHttpInfo(
    String nodeId, {
    bool? flatSettings,
    String? timeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_nodes/{node_id}'.replaceAll('{node_id}', nodeId);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (flatSettings != null) {
      queryParams.addAll(_queryParams('', 'flat_settings', flatSettings));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about nodes in the cluster.
  ///
  /// Parameters:
  ///
  /// * [String] nodeId (required):
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [bool] flatSettings:
  ///   Return settings in flat format.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<void> nodesInfoWithNodeId(
    String nodeId, {
    bool? flatSettings,
    String? timeout,
  }) async {
    final response = await nodesInfoWithNodeIdWithHttpInfo(
      nodeId,
      flatSettings: flatSettings,
      timeout: timeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Reloads secure settings.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [Object] body:
  Future<Response> nodesReloadSecureSettingsWithHttpInfo({
    String? timeout,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_nodes/reload_secure_settings';

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Reloads secure settings.
  ///
  /// Parameters:
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [Object] body:
  Future<void> nodesReloadSecureSettings({
    String? timeout,
    Object? body,
  }) async {
    final response = await nodesReloadSecureSettingsWithHttpInfo(
      timeout: timeout,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Reloads secure settings.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] nodeId (required):
  ///   Comma-separated list of node IDs to span the reload/reinit call. Should stay empty because reloading usually involves all cluster nodes.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [Object] body:
  Future<Response> nodesReloadSecureSettingsWithNodeIdWithHttpInfo(
    String nodeId, {
    String? timeout,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_nodes/{node_id}/reload_secure_settings'
        .replaceAll('{node_id}', nodeId);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Reloads secure settings.
  ///
  /// Parameters:
  ///
  /// * [String] nodeId (required):
  ///   Comma-separated list of node IDs to span the reload/reinit call. Should stay empty because reloading usually involves all cluster nodes.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [Object] body:
  Future<void> nodesReloadSecureSettingsWithNodeId(
    String nodeId, {
    String? timeout,
    Object? body,
  }) async {
    final response = await nodesReloadSecureSettingsWithNodeIdWithHttpInfo(
      nodeId,
      timeout: timeout,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns statistical information about nodes in the cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [List<String>] completionFields:
  ///   Comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards).
  ///
  /// * [List<String>] fielddataFields:
  ///   Comma-separated list of fields for `fielddata` index metric (supports wildcards).
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards).
  ///
  /// * [List<String>] groups:
  ///   Comma-separated list of search groups for `search` index metric.
  ///
  /// * [NodesStatLevel] level:
  ///   Return indices stats aggregated at index, node or shard level.
  ///
  /// * [List<String>] types:
  ///   Comma-separated list of document types for the `indexing` index metric.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] includeSegmentFileSizes:
  ///   Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
  Future<Response> nodesStatsWithHttpInfo({
    List<String>? completionFields,
    List<String>? fielddataFields,
    List<String>? fields,
    List<String>? groups,
    NodesStatLevel? level,
    List<String>? types,
    String? timeout,
    bool? includeSegmentFileSizes,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_nodes/stats';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (completionFields != null) {
      queryParams
          .addAll(_queryParams('multi', 'completion_fields', completionFields));
    }
    if (fielddataFields != null) {
      queryParams
          .addAll(_queryParams('multi', 'fielddata_fields', fielddataFields));
    }
    if (fields != null) {
      queryParams.addAll(_queryParams('multi', 'fields', fields));
    }
    if (groups != null) {
      queryParams.addAll(_queryParams('multi', 'groups', groups));
    }
    if (level != null) {
      queryParams.addAll(_queryParams('', 'level', level));
    }
    if (types != null) {
      queryParams.addAll(_queryParams('multi', 'types', types));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (includeSegmentFileSizes != null) {
      queryParams.addAll(_queryParams(
          '', 'include_segment_file_sizes', includeSegmentFileSizes));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns statistical information about nodes in the cluster.
  ///
  /// Parameters:
  ///
  /// * [List<String>] completionFields:
  ///   Comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards).
  ///
  /// * [List<String>] fielddataFields:
  ///   Comma-separated list of fields for `fielddata` index metric (supports wildcards).
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards).
  ///
  /// * [List<String>] groups:
  ///   Comma-separated list of search groups for `search` index metric.
  ///
  /// * [NodesStatLevel] level:
  ///   Return indices stats aggregated at index, node or shard level.
  ///
  /// * [List<String>] types:
  ///   Comma-separated list of document types for the `indexing` index metric.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] includeSegmentFileSizes:
  ///   Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
  Future<void> nodesStats({
    List<String>? completionFields,
    List<String>? fielddataFields,
    List<String>? fields,
    List<String>? groups,
    NodesStatLevel? level,
    List<String>? types,
    String? timeout,
    bool? includeSegmentFileSizes,
  }) async {
    final response = await nodesStatsWithHttpInfo(
      completionFields: completionFields,
      fielddataFields: fielddataFields,
      fields: fields,
      groups: groups,
      level: level,
      types: types,
      timeout: timeout,
      includeSegmentFileSizes: includeSegmentFileSizes,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns statistical information about nodes in the cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] metric (required):
  ///   Limit the information returned to the specified metrics.
  ///
  /// * [String] indexMetric (required):
  ///   Limit the information returned for `indices` metric to the specific index metrics. Isn't used if `indices` (or `all`) metric isn't specified.
  ///
  /// * [List<String>] completionFields:
  ///   Comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards).
  ///
  /// * [List<String>] fielddataFields:
  ///   Comma-separated list of fields for `fielddata` index metric (supports wildcards).
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards).
  ///
  /// * [List<String>] groups:
  ///   Comma-separated list of search groups for `search` index metric.
  ///
  /// * [NodesStatLevel] level:
  ///   Return indices stats aggregated at index, node or shard level.
  ///
  /// * [List<String>] types:
  ///   Comma-separated list of document types for the `indexing` index metric.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] includeSegmentFileSizes:
  ///   Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
  Future<Response> nodesStatsWithIndexMetricMetricWithHttpInfo(
    String metric,
    String indexMetric, {
    List<String>? completionFields,
    List<String>? fielddataFields,
    List<String>? fields,
    List<String>? groups,
    NodesStatLevel? level,
    List<String>? types,
    String? timeout,
    bool? includeSegmentFileSizes,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_nodes/stats/{metric}/{index_metric}'
        .replaceAll('{metric}', metric)
        .replaceAll('{index_metric}', indexMetric);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (completionFields != null) {
      queryParams
          .addAll(_queryParams('multi', 'completion_fields', completionFields));
    }
    if (fielddataFields != null) {
      queryParams
          .addAll(_queryParams('multi', 'fielddata_fields', fielddataFields));
    }
    if (fields != null) {
      queryParams.addAll(_queryParams('multi', 'fields', fields));
    }
    if (groups != null) {
      queryParams.addAll(_queryParams('multi', 'groups', groups));
    }
    if (level != null) {
      queryParams.addAll(_queryParams('', 'level', level));
    }
    if (types != null) {
      queryParams.addAll(_queryParams('multi', 'types', types));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (includeSegmentFileSizes != null) {
      queryParams.addAll(_queryParams(
          '', 'include_segment_file_sizes', includeSegmentFileSizes));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns statistical information about nodes in the cluster.
  ///
  /// Parameters:
  ///
  /// * [String] metric (required):
  ///   Limit the information returned to the specified metrics.
  ///
  /// * [String] indexMetric (required):
  ///   Limit the information returned for `indices` metric to the specific index metrics. Isn't used if `indices` (or `all`) metric isn't specified.
  ///
  /// * [List<String>] completionFields:
  ///   Comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards).
  ///
  /// * [List<String>] fielddataFields:
  ///   Comma-separated list of fields for `fielddata` index metric (supports wildcards).
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards).
  ///
  /// * [List<String>] groups:
  ///   Comma-separated list of search groups for `search` index metric.
  ///
  /// * [NodesStatLevel] level:
  ///   Return indices stats aggregated at index, node or shard level.
  ///
  /// * [List<String>] types:
  ///   Comma-separated list of document types for the `indexing` index metric.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] includeSegmentFileSizes:
  ///   Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
  Future<void> nodesStatsWithIndexMetricMetric(
    String metric,
    String indexMetric, {
    List<String>? completionFields,
    List<String>? fielddataFields,
    List<String>? fields,
    List<String>? groups,
    NodesStatLevel? level,
    List<String>? types,
    String? timeout,
    bool? includeSegmentFileSizes,
  }) async {
    final response = await nodesStatsWithIndexMetricMetricWithHttpInfo(
      metric,
      indexMetric,
      completionFields: completionFields,
      fielddataFields: fielddataFields,
      fields: fields,
      groups: groups,
      level: level,
      types: types,
      timeout: timeout,
      includeSegmentFileSizes: includeSegmentFileSizes,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns statistical information about nodes in the cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] metric (required):
  ///   Limit the information returned to the specified metrics.
  ///
  /// * [String] indexMetric (required):
  ///   Limit the information returned for `indices` metric to the specific index metrics. Isn't used if `indices` (or `all`) metric isn't specified.
  ///
  /// * [String] nodeId (required):
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [List<String>] completionFields:
  ///   Comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards).
  ///
  /// * [List<String>] fielddataFields:
  ///   Comma-separated list of fields for `fielddata` index metric (supports wildcards).
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards).
  ///
  /// * [List<String>] groups:
  ///   Comma-separated list of search groups for `search` index metric.
  ///
  /// * [NodesStatLevel] level:
  ///   Return indices stats aggregated at index, node or shard level.
  ///
  /// * [List<String>] types:
  ///   Comma-separated list of document types for the `indexing` index metric.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] includeSegmentFileSizes:
  ///   Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
  Future<Response> nodesStatsWithIndexMetricMetricNodeIdWithHttpInfo(
    String metric,
    String indexMetric,
    String nodeId, {
    List<String>? completionFields,
    List<String>? fielddataFields,
    List<String>? fields,
    List<String>? groups,
    NodesStatLevel? level,
    List<String>? types,
    String? timeout,
    bool? includeSegmentFileSizes,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_nodes/{node_id}/stats/{metric}/{index_metric}'
        .replaceAll('{metric}', metric)
        .replaceAll('{index_metric}', indexMetric)
        .replaceAll('{node_id}', nodeId);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (completionFields != null) {
      queryParams
          .addAll(_queryParams('multi', 'completion_fields', completionFields));
    }
    if (fielddataFields != null) {
      queryParams
          .addAll(_queryParams('multi', 'fielddata_fields', fielddataFields));
    }
    if (fields != null) {
      queryParams.addAll(_queryParams('multi', 'fields', fields));
    }
    if (groups != null) {
      queryParams.addAll(_queryParams('multi', 'groups', groups));
    }
    if (level != null) {
      queryParams.addAll(_queryParams('', 'level', level));
    }
    if (types != null) {
      queryParams.addAll(_queryParams('multi', 'types', types));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (includeSegmentFileSizes != null) {
      queryParams.addAll(_queryParams(
          '', 'include_segment_file_sizes', includeSegmentFileSizes));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns statistical information about nodes in the cluster.
  ///
  /// Parameters:
  ///
  /// * [String] metric (required):
  ///   Limit the information returned to the specified metrics.
  ///
  /// * [String] indexMetric (required):
  ///   Limit the information returned for `indices` metric to the specific index metrics. Isn't used if `indices` (or `all`) metric isn't specified.
  ///
  /// * [String] nodeId (required):
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [List<String>] completionFields:
  ///   Comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards).
  ///
  /// * [List<String>] fielddataFields:
  ///   Comma-separated list of fields for `fielddata` index metric (supports wildcards).
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards).
  ///
  /// * [List<String>] groups:
  ///   Comma-separated list of search groups for `search` index metric.
  ///
  /// * [NodesStatLevel] level:
  ///   Return indices stats aggregated at index, node or shard level.
  ///
  /// * [List<String>] types:
  ///   Comma-separated list of document types for the `indexing` index metric.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] includeSegmentFileSizes:
  ///   Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
  Future<void> nodesStatsWithIndexMetricMetricNodeId(
    String metric,
    String indexMetric,
    String nodeId, {
    List<String>? completionFields,
    List<String>? fielddataFields,
    List<String>? fields,
    List<String>? groups,
    NodesStatLevel? level,
    List<String>? types,
    String? timeout,
    bool? includeSegmentFileSizes,
  }) async {
    final response = await nodesStatsWithIndexMetricMetricNodeIdWithHttpInfo(
      metric,
      indexMetric,
      nodeId,
      completionFields: completionFields,
      fielddataFields: fielddataFields,
      fields: fields,
      groups: groups,
      level: level,
      types: types,
      timeout: timeout,
      includeSegmentFileSizes: includeSegmentFileSizes,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns statistical information about nodes in the cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] metric (required):
  ///   Limit the information returned to the specified metrics.
  ///
  /// * [List<String>] completionFields:
  ///   Comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards).
  ///
  /// * [List<String>] fielddataFields:
  ///   Comma-separated list of fields for `fielddata` index metric (supports wildcards).
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards).
  ///
  /// * [List<String>] groups:
  ///   Comma-separated list of search groups for `search` index metric.
  ///
  /// * [NodesStatLevel] level:
  ///   Return indices stats aggregated at index, node or shard level.
  ///
  /// * [List<String>] types:
  ///   Comma-separated list of document types for the `indexing` index metric.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] includeSegmentFileSizes:
  ///   Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
  Future<Response> nodesStatsWithMetricWithHttpInfo(
    String metric, {
    List<String>? completionFields,
    List<String>? fielddataFields,
    List<String>? fields,
    List<String>? groups,
    NodesStatLevel? level,
    List<String>? types,
    String? timeout,
    bool? includeSegmentFileSizes,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_nodes/stats/{metric}'.replaceAll('{metric}', metric);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (completionFields != null) {
      queryParams
          .addAll(_queryParams('multi', 'completion_fields', completionFields));
    }
    if (fielddataFields != null) {
      queryParams
          .addAll(_queryParams('multi', 'fielddata_fields', fielddataFields));
    }
    if (fields != null) {
      queryParams.addAll(_queryParams('multi', 'fields', fields));
    }
    if (groups != null) {
      queryParams.addAll(_queryParams('multi', 'groups', groups));
    }
    if (level != null) {
      queryParams.addAll(_queryParams('', 'level', level));
    }
    if (types != null) {
      queryParams.addAll(_queryParams('multi', 'types', types));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (includeSegmentFileSizes != null) {
      queryParams.addAll(_queryParams(
          '', 'include_segment_file_sizes', includeSegmentFileSizes));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns statistical information about nodes in the cluster.
  ///
  /// Parameters:
  ///
  /// * [String] metric (required):
  ///   Limit the information returned to the specified metrics.
  ///
  /// * [List<String>] completionFields:
  ///   Comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards).
  ///
  /// * [List<String>] fielddataFields:
  ///   Comma-separated list of fields for `fielddata` index metric (supports wildcards).
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards).
  ///
  /// * [List<String>] groups:
  ///   Comma-separated list of search groups for `search` index metric.
  ///
  /// * [NodesStatLevel] level:
  ///   Return indices stats aggregated at index, node or shard level.
  ///
  /// * [List<String>] types:
  ///   Comma-separated list of document types for the `indexing` index metric.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] includeSegmentFileSizes:
  ///   Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
  Future<void> nodesStatsWithMetric(
    String metric, {
    List<String>? completionFields,
    List<String>? fielddataFields,
    List<String>? fields,
    List<String>? groups,
    NodesStatLevel? level,
    List<String>? types,
    String? timeout,
    bool? includeSegmentFileSizes,
  }) async {
    final response = await nodesStatsWithMetricWithHttpInfo(
      metric,
      completionFields: completionFields,
      fielddataFields: fielddataFields,
      fields: fields,
      groups: groups,
      level: level,
      types: types,
      timeout: timeout,
      includeSegmentFileSizes: includeSegmentFileSizes,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns statistical information about nodes in the cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] metric (required):
  ///   Limit the information returned to the specified metrics.
  ///
  /// * [String] nodeId (required):
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [List<String>] completionFields:
  ///   Comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards).
  ///
  /// * [List<String>] fielddataFields:
  ///   Comma-separated list of fields for `fielddata` index metric (supports wildcards).
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards).
  ///
  /// * [List<String>] groups:
  ///   Comma-separated list of search groups for `search` index metric.
  ///
  /// * [NodesStatLevel] level:
  ///   Return indices stats aggregated at index, node or shard level.
  ///
  /// * [List<String>] types:
  ///   Comma-separated list of document types for the `indexing` index metric.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] includeSegmentFileSizes:
  ///   Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
  Future<Response> nodesStatsWithMetricNodeIdWithHttpInfo(
    String metric,
    String nodeId, {
    List<String>? completionFields,
    List<String>? fielddataFields,
    List<String>? fields,
    List<String>? groups,
    NodesStatLevel? level,
    List<String>? types,
    String? timeout,
    bool? includeSegmentFileSizes,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_nodes/{node_id}/stats/{metric}'
        .replaceAll('{metric}', metric)
        .replaceAll('{node_id}', nodeId);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (completionFields != null) {
      queryParams
          .addAll(_queryParams('multi', 'completion_fields', completionFields));
    }
    if (fielddataFields != null) {
      queryParams
          .addAll(_queryParams('multi', 'fielddata_fields', fielddataFields));
    }
    if (fields != null) {
      queryParams.addAll(_queryParams('multi', 'fields', fields));
    }
    if (groups != null) {
      queryParams.addAll(_queryParams('multi', 'groups', groups));
    }
    if (level != null) {
      queryParams.addAll(_queryParams('', 'level', level));
    }
    if (types != null) {
      queryParams.addAll(_queryParams('multi', 'types', types));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (includeSegmentFileSizes != null) {
      queryParams.addAll(_queryParams(
          '', 'include_segment_file_sizes', includeSegmentFileSizes));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns statistical information about nodes in the cluster.
  ///
  /// Parameters:
  ///
  /// * [String] metric (required):
  ///   Limit the information returned to the specified metrics.
  ///
  /// * [String] nodeId (required):
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [List<String>] completionFields:
  ///   Comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards).
  ///
  /// * [List<String>] fielddataFields:
  ///   Comma-separated list of fields for `fielddata` index metric (supports wildcards).
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards).
  ///
  /// * [List<String>] groups:
  ///   Comma-separated list of search groups for `search` index metric.
  ///
  /// * [NodesStatLevel] level:
  ///   Return indices stats aggregated at index, node or shard level.
  ///
  /// * [List<String>] types:
  ///   Comma-separated list of document types for the `indexing` index metric.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] includeSegmentFileSizes:
  ///   Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
  Future<void> nodesStatsWithMetricNodeId(
    String metric,
    String nodeId, {
    List<String>? completionFields,
    List<String>? fielddataFields,
    List<String>? fields,
    List<String>? groups,
    NodesStatLevel? level,
    List<String>? types,
    String? timeout,
    bool? includeSegmentFileSizes,
  }) async {
    final response = await nodesStatsWithMetricNodeIdWithHttpInfo(
      metric,
      nodeId,
      completionFields: completionFields,
      fielddataFields: fielddataFields,
      fields: fields,
      groups: groups,
      level: level,
      types: types,
      timeout: timeout,
      includeSegmentFileSizes: includeSegmentFileSizes,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns statistical information about nodes in the cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] nodeId (required):
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [List<String>] completionFields:
  ///   Comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards).
  ///
  /// * [List<String>] fielddataFields:
  ///   Comma-separated list of fields for `fielddata` index metric (supports wildcards).
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards).
  ///
  /// * [List<String>] groups:
  ///   Comma-separated list of search groups for `search` index metric.
  ///
  /// * [NodesStatLevel] level:
  ///   Return indices stats aggregated at index, node or shard level.
  ///
  /// * [List<String>] types:
  ///   Comma-separated list of document types for the `indexing` index metric.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] includeSegmentFileSizes:
  ///   Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
  Future<Response> nodesStatsWithNodeIdWithHttpInfo(
    String nodeId, {
    List<String>? completionFields,
    List<String>? fielddataFields,
    List<String>? fields,
    List<String>? groups,
    NodesStatLevel? level,
    List<String>? types,
    String? timeout,
    bool? includeSegmentFileSizes,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_nodes/{node_id}/stats'.replaceAll('{node_id}', nodeId);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (completionFields != null) {
      queryParams
          .addAll(_queryParams('multi', 'completion_fields', completionFields));
    }
    if (fielddataFields != null) {
      queryParams
          .addAll(_queryParams('multi', 'fielddata_fields', fielddataFields));
    }
    if (fields != null) {
      queryParams.addAll(_queryParams('multi', 'fields', fields));
    }
    if (groups != null) {
      queryParams.addAll(_queryParams('multi', 'groups', groups));
    }
    if (level != null) {
      queryParams.addAll(_queryParams('', 'level', level));
    }
    if (types != null) {
      queryParams.addAll(_queryParams('multi', 'types', types));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (includeSegmentFileSizes != null) {
      queryParams.addAll(_queryParams(
          '', 'include_segment_file_sizes', includeSegmentFileSizes));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns statistical information about nodes in the cluster.
  ///
  /// Parameters:
  ///
  /// * [String] nodeId (required):
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [List<String>] completionFields:
  ///   Comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards).
  ///
  /// * [List<String>] fielddataFields:
  ///   Comma-separated list of fields for `fielddata` index metric (supports wildcards).
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards).
  ///
  /// * [List<String>] groups:
  ///   Comma-separated list of search groups for `search` index metric.
  ///
  /// * [NodesStatLevel] level:
  ///   Return indices stats aggregated at index, node or shard level.
  ///
  /// * [List<String>] types:
  ///   Comma-separated list of document types for the `indexing` index metric.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] includeSegmentFileSizes:
  ///   Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).
  Future<void> nodesStatsWithNodeId(
    String nodeId, {
    List<String>? completionFields,
    List<String>? fielddataFields,
    List<String>? fields,
    List<String>? groups,
    NodesStatLevel? level,
    List<String>? types,
    String? timeout,
    bool? includeSegmentFileSizes,
  }) async {
    final response = await nodesStatsWithNodeIdWithHttpInfo(
      nodeId,
      completionFields: completionFields,
      fielddataFields: fielddataFields,
      fields: fields,
      groups: groups,
      level: level,
      types: types,
      timeout: timeout,
      includeSegmentFileSizes: includeSegmentFileSizes,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns low-level information about REST actions usage on nodes.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<Response> nodesUsageWithHttpInfo({
    String? timeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_nodes/usage';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns low-level information about REST actions usage on nodes.
  ///
  /// Parameters:
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<void> nodesUsage({
    String? timeout,
  }) async {
    final response = await nodesUsageWithHttpInfo(
      timeout: timeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns low-level information about REST actions usage on nodes.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] metric (required):
  ///   Limit the information returned to the specified metrics.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<Response> nodesUsageWithMetricWithHttpInfo(
    String metric, {
    String? timeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_nodes/usage/{metric}'.replaceAll('{metric}', metric);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns low-level information about REST actions usage on nodes.
  ///
  /// Parameters:
  ///
  /// * [String] metric (required):
  ///   Limit the information returned to the specified metrics.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<void> nodesUsageWithMetric(
    String metric, {
    String? timeout,
  }) async {
    final response = await nodesUsageWithMetricWithHttpInfo(
      metric,
      timeout: timeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns low-level information about REST actions usage on nodes.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] metric (required):
  ///   Limit the information returned to the specified metrics.
  ///
  /// * [String] nodeId (required):
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<Response> nodesUsageWithMetricNodeIdWithHttpInfo(
    String metric,
    String nodeId, {
    String? timeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_nodes/{node_id}/usage/{metric}'
        .replaceAll('{metric}', metric)
        .replaceAll('{node_id}', nodeId);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns low-level information about REST actions usage on nodes.
  ///
  /// Parameters:
  ///
  /// * [String] metric (required):
  ///   Limit the information returned to the specified metrics.
  ///
  /// * [String] nodeId (required):
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<void> nodesUsageWithMetricNodeId(
    String metric,
    String nodeId, {
    String? timeout,
  }) async {
    final response = await nodesUsageWithMetricNodeIdWithHttpInfo(
      metric,
      nodeId,
      timeout: timeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns low-level information about REST actions usage on nodes.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] nodeId (required):
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<Response> nodesUsageWithNodeIdWithHttpInfo(
    String nodeId, {
    String? timeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_nodes/{node_id}/usage'.replaceAll('{node_id}', nodeId);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns low-level information about REST actions usage on nodes.
  ///
  /// Parameters:
  ///
  /// * [String] nodeId (required):
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<void> nodesUsageWithNodeId(
    String nodeId, {
    String? timeout,
  }) async {
    final response = await nodesUsageWithNodeIdWithHttpInfo(
      nodeId,
      timeout: timeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Updates individual attributes of an action group.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] actionGroup (required):
  ///
  /// * [List<PatchOperation>] patchOperation (required):
  Future<Response> patchActionGroupWithHttpInfo(
    String actionGroup,
    List<PatchOperation> patchOperation,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/actiongroups/{action_group}'
        .replaceAll('{action_group}', actionGroup);

    // ignore: prefer_final_locals
    Object? postBody = patchOperation;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PATCH',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Updates individual attributes of an action group.
  ///
  /// Parameters:
  ///
  /// * [String] actionGroup (required):
  ///
  /// * [List<PatchOperation>] patchOperation (required):
  Future<PatchActionGroupResponseContent?> patchActionGroup(
    String actionGroup,
    List<PatchOperation> patchOperation,
  ) async {
    final response = await patchActionGroupWithHttpInfo(
      actionGroup,
      patchOperation,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'PatchActionGroupResponseContent',
      ) as PatchActionGroupResponseContent;
    }
    return null;
  }

  /// Creates, updates, or deletes multiple action groups in a single call.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [List<PatchOperation>] patchOperation (required):
  Future<Response> patchActionGroupsWithHttpInfo(
    List<PatchOperation> patchOperation,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/actiongroups';

    // ignore: prefer_final_locals
    Object? postBody = patchOperation;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PATCH',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates, updates, or deletes multiple action groups in a single call.
  ///
  /// Parameters:
  ///
  /// * [List<PatchOperation>] patchOperation (required):
  Future<PatchActionGroupsResponseContent?> patchActionGroups(
    List<PatchOperation> patchOperation,
  ) async {
    final response = await patchActionGroupsWithHttpInfo(
      patchOperation,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'PatchActionGroupsResponseContent',
      ) as PatchActionGroupsResponseContent;
    }
    return null;
  }

  /// A PATCH call is used to update specified fields in the audit configuration.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [List<PatchOperation>] patchOperation (required):
  Future<Response> patchAuditConfigurationWithHttpInfo(
    List<PatchOperation> patchOperation,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/audit';

    // ignore: prefer_final_locals
    Object? postBody = patchOperation;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PATCH',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// A PATCH call is used to update specified fields in the audit configuration.
  ///
  /// Parameters:
  ///
  /// * [List<PatchOperation>] patchOperation (required):
  Future<void> patchAuditConfiguration(
    List<PatchOperation> patchOperation,
  ) async {
    final response = await patchAuditConfigurationWithHttpInfo(
      patchOperation,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// A PATCH call is used to update the existing configuration using the REST API.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [List<PatchOperation>] patchOperation (required):
  Future<Response> patchConfigurationWithHttpInfo(
    List<PatchOperation> patchOperation,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/securityconfig';

    // ignore: prefer_final_locals
    Object? postBody = patchOperation;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PATCH',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// A PATCH call is used to update the existing configuration using the REST API.
  ///
  /// Parameters:
  ///
  /// * [List<PatchOperation>] patchOperation (required):
  Future<PatchConfigurationResponseContent?> patchConfiguration(
    List<PatchOperation> patchOperation,
  ) async {
    final response = await patchConfigurationWithHttpInfo(
      patchOperation,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'PatchConfigurationResponseContent',
      ) as PatchConfigurationResponseContent;
    }
    return null;
  }

  /// Bulk update of distinguished names.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [List<PatchOperation>] patchOperation (required):
  Future<Response> patchDistinguishedNamesWithHttpInfo(
    List<PatchOperation> patchOperation,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/nodesdn';

    // ignore: prefer_final_locals
    Object? postBody = patchOperation;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PATCH',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Bulk update of distinguished names.
  ///
  /// Parameters:
  ///
  /// * [List<PatchOperation>] patchOperation (required):
  Future<PatchDistinguishedNamesResponseContent?> patchDistinguishedNames(
    List<PatchOperation> patchOperation,
  ) async {
    final response = await patchDistinguishedNamesWithHttpInfo(
      patchOperation,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'PatchDistinguishedNamesResponseContent',
      ) as PatchDistinguishedNamesResponseContent;
    }
    return null;
  }

  /// Updates individual attributes of a role.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] role (required):
  ///
  /// * [List<PatchOperation>] patchOperation (required):
  Future<Response> patchRoleWithHttpInfo(
    String role,
    List<PatchOperation> patchOperation,
  ) async {
    // ignore: prefer_const_declarations
    final path =
        r'/_plugins/_security/api/roles/{role}'.replaceAll('{role}', role);

    // ignore: prefer_final_locals
    Object? postBody = patchOperation;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PATCH',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Updates individual attributes of a role.
  ///
  /// Parameters:
  ///
  /// * [String] role (required):
  ///
  /// * [List<PatchOperation>] patchOperation (required):
  Future<PatchRoleResponseContent?> patchRole(
    String role,
    List<PatchOperation> patchOperation,
  ) async {
    final response = await patchRoleWithHttpInfo(
      role,
      patchOperation,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'PatchRoleResponseContent',
      ) as PatchRoleResponseContent;
    }
    return null;
  }

  /// Updates individual attributes of a role mapping.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] role (required):
  ///
  /// * [List<PatchOperation>] patchOperation (required):
  Future<Response> patchRoleMappingWithHttpInfo(
    String role,
    List<PatchOperation> patchOperation,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/rolesmapping/{role}'
        .replaceAll('{role}', role);

    // ignore: prefer_final_locals
    Object? postBody = patchOperation;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PATCH',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Updates individual attributes of a role mapping.
  ///
  /// Parameters:
  ///
  /// * [String] role (required):
  ///
  /// * [List<PatchOperation>] patchOperation (required):
  Future<PatchRoleMappingResponseContent?> patchRoleMapping(
    String role,
    List<PatchOperation> patchOperation,
  ) async {
    final response = await patchRoleMappingWithHttpInfo(
      role,
      patchOperation,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'PatchRoleMappingResponseContent',
      ) as PatchRoleMappingResponseContent;
    }
    return null;
  }

  /// Creates or updates multiple role mappings in a single call.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [List<PatchOperation>] patchOperation (required):
  Future<Response> patchRoleMappingsWithHttpInfo(
    List<PatchOperation> patchOperation,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/rolesmapping';

    // ignore: prefer_final_locals
    Object? postBody = patchOperation;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PATCH',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates or updates multiple role mappings in a single call.
  ///
  /// Parameters:
  ///
  /// * [List<PatchOperation>] patchOperation (required):
  Future<PatchRoleMappingsResponseContent?> patchRoleMappings(
    List<PatchOperation> patchOperation,
  ) async {
    final response = await patchRoleMappingsWithHttpInfo(
      patchOperation,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'PatchRoleMappingsResponseContent',
      ) as PatchRoleMappingsResponseContent;
    }
    return null;
  }

  /// Creates, updates, or deletes multiple roles in a single call.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [List<PatchOperation>] patchOperation (required):
  Future<Response> patchRolesWithHttpInfo(
    List<PatchOperation> patchOperation,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/roles';

    // ignore: prefer_final_locals
    Object? postBody = patchOperation;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PATCH',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates, updates, or deletes multiple roles in a single call.
  ///
  /// Parameters:
  ///
  /// * [List<PatchOperation>] patchOperation (required):
  Future<PatchRolesResponseContent?> patchRoles(
    List<PatchOperation> patchOperation,
  ) async {
    final response = await patchRolesWithHttpInfo(
      patchOperation,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'PatchRolesResponseContent',
      ) as PatchRolesResponseContent;
    }
    return null;
  }

  /// Add, delete, or modify a single tenant.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] tenant (required):
  ///
  /// * [List<PatchOperation>] patchOperation (required):
  Future<Response> patchTenantWithHttpInfo(
    String tenant,
    List<PatchOperation> patchOperation,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/tenants/{tenant}'
        .replaceAll('{tenant}', tenant);

    // ignore: prefer_final_locals
    Object? postBody = patchOperation;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PATCH',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Add, delete, or modify a single tenant.
  ///
  /// Parameters:
  ///
  /// * [String] tenant (required):
  ///
  /// * [List<PatchOperation>] patchOperation (required):
  Future<PatchTenantResponseContent?> patchTenant(
    String tenant,
    List<PatchOperation> patchOperation,
  ) async {
    final response = await patchTenantWithHttpInfo(
      tenant,
      patchOperation,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'PatchTenantResponseContent',
      ) as PatchTenantResponseContent;
    }
    return null;
  }

  /// Add, delete, or modify multiple tenants in a single call.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [List<PatchOperation>] patchOperation (required):
  Future<Response> patchTenantsWithHttpInfo(
    List<PatchOperation> patchOperation,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/tenants/';

    // ignore: prefer_final_locals
    Object? postBody = patchOperation;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PATCH',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Add, delete, or modify multiple tenants in a single call.
  ///
  /// Parameters:
  ///
  /// * [List<PatchOperation>] patchOperation (required):
  Future<PatchTenantsResponseContent?> patchTenants(
    List<PatchOperation> patchOperation,
  ) async {
    final response = await patchTenantsWithHttpInfo(
      patchOperation,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'PatchTenantsResponseContent',
      ) as PatchTenantsResponseContent;
    }
    return null;
  }

  /// Updates individual attributes of an internal user.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] username (required):
  ///
  /// * [List<PatchOperation>] patchOperation (required):
  Future<Response> patchUserWithHttpInfo(
    String username,
    List<PatchOperation> patchOperation,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/internalusers/{username}'
        .replaceAll('{username}', username);

    // ignore: prefer_final_locals
    Object? postBody = patchOperation;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PATCH',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Updates individual attributes of an internal user.
  ///
  /// Parameters:
  ///
  /// * [String] username (required):
  ///
  /// * [List<PatchOperation>] patchOperation (required):
  Future<PatchUserResponseContent?> patchUser(
    String username,
    List<PatchOperation> patchOperation,
  ) async {
    final response = await patchUserWithHttpInfo(
      username,
      patchOperation,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'PatchUserResponseContent',
      ) as PatchUserResponseContent;
    }
    return null;
  }

  /// Creates, updates, or deletes multiple internal users in a single call.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [List<PatchOperation>] patchOperation (required):
  Future<Response> patchUsersWithHttpInfo(
    List<PatchOperation> patchOperation,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/internalusers';

    // ignore: prefer_final_locals
    Object? postBody = patchOperation;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PATCH',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates, updates, or deletes multiple internal users in a single call.
  ///
  /// Parameters:
  ///
  /// * [List<PatchOperation>] patchOperation (required):
  Future<PatchUsersResponseContent?> patchUsers(
    List<PatchOperation> patchOperation,
  ) async {
    final response = await patchUsersWithHttpInfo(
      patchOperation,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'PatchUsersResponseContent',
      ) as PatchUsersResponseContent;
    }
    return null;
  }

  /// Returns whether the cluster is running.
  ///
  /// Note: This method returns the HTTP [Response].
  Future<Response> pingWithHttpInfo() async {
    // ignore: prefer_const_declarations
    final path = r'/';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'HEAD',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns whether the cluster is running.
  Future<void> ping() async {
    final response = await pingWithHttpInfo();
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Creates or updates a script.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Script ID.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<Response> putScriptPostWithHttpInfo(
    String id,
    Object body, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_scripts/{id}'.replaceAll('{id}', id);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates or updates a script.
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Script ID.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<void> putScriptPost(
    String id,
    Object body, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    final response = await putScriptPostWithHttpInfo(
      id,
      body,
      timeout: timeout,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Creates or updates a script.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Script ID.
  ///
  /// * [String] context (required):
  ///   Script context.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<Response> putScriptPostWithContextWithHttpInfo(
    String id,
    String context,
    Object body, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_scripts/{id}/{context}'
        .replaceAll('{id}', id)
        .replaceAll('{context}', context);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates or updates a script.
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Script ID.
  ///
  /// * [String] context (required):
  ///   Script context.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<void> putScriptPostWithContext(
    String id,
    String context,
    Object body, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    final response = await putScriptPostWithContextWithHttpInfo(
      id,
      context,
      body,
      timeout: timeout,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Creates or updates a script.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Script ID.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<Response> putScriptPutWithHttpInfo(
    String id,
    Object body, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_scripts/{id}'.replaceAll('{id}', id);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates or updates a script.
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Script ID.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<void> putScriptPut(
    String id,
    Object body, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    final response = await putScriptPutWithHttpInfo(
      id,
      body,
      timeout: timeout,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Creates or updates a script.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Script ID.
  ///
  /// * [String] context (required):
  ///   Script context.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<Response> putScriptPutWithContextWithHttpInfo(
    String id,
    String context,
    Object body, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_scripts/{id}/{context}'
        .replaceAll('{id}', id)
        .replaceAll('{context}', context);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates or updates a script.
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Script ID.
  ///
  /// * [String] context (required):
  ///   Script context.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<void> putScriptPutWithContext(
    String id,
    String context,
    Object body, {
    String? timeout,
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    final response = await putScriptPutWithContextWithHttpInfo(
      id,
      context,
      body,
      timeout: timeout,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to evaluate the quality of ranked search results over a set of typical search queries.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [SearchType] searchType:
  ///   Search operation type.
  Future<Response> rankEvalGetWithHttpInfo({
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    SearchType? searchType,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_rank_eval';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (searchType != null) {
      queryParams.addAll(_queryParams('', 'search_type', searchType));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to evaluate the quality of ranked search results over a set of typical search queries.
  ///
  /// Parameters:
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [SearchType] searchType:
  ///   Search operation type.
  Future<void> rankEvalGet({
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    SearchType? searchType,
  }) async {
    final response = await rankEvalGetWithHttpInfo(
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      searchType: searchType,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to evaluate the quality of ranked search results over a set of typical search queries.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [SearchType] searchType:
  ///   Search operation type.
  Future<Response> rankEvalGetWithIndexWithHttpInfo(
    String index, {
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    SearchType? searchType,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_rank_eval'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (searchType != null) {
      queryParams.addAll(_queryParams('', 'search_type', searchType));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to evaluate the quality of ranked search results over a set of typical search queries.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [SearchType] searchType:
  ///   Search operation type.
  Future<void> rankEvalGetWithIndex(
    String index, {
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    SearchType? searchType,
  }) async {
    final response = await rankEvalGetWithIndexWithHttpInfo(
      index,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      searchType: searchType,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to evaluate the quality of ranked search results over a set of typical search queries.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [Object] body (required):
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [SearchType] searchType:
  ///   Search operation type.
  Future<Response> rankEvalPostWithHttpInfo(
    Object body, {
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    SearchType? searchType,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_rank_eval';

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (searchType != null) {
      queryParams.addAll(_queryParams('', 'search_type', searchType));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to evaluate the quality of ranked search results over a set of typical search queries.
  ///
  /// Parameters:
  ///
  /// * [Object] body (required):
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [SearchType] searchType:
  ///   Search operation type.
  Future<void> rankEvalPost(
    Object body, {
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    SearchType? searchType,
  }) async {
    final response = await rankEvalPostWithHttpInfo(
      body,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      searchType: searchType,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to evaluate the quality of ranked search results over a set of typical search queries.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [Object] body (required):
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [SearchType] searchType:
  ///   Search operation type.
  Future<Response> rankEvalPostWithIndexWithHttpInfo(
    String index,
    Object body, {
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    SearchType? searchType,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_rank_eval'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (searchType != null) {
      queryParams.addAll(_queryParams('', 'search_type', searchType));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to evaluate the quality of ranked search results over a set of typical search queries.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [Object] body (required):
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [SearchType] searchType:
  ///   Search operation type.
  Future<void> rankEvalPostWithIndex(
    String index,
    Object body, {
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    SearchType? searchType,
  }) async {
    final response = await rankEvalPostWithIndexWithHttpInfo(
      index,
      body,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      searchType: searchType,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to copy documents from one index to another, optionally filtering the source documents by a query, changing the destination index settings, or fetching the documents from a remote cluster.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [Object] body (required):
  ///
  /// * [bool] refresh:
  ///   Should the affected indexes be refreshed?.
  ///
  /// * [String] timeout:
  ///   Time each individual bulk request should wait for shards that are unavailable.
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
  ///
  /// * [bool] waitForCompletion:
  ///   Should this request wait until the operation has completed before returning.
  ///
  /// * [int] requestsPerSecond:
  ///   The throttle for this request in sub-requests per second. -1 means no throttle.
  ///
  /// * [String] scroll:
  ///   Specify how long a consistent view of the index should be maintained for scrolled search.
  ///
  /// * [String] slices:
  ///   The number of slices this task should be divided into. Defaults to 1, meaning the task isn't sliced into subtasks. Can be set to `auto`.
  ///
  /// * [int] maxDocs:
  ///   Maximum number of documents to process (default: all documents).
  Future<Response> reindexWithHttpInfo(
    Object body, {
    bool? refresh,
    String? timeout,
    String? waitForActiveShards,
    bool? waitForCompletion,
    int? requestsPerSecond,
    String? scroll,
    String? slices,
    int? maxDocs,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_reindex';

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (refresh != null) {
      queryParams.addAll(_queryParams('', 'refresh', refresh));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (waitForActiveShards != null) {
      queryParams.addAll(
          _queryParams('', 'wait_for_active_shards', waitForActiveShards));
    }
    if (waitForCompletion != null) {
      queryParams
          .addAll(_queryParams('', 'wait_for_completion', waitForCompletion));
    }
    if (requestsPerSecond != null) {
      queryParams
          .addAll(_queryParams('', 'requests_per_second', requestsPerSecond));
    }
    if (scroll != null) {
      queryParams.addAll(_queryParams('', 'scroll', scroll));
    }
    if (slices != null) {
      queryParams.addAll(_queryParams('', 'slices', slices));
    }
    if (maxDocs != null) {
      queryParams.addAll(_queryParams('', 'max_docs', maxDocs));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to copy documents from one index to another, optionally filtering the source documents by a query, changing the destination index settings, or fetching the documents from a remote cluster.
  ///
  /// Parameters:
  ///
  /// * [Object] body (required):
  ///
  /// * [bool] refresh:
  ///   Should the affected indexes be refreshed?.
  ///
  /// * [String] timeout:
  ///   Time each individual bulk request should wait for shards that are unavailable.
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
  ///
  /// * [bool] waitForCompletion:
  ///   Should this request wait until the operation has completed before returning.
  ///
  /// * [int] requestsPerSecond:
  ///   The throttle for this request in sub-requests per second. -1 means no throttle.
  ///
  /// * [String] scroll:
  ///   Specify how long a consistent view of the index should be maintained for scrolled search.
  ///
  /// * [String] slices:
  ///   The number of slices this task should be divided into. Defaults to 1, meaning the task isn't sliced into subtasks. Can be set to `auto`.
  ///
  /// * [int] maxDocs:
  ///   Maximum number of documents to process (default: all documents).
  Future<void> reindex(
    Object body, {
    bool? refresh,
    String? timeout,
    String? waitForActiveShards,
    bool? waitForCompletion,
    int? requestsPerSecond,
    String? scroll,
    String? slices,
    int? maxDocs,
  }) async {
    final response = await reindexWithHttpInfo(
      body,
      refresh: refresh,
      timeout: timeout,
      waitForActiveShards: waitForActiveShards,
      waitForCompletion: waitForCompletion,
      requestsPerSecond: requestsPerSecond,
      scroll: scroll,
      slices: slices,
      maxDocs: maxDocs,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Changes the number of requests per second for a particular Reindex operation.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] taskId (required):
  ///   The task id to rethrottle.
  ///
  /// * [int] requestsPerSecond (required):
  ///   The throttle for this request in sub-requests per second. -1 means no throttle.
  Future<Response> reindexRethrottleWithHttpInfo(
    String taskId,
    int requestsPerSecond,
  ) async {
    // ignore: prefer_const_declarations
    final path =
        r'/_reindex/{task_id}/_rethrottle'.replaceAll('{task_id}', taskId);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    queryParams
        .addAll(_queryParams('', 'requests_per_second', requestsPerSecond));

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Changes the number of requests per second for a particular Reindex operation.
  ///
  /// Parameters:
  ///
  /// * [String] taskId (required):
  ///   The task id to rethrottle.
  ///
  /// * [int] requestsPerSecond (required):
  ///   The throttle for this request in sub-requests per second. -1 means no throttle.
  Future<void> reindexRethrottle(
    String taskId,
    int requestsPerSecond,
  ) async {
    final response = await reindexRethrottleWithHttpInfo(
      taskId,
      requestsPerSecond,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Reload HTTP layer communication certificates.
  ///
  /// Note: This method returns the HTTP [Response].
  Future<Response> reloadHttpCertificatesWithHttpInfo() async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/ssl/http/reloadcerts';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Reload HTTP layer communication certificates.
  Future<ReloadHttpCertificatesResponseContent?>
      reloadHttpCertificates() async {
    final response = await reloadHttpCertificatesWithHttpInfo();
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'ReloadHttpCertificatesResponseContent',
      ) as ReloadHttpCertificatesResponseContent;
    }
    return null;
  }

  /// Reload transport layer communication certificates.
  ///
  /// Note: This method returns the HTTP [Response].
  Future<Response> reloadTransportCertificatesWithHttpInfo() async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/ssl/transport/reloadcerts';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Reload transport layer communication certificates.
  Future<ReloadTransportCertificatesResponseContent?>
      reloadTransportCertificates() async {
    final response = await reloadTransportCertificatesWithHttpInfo();
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'ReloadTransportCertificatesResponseContent',
      ) as ReloadTransportCertificatesResponseContent;
    }
    return null;
  }

  /// Restores from remote store.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [RemoteStoreRestoreBodyParams] remoteStoreRestoreBodyParams (required):
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] waitForCompletion:
  ///   Should this request wait until the operation has completed before returning.
  Future<Response> remoteStoreRestoreWithHttpInfo(
    RemoteStoreRestoreBodyParams remoteStoreRestoreBodyParams, {
    String? clusterManagerTimeout,
    bool? waitForCompletion,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_remotestore/_restore';

    // ignore: prefer_final_locals
    Object? postBody = remoteStoreRestoreBodyParams;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (waitForCompletion != null) {
      queryParams
          .addAll(_queryParams('', 'wait_for_completion', waitForCompletion));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Restores from remote store.
  ///
  /// Parameters:
  ///
  /// * [RemoteStoreRestoreBodyParams] remoteStoreRestoreBodyParams (required):
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] waitForCompletion:
  ///   Should this request wait until the operation has completed before returning.
  Future<RemoteStoreRestoreResponseContent?> remoteStoreRestore(
    RemoteStoreRestoreBodyParams remoteStoreRestoreBodyParams, {
    String? clusterManagerTimeout,
    bool? waitForCompletion,
  }) async {
    final response = await remoteStoreRestoreWithHttpInfo(
      remoteStoreRestoreBodyParams,
      clusterManagerTimeout: clusterManagerTimeout,
      waitForCompletion: waitForCompletion,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'RemoteStoreRestoreResponseContent',
      ) as RemoteStoreRestoreResponseContent;
    }
    return null;
  }

  /// Allows to use the Mustache language to pre-render a search definition.
  ///
  /// Note: This method returns the HTTP [Response].
  Future<Response> renderSearchTemplateGetWithHttpInfo() async {
    // ignore: prefer_const_declarations
    final path = r'/_render/template';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to use the Mustache language to pre-render a search definition.
  Future<void> renderSearchTemplateGet() async {
    final response = await renderSearchTemplateGetWithHttpInfo();
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to use the Mustache language to pre-render a search definition.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   The id of the stored search template.
  Future<Response> renderSearchTemplateGetWithIdWithHttpInfo(
    String id,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_render/template/{id}'.replaceAll('{id}', id);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to use the Mustache language to pre-render a search definition.
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   The id of the stored search template.
  Future<void> renderSearchTemplateGetWithId(
    String id,
  ) async {
    final response = await renderSearchTemplateGetWithIdWithHttpInfo(
      id,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to use the Mustache language to pre-render a search definition.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [Object] body:
  Future<Response> renderSearchTemplatePostWithHttpInfo({
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_render/template';

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to use the Mustache language to pre-render a search definition.
  ///
  /// Parameters:
  ///
  /// * [Object] body:
  Future<void> renderSearchTemplatePost({
    Object? body,
  }) async {
    final response = await renderSearchTemplatePostWithHttpInfo(
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to use the Mustache language to pre-render a search definition.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   The id of the stored search template.
  ///
  /// * [Object] body:
  Future<Response> renderSearchTemplatePostWithIdWithHttpInfo(
    String id, {
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_render/template/{id}'.replaceAll('{id}', id);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to use the Mustache language to pre-render a search definition.
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   The id of the stored search template.
  ///
  /// * [Object] body:
  Future<void> renderSearchTemplatePostWithId(
    String id, {
    Object? body,
  }) async {
    final response = await renderSearchTemplatePostWithIdWithHttpInfo(
      id,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows an arbitrary script to be executed and a result to be returned.
  ///
  /// Note: This method returns the HTTP [Response].
  Future<Response> scriptsPainlessExecuteGetWithHttpInfo() async {
    // ignore: prefer_const_declarations
    final path = r'/_scripts/painless/_execute';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows an arbitrary script to be executed and a result to be returned.
  Future<void> scriptsPainlessExecuteGet() async {
    final response = await scriptsPainlessExecuteGetWithHttpInfo();
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows an arbitrary script to be executed and a result to be returned.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [Object] body:
  Future<Response> scriptsPainlessExecutePostWithHttpInfo({
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_scripts/painless/_execute';

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows an arbitrary script to be executed and a result to be returned.
  ///
  /// Parameters:
  ///
  /// * [Object] body:
  Future<void> scriptsPainlessExecutePost({
    Object? body,
  }) async {
    final response = await scriptsPainlessExecutePostWithHttpInfo(
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to retrieve a large numbers of results from a single search request.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] scroll:
  ///   Specify how long a consistent view of the index should be maintained for scrolled search.
  ///
  /// * [String] scrollId:
  ///   Scroll ID.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  Future<Response> scrollGetWithHttpInfo({
    String? scroll,
    String? scrollId,
    bool? restTotalHitsAsInt,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_search/scroll';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (scroll != null) {
      queryParams.addAll(_queryParams('', 'scroll', scroll));
    }
    if (scrollId != null) {
      queryParams.addAll(_queryParams('', 'scroll_id', scrollId));
    }
    if (restTotalHitsAsInt != null) {
      queryParams.addAll(
          _queryParams('', 'rest_total_hits_as_int', restTotalHitsAsInt));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to retrieve a large numbers of results from a single search request.
  ///
  /// Parameters:
  ///
  /// * [String] scroll:
  ///   Specify how long a consistent view of the index should be maintained for scrolled search.
  ///
  /// * [String] scrollId:
  ///   Scroll ID.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  Future<void> scrollGet({
    String? scroll,
    String? scrollId,
    bool? restTotalHitsAsInt,
  }) async {
    final response = await scrollGetWithHttpInfo(
      scroll: scroll,
      scrollId: scrollId,
      restTotalHitsAsInt: restTotalHitsAsInt,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to retrieve a large numbers of results from a single search request.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] scrollId (required):
  ///   Scroll ID.
  ///
  /// * [String] scroll:
  ///   Specify how long a consistent view of the index should be maintained for scrolled search.
  ///
  /// * [String] scrollId2:
  ///   Scroll ID.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  Future<Response> scrollGetWithScrollIdWithHttpInfo(
    String scrollId, {
    String? scroll,
    String? scrollId2,
    bool? restTotalHitsAsInt,
  }) async {
    // ignore: prefer_const_declarations
    final path =
        r'/_search/scroll/{scroll_id}'.replaceAll('{scroll_id}', scrollId);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (scroll != null) {
      queryParams.addAll(_queryParams('', 'scroll', scroll));
    }
    if (scrollId2 != null) {
      queryParams.addAll(_queryParams('', 'scroll_id', scrollId2));
    }
    if (restTotalHitsAsInt != null) {
      queryParams.addAll(
          _queryParams('', 'rest_total_hits_as_int', restTotalHitsAsInt));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to retrieve a large numbers of results from a single search request.
  ///
  /// Parameters:
  ///
  /// * [String] scrollId (required):
  ///   Scroll ID.
  ///
  /// * [String] scroll:
  ///   Specify how long a consistent view of the index should be maintained for scrolled search.
  ///
  /// * [String] scrollId2:
  ///   Scroll ID.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  Future<void> scrollGetWithScrollId(
    String scrollId, {
    String? scroll,
    String? scrollId2,
    bool? restTotalHitsAsInt,
  }) async {
    final response = await scrollGetWithScrollIdWithHttpInfo(
      scrollId,
      scroll: scroll,
      scrollId2: scrollId2,
      restTotalHitsAsInt: restTotalHitsAsInt,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to retrieve a large numbers of results from a single search request.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] scroll:
  ///   Specify how long a consistent view of the index should be maintained for scrolled search.
  ///
  /// * [String] scrollId:
  ///   Scroll ID.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [Object] body:
  Future<Response> scrollPostWithHttpInfo({
    String? scroll,
    String? scrollId,
    bool? restTotalHitsAsInt,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_search/scroll';

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (scroll != null) {
      queryParams.addAll(_queryParams('', 'scroll', scroll));
    }
    if (scrollId != null) {
      queryParams.addAll(_queryParams('', 'scroll_id', scrollId));
    }
    if (restTotalHitsAsInt != null) {
      queryParams.addAll(
          _queryParams('', 'rest_total_hits_as_int', restTotalHitsAsInt));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to retrieve a large numbers of results from a single search request.
  ///
  /// Parameters:
  ///
  /// * [String] scroll:
  ///   Specify how long a consistent view of the index should be maintained for scrolled search.
  ///
  /// * [String] scrollId:
  ///   Scroll ID.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [Object] body:
  Future<void> scrollPost({
    String? scroll,
    String? scrollId,
    bool? restTotalHitsAsInt,
    Object? body,
  }) async {
    final response = await scrollPostWithHttpInfo(
      scroll: scroll,
      scrollId: scrollId,
      restTotalHitsAsInt: restTotalHitsAsInt,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to retrieve a large numbers of results from a single search request.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] scrollId (required):
  ///   Scroll ID.
  ///
  /// * [String] scroll:
  ///   Specify how long a consistent view of the index should be maintained for scrolled search.
  ///
  /// * [String] scrollId2:
  ///   Scroll ID.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [Object] body:
  Future<Response> scrollPostWithScrollIdWithHttpInfo(
    String scrollId, {
    String? scroll,
    String? scrollId2,
    bool? restTotalHitsAsInt,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path =
        r'/_search/scroll/{scroll_id}'.replaceAll('{scroll_id}', scrollId);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (scroll != null) {
      queryParams.addAll(_queryParams('', 'scroll', scroll));
    }
    if (scrollId2 != null) {
      queryParams.addAll(_queryParams('', 'scroll_id', scrollId2));
    }
    if (restTotalHitsAsInt != null) {
      queryParams.addAll(
          _queryParams('', 'rest_total_hits_as_int', restTotalHitsAsInt));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to retrieve a large numbers of results from a single search request.
  ///
  /// Parameters:
  ///
  /// * [String] scrollId (required):
  ///   Scroll ID.
  ///
  /// * [String] scroll:
  ///   Specify how long a consistent view of the index should be maintained for scrolled search.
  ///
  /// * [String] scrollId2:
  ///   Scroll ID.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [Object] body:
  Future<void> scrollPostWithScrollId(
    String scrollId, {
    String? scroll,
    String? scrollId2,
    bool? restTotalHitsAsInt,
    Object? body,
  }) async {
    final response = await scrollPostWithScrollIdWithHttpInfo(
      scrollId,
      scroll: scroll,
      scrollId2: scrollId2,
      restTotalHitsAsInt: restTotalHitsAsInt,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns results matching a query.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcard and prefix queries should be analyzed.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The field to use as default where no field prefix is given in the query string.
  ///
  /// * [bool] explain:
  ///   Specify whether to return detailed information about score computation as part of a hit.
  ///
  /// * [List<String>] storedFields:
  ///   Comma-separated list of stored fields to return.
  ///
  /// * [List<String>] docvalueFields:
  ///   Comma-separated list of fields to return as the docvalue representation of a field for each hit.
  ///
  /// * [int] from:
  ///   Starting offset.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] ignoreThrottled:
  ///   Whether specified concrete, expanded or aliased indices should be ignored when throttled.
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [List<String>] routing:
  ///   Comma-separated list of specific routing values.
  ///
  /// * [String] scroll:
  ///   Specify how long a consistent view of the index should be maintained for scrolled search.
  ///
  /// * [SearchType] searchType:
  ///   Search operation type.
  ///
  /// * [int] size:
  ///   Number of hits to return.
  ///
  /// * [List<String>] sort:
  ///   Comma-separated list of <field>:<direction> pairs.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  ///
  /// * [int] terminateAfter:
  ///   The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
  ///
  /// * [List<String>] stats:
  ///   Specific 'tag' of the request for logging and statistical purposes.
  ///
  /// * [String] suggestField:
  ///   Specify which field to use for suggestions.
  ///
  /// * [SuggestMode] suggestMode:
  ///   Specify suggest mode.
  ///
  /// * [int] suggestSize:
  ///   How many suggestions to return in response.
  ///
  /// * [String] suggestText:
  ///   The source text for which the suggestions should be returned.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] trackScores:
  ///   Whether to calculate and return scores even if they are not used for sorting.
  ///
  /// * [bool] trackTotalHits:
  ///   Indicate if the number of documents that match the query should be tracked.
  ///
  /// * [bool] allowPartialSearchResults:
  ///   Indicate if an error should be returned if there is a partial search failure or timeout.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [bool] version:
  ///   Whether to return document version as part of a hit.
  ///
  /// * [bool] seqNoPrimaryTerm:
  ///   Specify whether to return sequence number and primary term of the last modification of each hit.
  ///
  /// * [bool] requestCache:
  ///   Specify if request cache should be used for this request or not, defaults to index level setting.
  ///
  /// * [int] batchedReduceSize:
  ///   The number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.
  ///
  /// * [int] maxConcurrentShardRequests:
  ///   The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
  ///
  /// * [int] preFilterShardSize:
  ///   Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  Future<Response> searchGetWithHttpInfo({
    String? analyzer,
    bool? analyzeWildcard,
    bool? ccsMinimizeRoundtrips,
    DefaultOperator? defaultOperator,
    String? df,
    bool? explain,
    List<String>? storedFields,
    List<String>? docvalueFields,
    int? from,
    bool? ignoreUnavailable,
    bool? ignoreThrottled,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? lenient,
    String? preference,
    String? q,
    List<String>? routing,
    String? scroll,
    SearchType? searchType,
    int? size,
    List<String>? sort,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    int? terminateAfter,
    List<String>? stats,
    String? suggestField,
    SuggestMode? suggestMode,
    int? suggestSize,
    String? suggestText,
    String? timeout,
    bool? trackScores,
    bool? trackTotalHits,
    bool? allowPartialSearchResults,
    bool? typedKeys,
    bool? version,
    bool? seqNoPrimaryTerm,
    bool? requestCache,
    int? batchedReduceSize,
    int? maxConcurrentShardRequests,
    int? preFilterShardSize,
    bool? restTotalHitsAsInt,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_search';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (analyzer != null) {
      queryParams.addAll(_queryParams('', 'analyzer', analyzer));
    }
    if (analyzeWildcard != null) {
      queryParams.addAll(_queryParams('', 'analyze_wildcard', analyzeWildcard));
    }
    if (ccsMinimizeRoundtrips != null) {
      queryParams.addAll(
          _queryParams('', 'ccs_minimize_roundtrips', ccsMinimizeRoundtrips));
    }
    if (defaultOperator != null) {
      queryParams.addAll(_queryParams('', 'default_operator', defaultOperator));
    }
    if (df != null) {
      queryParams.addAll(_queryParams('', 'df', df));
    }
    if (explain != null) {
      queryParams.addAll(_queryParams('', 'explain', explain));
    }
    if (storedFields != null) {
      queryParams.addAll(_queryParams('multi', 'stored_fields', storedFields));
    }
    if (docvalueFields != null) {
      queryParams
          .addAll(_queryParams('multi', 'docvalue_fields', docvalueFields));
    }
    if (from != null) {
      queryParams.addAll(_queryParams('', 'from', from));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (ignoreThrottled != null) {
      queryParams.addAll(_queryParams('', 'ignore_throttled', ignoreThrottled));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (lenient != null) {
      queryParams.addAll(_queryParams('', 'lenient', lenient));
    }
    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (q != null) {
      queryParams.addAll(_queryParams('', 'q', q));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('multi', 'routing', routing));
    }
    if (scroll != null) {
      queryParams.addAll(_queryParams('', 'scroll', scroll));
    }
    if (searchType != null) {
      queryParams.addAll(_queryParams('', 'search_type', searchType));
    }
    if (size != null) {
      queryParams.addAll(_queryParams('', 'size', size));
    }
    if (sort != null) {
      queryParams.addAll(_queryParams('multi', 'sort', sort));
    }
    if (source_ != null) {
      queryParams.addAll(_queryParams('multi', '_source', source_));
    }
    if (sourceExcludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_excludes', sourceExcludes));
    }
    if (sourceIncludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_includes', sourceIncludes));
    }
    if (terminateAfter != null) {
      queryParams.addAll(_queryParams('', 'terminate_after', terminateAfter));
    }
    if (stats != null) {
      queryParams.addAll(_queryParams('multi', 'stats', stats));
    }
    if (suggestField != null) {
      queryParams.addAll(_queryParams('', 'suggest_field', suggestField));
    }
    if (suggestMode != null) {
      queryParams.addAll(_queryParams('', 'suggest_mode', suggestMode));
    }
    if (suggestSize != null) {
      queryParams.addAll(_queryParams('', 'suggest_size', suggestSize));
    }
    if (suggestText != null) {
      queryParams.addAll(_queryParams('', 'suggest_text', suggestText));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (trackScores != null) {
      queryParams.addAll(_queryParams('', 'track_scores', trackScores));
    }
    if (trackTotalHits != null) {
      queryParams.addAll(_queryParams('', 'track_total_hits', trackTotalHits));
    }
    if (allowPartialSearchResults != null) {
      queryParams.addAll(_queryParams(
          '', 'allow_partial_search_results', allowPartialSearchResults));
    }
    if (typedKeys != null) {
      queryParams.addAll(_queryParams('', 'typed_keys', typedKeys));
    }
    if (version != null) {
      queryParams.addAll(_queryParams('', 'version', version));
    }
    if (seqNoPrimaryTerm != null) {
      queryParams
          .addAll(_queryParams('', 'seq_no_primary_term', seqNoPrimaryTerm));
    }
    if (requestCache != null) {
      queryParams.addAll(_queryParams('', 'request_cache', requestCache));
    }
    if (batchedReduceSize != null) {
      queryParams
          .addAll(_queryParams('', 'batched_reduce_size', batchedReduceSize));
    }
    if (maxConcurrentShardRequests != null) {
      queryParams.addAll(_queryParams(
          '', 'max_concurrent_shard_requests', maxConcurrentShardRequests));
    }
    if (preFilterShardSize != null) {
      queryParams.addAll(
          _queryParams('', 'pre_filter_shard_size', preFilterShardSize));
    }
    if (restTotalHitsAsInt != null) {
      queryParams.addAll(
          _queryParams('', 'rest_total_hits_as_int', restTotalHitsAsInt));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns results matching a query.
  ///
  /// Parameters:
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcard and prefix queries should be analyzed.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The field to use as default where no field prefix is given in the query string.
  ///
  /// * [bool] explain:
  ///   Specify whether to return detailed information about score computation as part of a hit.
  ///
  /// * [List<String>] storedFields:
  ///   Comma-separated list of stored fields to return.
  ///
  /// * [List<String>] docvalueFields:
  ///   Comma-separated list of fields to return as the docvalue representation of a field for each hit.
  ///
  /// * [int] from:
  ///   Starting offset.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] ignoreThrottled:
  ///   Whether specified concrete, expanded or aliased indices should be ignored when throttled.
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [List<String>] routing:
  ///   Comma-separated list of specific routing values.
  ///
  /// * [String] scroll:
  ///   Specify how long a consistent view of the index should be maintained for scrolled search.
  ///
  /// * [SearchType] searchType:
  ///   Search operation type.
  ///
  /// * [int] size:
  ///   Number of hits to return.
  ///
  /// * [List<String>] sort:
  ///   Comma-separated list of <field>:<direction> pairs.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  ///
  /// * [int] terminateAfter:
  ///   The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
  ///
  /// * [List<String>] stats:
  ///   Specific 'tag' of the request for logging and statistical purposes.
  ///
  /// * [String] suggestField:
  ///   Specify which field to use for suggestions.
  ///
  /// * [SuggestMode] suggestMode:
  ///   Specify suggest mode.
  ///
  /// * [int] suggestSize:
  ///   How many suggestions to return in response.
  ///
  /// * [String] suggestText:
  ///   The source text for which the suggestions should be returned.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] trackScores:
  ///   Whether to calculate and return scores even if they are not used for sorting.
  ///
  /// * [bool] trackTotalHits:
  ///   Indicate if the number of documents that match the query should be tracked.
  ///
  /// * [bool] allowPartialSearchResults:
  ///   Indicate if an error should be returned if there is a partial search failure or timeout.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [bool] version:
  ///   Whether to return document version as part of a hit.
  ///
  /// * [bool] seqNoPrimaryTerm:
  ///   Specify whether to return sequence number and primary term of the last modification of each hit.
  ///
  /// * [bool] requestCache:
  ///   Specify if request cache should be used for this request or not, defaults to index level setting.
  ///
  /// * [int] batchedReduceSize:
  ///   The number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.
  ///
  /// * [int] maxConcurrentShardRequests:
  ///   The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
  ///
  /// * [int] preFilterShardSize:
  ///   Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  Future<SearchGetResponseContent?> searchGet({
    String? analyzer,
    bool? analyzeWildcard,
    bool? ccsMinimizeRoundtrips,
    DefaultOperator? defaultOperator,
    String? df,
    bool? explain,
    List<String>? storedFields,
    List<String>? docvalueFields,
    int? from,
    bool? ignoreUnavailable,
    bool? ignoreThrottled,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? lenient,
    String? preference,
    String? q,
    List<String>? routing,
    String? scroll,
    SearchType? searchType,
    int? size,
    List<String>? sort,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    int? terminateAfter,
    List<String>? stats,
    String? suggestField,
    SuggestMode? suggestMode,
    int? suggestSize,
    String? suggestText,
    String? timeout,
    bool? trackScores,
    bool? trackTotalHits,
    bool? allowPartialSearchResults,
    bool? typedKeys,
    bool? version,
    bool? seqNoPrimaryTerm,
    bool? requestCache,
    int? batchedReduceSize,
    int? maxConcurrentShardRequests,
    int? preFilterShardSize,
    bool? restTotalHitsAsInt,
  }) async {
    final response = await searchGetWithHttpInfo(
      analyzer: analyzer,
      analyzeWildcard: analyzeWildcard,
      ccsMinimizeRoundtrips: ccsMinimizeRoundtrips,
      defaultOperator: defaultOperator,
      df: df,
      explain: explain,
      storedFields: storedFields,
      docvalueFields: docvalueFields,
      from: from,
      ignoreUnavailable: ignoreUnavailable,
      ignoreThrottled: ignoreThrottled,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      lenient: lenient,
      preference: preference,
      q: q,
      routing: routing,
      scroll: scroll,
      searchType: searchType,
      size: size,
      sort: sort,
      source_: source_,
      sourceExcludes: sourceExcludes,
      sourceIncludes: sourceIncludes,
      terminateAfter: terminateAfter,
      stats: stats,
      suggestField: suggestField,
      suggestMode: suggestMode,
      suggestSize: suggestSize,
      suggestText: suggestText,
      timeout: timeout,
      trackScores: trackScores,
      trackTotalHits: trackTotalHits,
      allowPartialSearchResults: allowPartialSearchResults,
      typedKeys: typedKeys,
      version: version,
      seqNoPrimaryTerm: seqNoPrimaryTerm,
      requestCache: requestCache,
      batchedReduceSize: batchedReduceSize,
      maxConcurrentShardRequests: maxConcurrentShardRequests,
      preFilterShardSize: preFilterShardSize,
      restTotalHitsAsInt: restTotalHitsAsInt,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'SearchGetResponseContent',
      ) as SearchGetResponseContent;
    }
    return null;
  }

  /// Returns results matching a query.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcard and prefix queries should be analyzed.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The field to use as default where no field prefix is given in the query string.
  ///
  /// * [bool] explain:
  ///   Specify whether to return detailed information about score computation as part of a hit.
  ///
  /// * [List<String>] storedFields:
  ///   Comma-separated list of stored fields to return.
  ///
  /// * [List<String>] docvalueFields:
  ///   Comma-separated list of fields to return as the docvalue representation of a field for each hit.
  ///
  /// * [int] from:
  ///   Starting offset.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] ignoreThrottled:
  ///   Whether specified concrete, expanded or aliased indices should be ignored when throttled.
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [List<String>] routing:
  ///   Comma-separated list of specific routing values.
  ///
  /// * [String] scroll:
  ///   Specify how long a consistent view of the index should be maintained for scrolled search.
  ///
  /// * [SearchType] searchType:
  ///   Search operation type.
  ///
  /// * [int] size:
  ///   Number of hits to return.
  ///
  /// * [List<String>] sort:
  ///   Comma-separated list of <field>:<direction> pairs.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  ///
  /// * [int] terminateAfter:
  ///   The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
  ///
  /// * [List<String>] stats:
  ///   Specific 'tag' of the request for logging and statistical purposes.
  ///
  /// * [String] suggestField:
  ///   Specify which field to use for suggestions.
  ///
  /// * [SuggestMode] suggestMode:
  ///   Specify suggest mode.
  ///
  /// * [int] suggestSize:
  ///   How many suggestions to return in response.
  ///
  /// * [String] suggestText:
  ///   The source text for which the suggestions should be returned.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] trackScores:
  ///   Whether to calculate and return scores even if they are not used for sorting.
  ///
  /// * [bool] trackTotalHits:
  ///   Indicate if the number of documents that match the query should be tracked.
  ///
  /// * [bool] allowPartialSearchResults:
  ///   Indicate if an error should be returned if there is a partial search failure or timeout.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [bool] version:
  ///   Whether to return document version as part of a hit.
  ///
  /// * [bool] seqNoPrimaryTerm:
  ///   Specify whether to return sequence number and primary term of the last modification of each hit.
  ///
  /// * [bool] requestCache:
  ///   Specify if request cache should be used for this request or not, defaults to index level setting.
  ///
  /// * [int] batchedReduceSize:
  ///   The number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.
  ///
  /// * [int] maxConcurrentShardRequests:
  ///   The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
  ///
  /// * [int] preFilterShardSize:
  ///   Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  Future<Response> searchGetWithIndexWithHttpInfo(
    String index, {
    String? analyzer,
    bool? analyzeWildcard,
    bool? ccsMinimizeRoundtrips,
    DefaultOperator? defaultOperator,
    String? df,
    bool? explain,
    List<String>? storedFields,
    List<String>? docvalueFields,
    int? from,
    bool? ignoreUnavailable,
    bool? ignoreThrottled,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? lenient,
    String? preference,
    String? q,
    List<String>? routing,
    String? scroll,
    SearchType? searchType,
    int? size,
    List<String>? sort,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    int? terminateAfter,
    List<String>? stats,
    String? suggestField,
    SuggestMode? suggestMode,
    int? suggestSize,
    String? suggestText,
    String? timeout,
    bool? trackScores,
    bool? trackTotalHits,
    bool? allowPartialSearchResults,
    bool? typedKeys,
    bool? version,
    bool? seqNoPrimaryTerm,
    bool? requestCache,
    int? batchedReduceSize,
    int? maxConcurrentShardRequests,
    int? preFilterShardSize,
    bool? restTotalHitsAsInt,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_search'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (analyzer != null) {
      queryParams.addAll(_queryParams('', 'analyzer', analyzer));
    }
    if (analyzeWildcard != null) {
      queryParams.addAll(_queryParams('', 'analyze_wildcard', analyzeWildcard));
    }
    if (ccsMinimizeRoundtrips != null) {
      queryParams.addAll(
          _queryParams('', 'ccs_minimize_roundtrips', ccsMinimizeRoundtrips));
    }
    if (defaultOperator != null) {
      queryParams.addAll(_queryParams('', 'default_operator', defaultOperator));
    }
    if (df != null) {
      queryParams.addAll(_queryParams('', 'df', df));
    }
    if (explain != null) {
      queryParams.addAll(_queryParams('', 'explain', explain));
    }
    if (storedFields != null) {
      queryParams.addAll(_queryParams('multi', 'stored_fields', storedFields));
    }
    if (docvalueFields != null) {
      queryParams
          .addAll(_queryParams('multi', 'docvalue_fields', docvalueFields));
    }
    if (from != null) {
      queryParams.addAll(_queryParams('', 'from', from));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (ignoreThrottled != null) {
      queryParams.addAll(_queryParams('', 'ignore_throttled', ignoreThrottled));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (lenient != null) {
      queryParams.addAll(_queryParams('', 'lenient', lenient));
    }
    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (q != null) {
      queryParams.addAll(_queryParams('', 'q', q));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('multi', 'routing', routing));
    }
    if (scroll != null) {
      queryParams.addAll(_queryParams('', 'scroll', scroll));
    }
    if (searchType != null) {
      queryParams.addAll(_queryParams('', 'search_type', searchType));
    }
    if (size != null) {
      queryParams.addAll(_queryParams('', 'size', size));
    }
    if (sort != null) {
      queryParams.addAll(_queryParams('multi', 'sort', sort));
    }
    if (source_ != null) {
      queryParams.addAll(_queryParams('multi', '_source', source_));
    }
    if (sourceExcludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_excludes', sourceExcludes));
    }
    if (sourceIncludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_includes', sourceIncludes));
    }
    if (terminateAfter != null) {
      queryParams.addAll(_queryParams('', 'terminate_after', terminateAfter));
    }
    if (stats != null) {
      queryParams.addAll(_queryParams('multi', 'stats', stats));
    }
    if (suggestField != null) {
      queryParams.addAll(_queryParams('', 'suggest_field', suggestField));
    }
    if (suggestMode != null) {
      queryParams.addAll(_queryParams('', 'suggest_mode', suggestMode));
    }
    if (suggestSize != null) {
      queryParams.addAll(_queryParams('', 'suggest_size', suggestSize));
    }
    if (suggestText != null) {
      queryParams.addAll(_queryParams('', 'suggest_text', suggestText));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (trackScores != null) {
      queryParams.addAll(_queryParams('', 'track_scores', trackScores));
    }
    if (trackTotalHits != null) {
      queryParams.addAll(_queryParams('', 'track_total_hits', trackTotalHits));
    }
    if (allowPartialSearchResults != null) {
      queryParams.addAll(_queryParams(
          '', 'allow_partial_search_results', allowPartialSearchResults));
    }
    if (typedKeys != null) {
      queryParams.addAll(_queryParams('', 'typed_keys', typedKeys));
    }
    if (version != null) {
      queryParams.addAll(_queryParams('', 'version', version));
    }
    if (seqNoPrimaryTerm != null) {
      queryParams
          .addAll(_queryParams('', 'seq_no_primary_term', seqNoPrimaryTerm));
    }
    if (requestCache != null) {
      queryParams.addAll(_queryParams('', 'request_cache', requestCache));
    }
    if (batchedReduceSize != null) {
      queryParams
          .addAll(_queryParams('', 'batched_reduce_size', batchedReduceSize));
    }
    if (maxConcurrentShardRequests != null) {
      queryParams.addAll(_queryParams(
          '', 'max_concurrent_shard_requests', maxConcurrentShardRequests));
    }
    if (preFilterShardSize != null) {
      queryParams.addAll(
          _queryParams('', 'pre_filter_shard_size', preFilterShardSize));
    }
    if (restTotalHitsAsInt != null) {
      queryParams.addAll(
          _queryParams('', 'rest_total_hits_as_int', restTotalHitsAsInt));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns results matching a query.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcard and prefix queries should be analyzed.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The field to use as default where no field prefix is given in the query string.
  ///
  /// * [bool] explain:
  ///   Specify whether to return detailed information about score computation as part of a hit.
  ///
  /// * [List<String>] storedFields:
  ///   Comma-separated list of stored fields to return.
  ///
  /// * [List<String>] docvalueFields:
  ///   Comma-separated list of fields to return as the docvalue representation of a field for each hit.
  ///
  /// * [int] from:
  ///   Starting offset.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] ignoreThrottled:
  ///   Whether specified concrete, expanded or aliased indices should be ignored when throttled.
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [List<String>] routing:
  ///   Comma-separated list of specific routing values.
  ///
  /// * [String] scroll:
  ///   Specify how long a consistent view of the index should be maintained for scrolled search.
  ///
  /// * [SearchType] searchType:
  ///   Search operation type.
  ///
  /// * [int] size:
  ///   Number of hits to return.
  ///
  /// * [List<String>] sort:
  ///   Comma-separated list of <field>:<direction> pairs.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  ///
  /// * [int] terminateAfter:
  ///   The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
  ///
  /// * [List<String>] stats:
  ///   Specific 'tag' of the request for logging and statistical purposes.
  ///
  /// * [String] suggestField:
  ///   Specify which field to use for suggestions.
  ///
  /// * [SuggestMode] suggestMode:
  ///   Specify suggest mode.
  ///
  /// * [int] suggestSize:
  ///   How many suggestions to return in response.
  ///
  /// * [String] suggestText:
  ///   The source text for which the suggestions should be returned.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] trackScores:
  ///   Whether to calculate and return scores even if they are not used for sorting.
  ///
  /// * [bool] trackTotalHits:
  ///   Indicate if the number of documents that match the query should be tracked.
  ///
  /// * [bool] allowPartialSearchResults:
  ///   Indicate if an error should be returned if there is a partial search failure or timeout.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [bool] version:
  ///   Whether to return document version as part of a hit.
  ///
  /// * [bool] seqNoPrimaryTerm:
  ///   Specify whether to return sequence number and primary term of the last modification of each hit.
  ///
  /// * [bool] requestCache:
  ///   Specify if request cache should be used for this request or not, defaults to index level setting.
  ///
  /// * [int] batchedReduceSize:
  ///   The number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.
  ///
  /// * [int] maxConcurrentShardRequests:
  ///   The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
  ///
  /// * [int] preFilterShardSize:
  ///   Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  Future<SearchGetWithIndexResponseContent?> searchGetWithIndex(
    String index, {
    String? analyzer,
    bool? analyzeWildcard,
    bool? ccsMinimizeRoundtrips,
    DefaultOperator? defaultOperator,
    String? df,
    bool? explain,
    List<String>? storedFields,
    List<String>? docvalueFields,
    int? from,
    bool? ignoreUnavailable,
    bool? ignoreThrottled,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? lenient,
    String? preference,
    String? q,
    List<String>? routing,
    String? scroll,
    SearchType? searchType,
    int? size,
    List<String>? sort,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    int? terminateAfter,
    List<String>? stats,
    String? suggestField,
    SuggestMode? suggestMode,
    int? suggestSize,
    String? suggestText,
    String? timeout,
    bool? trackScores,
    bool? trackTotalHits,
    bool? allowPartialSearchResults,
    bool? typedKeys,
    bool? version,
    bool? seqNoPrimaryTerm,
    bool? requestCache,
    int? batchedReduceSize,
    int? maxConcurrentShardRequests,
    int? preFilterShardSize,
    bool? restTotalHitsAsInt,
  }) async {
    final response = await searchGetWithIndexWithHttpInfo(
      index,
      analyzer: analyzer,
      analyzeWildcard: analyzeWildcard,
      ccsMinimizeRoundtrips: ccsMinimizeRoundtrips,
      defaultOperator: defaultOperator,
      df: df,
      explain: explain,
      storedFields: storedFields,
      docvalueFields: docvalueFields,
      from: from,
      ignoreUnavailable: ignoreUnavailable,
      ignoreThrottled: ignoreThrottled,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      lenient: lenient,
      preference: preference,
      q: q,
      routing: routing,
      scroll: scroll,
      searchType: searchType,
      size: size,
      sort: sort,
      source_: source_,
      sourceExcludes: sourceExcludes,
      sourceIncludes: sourceIncludes,
      terminateAfter: terminateAfter,
      stats: stats,
      suggestField: suggestField,
      suggestMode: suggestMode,
      suggestSize: suggestSize,
      suggestText: suggestText,
      timeout: timeout,
      trackScores: trackScores,
      trackTotalHits: trackTotalHits,
      allowPartialSearchResults: allowPartialSearchResults,
      typedKeys: typedKeys,
      version: version,
      seqNoPrimaryTerm: seqNoPrimaryTerm,
      requestCache: requestCache,
      batchedReduceSize: batchedReduceSize,
      maxConcurrentShardRequests: maxConcurrentShardRequests,
      preFilterShardSize: preFilterShardSize,
      restTotalHitsAsInt: restTotalHitsAsInt,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'SearchGetWithIndexResponseContent',
      ) as SearchGetWithIndexResponseContent;
    }
    return null;
  }

  /// Returns results matching a query.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcard and prefix queries should be analyzed.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The field to use as default where no field prefix is given in the query string.
  ///
  /// * [bool] explain:
  ///   Specify whether to return detailed information about score computation as part of a hit.
  ///
  /// * [List<String>] storedFields:
  ///   Comma-separated list of stored fields to return.
  ///
  /// * [List<String>] docvalueFields:
  ///   Comma-separated list of fields to return as the docvalue representation of a field for each hit.
  ///
  /// * [int] from:
  ///   Starting offset.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] ignoreThrottled:
  ///   Whether specified concrete, expanded or aliased indices should be ignored when throttled.
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [List<String>] routing:
  ///   Comma-separated list of specific routing values.
  ///
  /// * [String] scroll:
  ///   Specify how long a consistent view of the index should be maintained for scrolled search.
  ///
  /// * [SearchType] searchType:
  ///   Search operation type.
  ///
  /// * [int] size:
  ///   Number of hits to return.
  ///
  /// * [List<String>] sort:
  ///   Comma-separated list of <field>:<direction> pairs.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  ///
  /// * [int] terminateAfter:
  ///   The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
  ///
  /// * [List<String>] stats:
  ///   Specific 'tag' of the request for logging and statistical purposes.
  ///
  /// * [String] suggestField:
  ///   Specify which field to use for suggestions.
  ///
  /// * [SuggestMode] suggestMode:
  ///   Specify suggest mode.
  ///
  /// * [int] suggestSize:
  ///   How many suggestions to return in response.
  ///
  /// * [String] suggestText:
  ///   The source text for which the suggestions should be returned.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] trackScores:
  ///   Whether to calculate and return scores even if they are not used for sorting.
  ///
  /// * [bool] trackTotalHits:
  ///   Indicate if the number of documents that match the query should be tracked.
  ///
  /// * [bool] allowPartialSearchResults:
  ///   Indicate if an error should be returned if there is a partial search failure or timeout.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [bool] version:
  ///   Whether to return document version as part of a hit.
  ///
  /// * [bool] seqNoPrimaryTerm:
  ///   Specify whether to return sequence number and primary term of the last modification of each hit.
  ///
  /// * [bool] requestCache:
  ///   Specify if request cache should be used for this request or not, defaults to index level setting.
  ///
  /// * [int] batchedReduceSize:
  ///   The number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.
  ///
  /// * [int] maxConcurrentShardRequests:
  ///   The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
  ///
  /// * [int] preFilterShardSize:
  ///   Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [SearchBodyParams] searchBodyParams:
  Future<Response> searchPostWithHttpInfo({
    String? analyzer,
    bool? analyzeWildcard,
    bool? ccsMinimizeRoundtrips,
    DefaultOperator? defaultOperator,
    String? df,
    bool? explain,
    List<String>? storedFields,
    List<String>? docvalueFields,
    int? from,
    bool? ignoreUnavailable,
    bool? ignoreThrottled,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? lenient,
    String? preference,
    String? q,
    List<String>? routing,
    String? scroll,
    SearchType? searchType,
    int? size,
    List<String>? sort,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    int? terminateAfter,
    List<String>? stats,
    String? suggestField,
    SuggestMode? suggestMode,
    int? suggestSize,
    String? suggestText,
    String? timeout,
    bool? trackScores,
    bool? trackTotalHits,
    bool? allowPartialSearchResults,
    bool? typedKeys,
    bool? version,
    bool? seqNoPrimaryTerm,
    bool? requestCache,
    int? batchedReduceSize,
    int? maxConcurrentShardRequests,
    int? preFilterShardSize,
    bool? restTotalHitsAsInt,
    SearchBodyParams? searchBodyParams,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_search';

    // ignore: prefer_final_locals
    Object? postBody = searchBodyParams;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (analyzer != null) {
      queryParams.addAll(_queryParams('', 'analyzer', analyzer));
    }
    if (analyzeWildcard != null) {
      queryParams.addAll(_queryParams('', 'analyze_wildcard', analyzeWildcard));
    }
    if (ccsMinimizeRoundtrips != null) {
      queryParams.addAll(
          _queryParams('', 'ccs_minimize_roundtrips', ccsMinimizeRoundtrips));
    }
    if (defaultOperator != null) {
      queryParams.addAll(_queryParams('', 'default_operator', defaultOperator));
    }
    if (df != null) {
      queryParams.addAll(_queryParams('', 'df', df));
    }
    if (explain != null) {
      queryParams.addAll(_queryParams('', 'explain', explain));
    }
    if (storedFields != null) {
      queryParams.addAll(_queryParams('multi', 'stored_fields', storedFields));
    }
    if (docvalueFields != null) {
      queryParams
          .addAll(_queryParams('multi', 'docvalue_fields', docvalueFields));
    }
    if (from != null) {
      queryParams.addAll(_queryParams('', 'from', from));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (ignoreThrottled != null) {
      queryParams.addAll(_queryParams('', 'ignore_throttled', ignoreThrottled));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (lenient != null) {
      queryParams.addAll(_queryParams('', 'lenient', lenient));
    }
    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (q != null) {
      queryParams.addAll(_queryParams('', 'q', q));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('multi', 'routing', routing));
    }
    if (scroll != null) {
      queryParams.addAll(_queryParams('', 'scroll', scroll));
    }
    if (searchType != null) {
      queryParams.addAll(_queryParams('', 'search_type', searchType));
    }
    if (size != null) {
      queryParams.addAll(_queryParams('', 'size', size));
    }
    if (sort != null) {
      queryParams.addAll(_queryParams('multi', 'sort', sort));
    }
    if (source_ != null) {
      queryParams.addAll(_queryParams('multi', '_source', source_));
    }
    if (sourceExcludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_excludes', sourceExcludes));
    }
    if (sourceIncludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_includes', sourceIncludes));
    }
    if (terminateAfter != null) {
      queryParams.addAll(_queryParams('', 'terminate_after', terminateAfter));
    }
    if (stats != null) {
      queryParams.addAll(_queryParams('multi', 'stats', stats));
    }
    if (suggestField != null) {
      queryParams.addAll(_queryParams('', 'suggest_field', suggestField));
    }
    if (suggestMode != null) {
      queryParams.addAll(_queryParams('', 'suggest_mode', suggestMode));
    }
    if (suggestSize != null) {
      queryParams.addAll(_queryParams('', 'suggest_size', suggestSize));
    }
    if (suggestText != null) {
      queryParams.addAll(_queryParams('', 'suggest_text', suggestText));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (trackScores != null) {
      queryParams.addAll(_queryParams('', 'track_scores', trackScores));
    }
    if (trackTotalHits != null) {
      queryParams.addAll(_queryParams('', 'track_total_hits', trackTotalHits));
    }
    if (allowPartialSearchResults != null) {
      queryParams.addAll(_queryParams(
          '', 'allow_partial_search_results', allowPartialSearchResults));
    }
    if (typedKeys != null) {
      queryParams.addAll(_queryParams('', 'typed_keys', typedKeys));
    }
    if (version != null) {
      queryParams.addAll(_queryParams('', 'version', version));
    }
    if (seqNoPrimaryTerm != null) {
      queryParams
          .addAll(_queryParams('', 'seq_no_primary_term', seqNoPrimaryTerm));
    }
    if (requestCache != null) {
      queryParams.addAll(_queryParams('', 'request_cache', requestCache));
    }
    if (batchedReduceSize != null) {
      queryParams
          .addAll(_queryParams('', 'batched_reduce_size', batchedReduceSize));
    }
    if (maxConcurrentShardRequests != null) {
      queryParams.addAll(_queryParams(
          '', 'max_concurrent_shard_requests', maxConcurrentShardRequests));
    }
    if (preFilterShardSize != null) {
      queryParams.addAll(
          _queryParams('', 'pre_filter_shard_size', preFilterShardSize));
    }
    if (restTotalHitsAsInt != null) {
      queryParams.addAll(
          _queryParams('', 'rest_total_hits_as_int', restTotalHitsAsInt));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns results matching a query.
  ///
  /// Parameters:
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcard and prefix queries should be analyzed.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The field to use as default where no field prefix is given in the query string.
  ///
  /// * [bool] explain:
  ///   Specify whether to return detailed information about score computation as part of a hit.
  ///
  /// * [List<String>] storedFields:
  ///   Comma-separated list of stored fields to return.
  ///
  /// * [List<String>] docvalueFields:
  ///   Comma-separated list of fields to return as the docvalue representation of a field for each hit.
  ///
  /// * [int] from:
  ///   Starting offset.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] ignoreThrottled:
  ///   Whether specified concrete, expanded or aliased indices should be ignored when throttled.
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [List<String>] routing:
  ///   Comma-separated list of specific routing values.
  ///
  /// * [String] scroll:
  ///   Specify how long a consistent view of the index should be maintained for scrolled search.
  ///
  /// * [SearchType] searchType:
  ///   Search operation type.
  ///
  /// * [int] size:
  ///   Number of hits to return.
  ///
  /// * [List<String>] sort:
  ///   Comma-separated list of <field>:<direction> pairs.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  ///
  /// * [int] terminateAfter:
  ///   The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
  ///
  /// * [List<String>] stats:
  ///   Specific 'tag' of the request for logging and statistical purposes.
  ///
  /// * [String] suggestField:
  ///   Specify which field to use for suggestions.
  ///
  /// * [SuggestMode] suggestMode:
  ///   Specify suggest mode.
  ///
  /// * [int] suggestSize:
  ///   How many suggestions to return in response.
  ///
  /// * [String] suggestText:
  ///   The source text for which the suggestions should be returned.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] trackScores:
  ///   Whether to calculate and return scores even if they are not used for sorting.
  ///
  /// * [bool] trackTotalHits:
  ///   Indicate if the number of documents that match the query should be tracked.
  ///
  /// * [bool] allowPartialSearchResults:
  ///   Indicate if an error should be returned if there is a partial search failure or timeout.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [bool] version:
  ///   Whether to return document version as part of a hit.
  ///
  /// * [bool] seqNoPrimaryTerm:
  ///   Specify whether to return sequence number and primary term of the last modification of each hit.
  ///
  /// * [bool] requestCache:
  ///   Specify if request cache should be used for this request or not, defaults to index level setting.
  ///
  /// * [int] batchedReduceSize:
  ///   The number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.
  ///
  /// * [int] maxConcurrentShardRequests:
  ///   The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
  ///
  /// * [int] preFilterShardSize:
  ///   Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [SearchBodyParams] searchBodyParams:
  Future<SearchPostResponseContent?> searchPost({
    String? analyzer,
    bool? analyzeWildcard,
    bool? ccsMinimizeRoundtrips,
    DefaultOperator? defaultOperator,
    String? df,
    bool? explain,
    List<String>? storedFields,
    List<String>? docvalueFields,
    int? from,
    bool? ignoreUnavailable,
    bool? ignoreThrottled,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? lenient,
    String? preference,
    String? q,
    List<String>? routing,
    String? scroll,
    SearchType? searchType,
    int? size,
    List<String>? sort,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    int? terminateAfter,
    List<String>? stats,
    String? suggestField,
    SuggestMode? suggestMode,
    int? suggestSize,
    String? suggestText,
    String? timeout,
    bool? trackScores,
    bool? trackTotalHits,
    bool? allowPartialSearchResults,
    bool? typedKeys,
    bool? version,
    bool? seqNoPrimaryTerm,
    bool? requestCache,
    int? batchedReduceSize,
    int? maxConcurrentShardRequests,
    int? preFilterShardSize,
    bool? restTotalHitsAsInt,
    SearchBodyParams? searchBodyParams,
  }) async {
    final response = await searchPostWithHttpInfo(
      analyzer: analyzer,
      analyzeWildcard: analyzeWildcard,
      ccsMinimizeRoundtrips: ccsMinimizeRoundtrips,
      defaultOperator: defaultOperator,
      df: df,
      explain: explain,
      storedFields: storedFields,
      docvalueFields: docvalueFields,
      from: from,
      ignoreUnavailable: ignoreUnavailable,
      ignoreThrottled: ignoreThrottled,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      lenient: lenient,
      preference: preference,
      q: q,
      routing: routing,
      scroll: scroll,
      searchType: searchType,
      size: size,
      sort: sort,
      source_: source_,
      sourceExcludes: sourceExcludes,
      sourceIncludes: sourceIncludes,
      terminateAfter: terminateAfter,
      stats: stats,
      suggestField: suggestField,
      suggestMode: suggestMode,
      suggestSize: suggestSize,
      suggestText: suggestText,
      timeout: timeout,
      trackScores: trackScores,
      trackTotalHits: trackTotalHits,
      allowPartialSearchResults: allowPartialSearchResults,
      typedKeys: typedKeys,
      version: version,
      seqNoPrimaryTerm: seqNoPrimaryTerm,
      requestCache: requestCache,
      batchedReduceSize: batchedReduceSize,
      maxConcurrentShardRequests: maxConcurrentShardRequests,
      preFilterShardSize: preFilterShardSize,
      restTotalHitsAsInt: restTotalHitsAsInt,
      searchBodyParams: searchBodyParams,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'SearchPostResponseContent',
      ) as SearchPostResponseContent;
    }
    return null;
  }

  /// Returns results matching a query.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcard and prefix queries should be analyzed.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The field to use as default where no field prefix is given in the query string.
  ///
  /// * [bool] explain:
  ///   Specify whether to return detailed information about score computation as part of a hit.
  ///
  /// * [List<String>] storedFields:
  ///   Comma-separated list of stored fields to return.
  ///
  /// * [List<String>] docvalueFields:
  ///   Comma-separated list of fields to return as the docvalue representation of a field for each hit.
  ///
  /// * [int] from:
  ///   Starting offset.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] ignoreThrottled:
  ///   Whether specified concrete, expanded or aliased indices should be ignored when throttled.
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [List<String>] routing:
  ///   Comma-separated list of specific routing values.
  ///
  /// * [String] scroll:
  ///   Specify how long a consistent view of the index should be maintained for scrolled search.
  ///
  /// * [SearchType] searchType:
  ///   Search operation type.
  ///
  /// * [int] size:
  ///   Number of hits to return.
  ///
  /// * [List<String>] sort:
  ///   Comma-separated list of <field>:<direction> pairs.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  ///
  /// * [int] terminateAfter:
  ///   The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
  ///
  /// * [List<String>] stats:
  ///   Specific 'tag' of the request for logging and statistical purposes.
  ///
  /// * [String] suggestField:
  ///   Specify which field to use for suggestions.
  ///
  /// * [SuggestMode] suggestMode:
  ///   Specify suggest mode.
  ///
  /// * [int] suggestSize:
  ///   How many suggestions to return in response.
  ///
  /// * [String] suggestText:
  ///   The source text for which the suggestions should be returned.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] trackScores:
  ///   Whether to calculate and return scores even if they are not used for sorting.
  ///
  /// * [bool] trackTotalHits:
  ///   Indicate if the number of documents that match the query should be tracked.
  ///
  /// * [bool] allowPartialSearchResults:
  ///   Indicate if an error should be returned if there is a partial search failure or timeout.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [bool] version:
  ///   Whether to return document version as part of a hit.
  ///
  /// * [bool] seqNoPrimaryTerm:
  ///   Specify whether to return sequence number and primary term of the last modification of each hit.
  ///
  /// * [bool] requestCache:
  ///   Specify if request cache should be used for this request or not, defaults to index level setting.
  ///
  /// * [int] batchedReduceSize:
  ///   The number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.
  ///
  /// * [int] maxConcurrentShardRequests:
  ///   The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
  ///
  /// * [int] preFilterShardSize:
  ///   Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [SearchBodyParams] searchBodyParams:
  Future<Response> searchPostWithIndexWithHttpInfo(
    String index, {
    String? analyzer,
    bool? analyzeWildcard,
    bool? ccsMinimizeRoundtrips,
    DefaultOperator? defaultOperator,
    String? df,
    bool? explain,
    List<String>? storedFields,
    List<String>? docvalueFields,
    int? from,
    bool? ignoreUnavailable,
    bool? ignoreThrottled,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? lenient,
    String? preference,
    String? q,
    List<String>? routing,
    String? scroll,
    SearchType? searchType,
    int? size,
    List<String>? sort,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    int? terminateAfter,
    List<String>? stats,
    String? suggestField,
    SuggestMode? suggestMode,
    int? suggestSize,
    String? suggestText,
    String? timeout,
    bool? trackScores,
    bool? trackTotalHits,
    bool? allowPartialSearchResults,
    bool? typedKeys,
    bool? version,
    bool? seqNoPrimaryTerm,
    bool? requestCache,
    int? batchedReduceSize,
    int? maxConcurrentShardRequests,
    int? preFilterShardSize,
    bool? restTotalHitsAsInt,
    SearchBodyParams? searchBodyParams,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_search'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody = searchBodyParams;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (analyzer != null) {
      queryParams.addAll(_queryParams('', 'analyzer', analyzer));
    }
    if (analyzeWildcard != null) {
      queryParams.addAll(_queryParams('', 'analyze_wildcard', analyzeWildcard));
    }
    if (ccsMinimizeRoundtrips != null) {
      queryParams.addAll(
          _queryParams('', 'ccs_minimize_roundtrips', ccsMinimizeRoundtrips));
    }
    if (defaultOperator != null) {
      queryParams.addAll(_queryParams('', 'default_operator', defaultOperator));
    }
    if (df != null) {
      queryParams.addAll(_queryParams('', 'df', df));
    }
    if (explain != null) {
      queryParams.addAll(_queryParams('', 'explain', explain));
    }
    if (storedFields != null) {
      queryParams.addAll(_queryParams('multi', 'stored_fields', storedFields));
    }
    if (docvalueFields != null) {
      queryParams
          .addAll(_queryParams('multi', 'docvalue_fields', docvalueFields));
    }
    if (from != null) {
      queryParams.addAll(_queryParams('', 'from', from));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (ignoreThrottled != null) {
      queryParams.addAll(_queryParams('', 'ignore_throttled', ignoreThrottled));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (lenient != null) {
      queryParams.addAll(_queryParams('', 'lenient', lenient));
    }
    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (q != null) {
      queryParams.addAll(_queryParams('', 'q', q));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('multi', 'routing', routing));
    }
    if (scroll != null) {
      queryParams.addAll(_queryParams('', 'scroll', scroll));
    }
    if (searchType != null) {
      queryParams.addAll(_queryParams('', 'search_type', searchType));
    }
    if (size != null) {
      queryParams.addAll(_queryParams('', 'size', size));
    }
    if (sort != null) {
      queryParams.addAll(_queryParams('multi', 'sort', sort));
    }
    if (source_ != null) {
      queryParams.addAll(_queryParams('multi', '_source', source_));
    }
    if (sourceExcludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_excludes', sourceExcludes));
    }
    if (sourceIncludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_includes', sourceIncludes));
    }
    if (terminateAfter != null) {
      queryParams.addAll(_queryParams('', 'terminate_after', terminateAfter));
    }
    if (stats != null) {
      queryParams.addAll(_queryParams('multi', 'stats', stats));
    }
    if (suggestField != null) {
      queryParams.addAll(_queryParams('', 'suggest_field', suggestField));
    }
    if (suggestMode != null) {
      queryParams.addAll(_queryParams('', 'suggest_mode', suggestMode));
    }
    if (suggestSize != null) {
      queryParams.addAll(_queryParams('', 'suggest_size', suggestSize));
    }
    if (suggestText != null) {
      queryParams.addAll(_queryParams('', 'suggest_text', suggestText));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (trackScores != null) {
      queryParams.addAll(_queryParams('', 'track_scores', trackScores));
    }
    if (trackTotalHits != null) {
      queryParams.addAll(_queryParams('', 'track_total_hits', trackTotalHits));
    }
    if (allowPartialSearchResults != null) {
      queryParams.addAll(_queryParams(
          '', 'allow_partial_search_results', allowPartialSearchResults));
    }
    if (typedKeys != null) {
      queryParams.addAll(_queryParams('', 'typed_keys', typedKeys));
    }
    if (version != null) {
      queryParams.addAll(_queryParams('', 'version', version));
    }
    if (seqNoPrimaryTerm != null) {
      queryParams
          .addAll(_queryParams('', 'seq_no_primary_term', seqNoPrimaryTerm));
    }
    if (requestCache != null) {
      queryParams.addAll(_queryParams('', 'request_cache', requestCache));
    }
    if (batchedReduceSize != null) {
      queryParams
          .addAll(_queryParams('', 'batched_reduce_size', batchedReduceSize));
    }
    if (maxConcurrentShardRequests != null) {
      queryParams.addAll(_queryParams(
          '', 'max_concurrent_shard_requests', maxConcurrentShardRequests));
    }
    if (preFilterShardSize != null) {
      queryParams.addAll(
          _queryParams('', 'pre_filter_shard_size', preFilterShardSize));
    }
    if (restTotalHitsAsInt != null) {
      queryParams.addAll(
          _queryParams('', 'rest_total_hits_as_int', restTotalHitsAsInt));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns results matching a query.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcard and prefix queries should be analyzed.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The field to use as default where no field prefix is given in the query string.
  ///
  /// * [bool] explain:
  ///   Specify whether to return detailed information about score computation as part of a hit.
  ///
  /// * [List<String>] storedFields:
  ///   Comma-separated list of stored fields to return.
  ///
  /// * [List<String>] docvalueFields:
  ///   Comma-separated list of fields to return as the docvalue representation of a field for each hit.
  ///
  /// * [int] from:
  ///   Starting offset.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] ignoreThrottled:
  ///   Whether specified concrete, expanded or aliased indices should be ignored when throttled.
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [List<String>] routing:
  ///   Comma-separated list of specific routing values.
  ///
  /// * [String] scroll:
  ///   Specify how long a consistent view of the index should be maintained for scrolled search.
  ///
  /// * [SearchType] searchType:
  ///   Search operation type.
  ///
  /// * [int] size:
  ///   Number of hits to return.
  ///
  /// * [List<String>] sort:
  ///   Comma-separated list of <field>:<direction> pairs.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  ///
  /// * [int] terminateAfter:
  ///   The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
  ///
  /// * [List<String>] stats:
  ///   Specific 'tag' of the request for logging and statistical purposes.
  ///
  /// * [String] suggestField:
  ///   Specify which field to use for suggestions.
  ///
  /// * [SuggestMode] suggestMode:
  ///   Specify suggest mode.
  ///
  /// * [int] suggestSize:
  ///   How many suggestions to return in response.
  ///
  /// * [String] suggestText:
  ///   The source text for which the suggestions should be returned.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] trackScores:
  ///   Whether to calculate and return scores even if they are not used for sorting.
  ///
  /// * [bool] trackTotalHits:
  ///   Indicate if the number of documents that match the query should be tracked.
  ///
  /// * [bool] allowPartialSearchResults:
  ///   Indicate if an error should be returned if there is a partial search failure or timeout.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [bool] version:
  ///   Whether to return document version as part of a hit.
  ///
  /// * [bool] seqNoPrimaryTerm:
  ///   Specify whether to return sequence number and primary term of the last modification of each hit.
  ///
  /// * [bool] requestCache:
  ///   Specify if request cache should be used for this request or not, defaults to index level setting.
  ///
  /// * [int] batchedReduceSize:
  ///   The number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.
  ///
  /// * [int] maxConcurrentShardRequests:
  ///   The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
  ///
  /// * [int] preFilterShardSize:
  ///   Threshold that enforces a pre-filter round-trip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter round-trip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [SearchBodyParams] searchBodyParams:
  Future<SearchPostWithIndexResponseContent?> searchPostWithIndex(
    String index, {
    String? analyzer,
    bool? analyzeWildcard,
    bool? ccsMinimizeRoundtrips,
    DefaultOperator? defaultOperator,
    String? df,
    bool? explain,
    List<String>? storedFields,
    List<String>? docvalueFields,
    int? from,
    bool? ignoreUnavailable,
    bool? ignoreThrottled,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    bool? lenient,
    String? preference,
    String? q,
    List<String>? routing,
    String? scroll,
    SearchType? searchType,
    int? size,
    List<String>? sort,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    int? terminateAfter,
    List<String>? stats,
    String? suggestField,
    SuggestMode? suggestMode,
    int? suggestSize,
    String? suggestText,
    String? timeout,
    bool? trackScores,
    bool? trackTotalHits,
    bool? allowPartialSearchResults,
    bool? typedKeys,
    bool? version,
    bool? seqNoPrimaryTerm,
    bool? requestCache,
    int? batchedReduceSize,
    int? maxConcurrentShardRequests,
    int? preFilterShardSize,
    bool? restTotalHitsAsInt,
    SearchBodyParams? searchBodyParams,
  }) async {
    final response = await searchPostWithIndexWithHttpInfo(
      index,
      analyzer: analyzer,
      analyzeWildcard: analyzeWildcard,
      ccsMinimizeRoundtrips: ccsMinimizeRoundtrips,
      defaultOperator: defaultOperator,
      df: df,
      explain: explain,
      storedFields: storedFields,
      docvalueFields: docvalueFields,
      from: from,
      ignoreUnavailable: ignoreUnavailable,
      ignoreThrottled: ignoreThrottled,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      lenient: lenient,
      preference: preference,
      q: q,
      routing: routing,
      scroll: scroll,
      searchType: searchType,
      size: size,
      sort: sort,
      source_: source_,
      sourceExcludes: sourceExcludes,
      sourceIncludes: sourceIncludes,
      terminateAfter: terminateAfter,
      stats: stats,
      suggestField: suggestField,
      suggestMode: suggestMode,
      suggestSize: suggestSize,
      suggestText: suggestText,
      timeout: timeout,
      trackScores: trackScores,
      trackTotalHits: trackTotalHits,
      allowPartialSearchResults: allowPartialSearchResults,
      typedKeys: typedKeys,
      version: version,
      seqNoPrimaryTerm: seqNoPrimaryTerm,
      requestCache: requestCache,
      batchedReduceSize: batchedReduceSize,
      maxConcurrentShardRequests: maxConcurrentShardRequests,
      preFilterShardSize: preFilterShardSize,
      restTotalHitsAsInt: restTotalHitsAsInt,
      searchBodyParams: searchBodyParams,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'SearchPostWithIndexResponseContent',
      ) as SearchPostWithIndexResponseContent;
    }
    return null;
  }

  /// Returns information about the indices and shards that a search request would be executed against.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<Response> searchShardsGetWithHttpInfo({
    String? preference,
    String? routing,
    bool? local,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_search_shards';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about the indices and shards that a search request would be executed against.
  ///
  /// Parameters:
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<void> searchShardsGet({
    String? preference,
    String? routing,
    bool? local,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    final response = await searchShardsGetWithHttpInfo(
      preference: preference,
      routing: routing,
      local: local,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about the indices and shards that a search request would be executed against.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<Response> searchShardsGetWithIndexWithHttpInfo(
    String index, {
    String? preference,
    String? routing,
    bool? local,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_search_shards'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about the indices and shards that a search request would be executed against.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<void> searchShardsGetWithIndex(
    String index, {
    String? preference,
    String? routing,
    bool? local,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    final response = await searchShardsGetWithIndexWithHttpInfo(
      index,
      preference: preference,
      routing: routing,
      local: local,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about the indices and shards that a search request would be executed against.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<Response> searchShardsPostWithHttpInfo({
    String? preference,
    String? routing,
    bool? local,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_search_shards';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about the indices and shards that a search request would be executed against.
  ///
  /// Parameters:
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<void> searchShardsPost({
    String? preference,
    String? routing,
    bool? local,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    final response = await searchShardsPostWithHttpInfo(
      preference: preference,
      routing: routing,
      local: local,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about the indices and shards that a search request would be executed against.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<Response> searchShardsPostWithIndexWithHttpInfo(
    String index, {
    String? preference,
    String? routing,
    bool? local,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_search_shards'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about the indices and shards that a search request would be executed against.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  Future<void> searchShardsPostWithIndex(
    String index, {
    String? preference,
    String? routing,
    bool? local,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
  }) async {
    final response = await searchShardsPostWithIndexWithHttpInfo(
      index,
      preference: preference,
      routing: routing,
      local: local,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to use the Mustache language to pre-render a search definition.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] ignoreThrottled:
  ///   Whether specified concrete, expanded or aliased indices should be ignored when throttled.
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [List<String>] routing:
  ///   Comma-separated list of specific routing values.
  ///
  /// * [String] scroll:
  ///   Specify how long a consistent view of the index should be maintained for scrolled search.
  ///
  /// * [SearchTypeMulti] searchType:
  ///   Search operation type.
  ///
  /// * [bool] explain:
  ///   Specify whether to return detailed information about score computation as part of a hit.
  ///
  /// * [bool] profile:
  ///   Specify whether to profile the query execution.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  Future<Response> searchTemplateGetWithHttpInfo({
    bool? ignoreUnavailable,
    bool? ignoreThrottled,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    String? preference,
    List<String>? routing,
    String? scroll,
    SearchTypeMulti? searchType,
    bool? explain,
    bool? profile,
    bool? typedKeys,
    bool? restTotalHitsAsInt,
    bool? ccsMinimizeRoundtrips,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_search/template';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (ignoreThrottled != null) {
      queryParams.addAll(_queryParams('', 'ignore_throttled', ignoreThrottled));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('multi', 'routing', routing));
    }
    if (scroll != null) {
      queryParams.addAll(_queryParams('', 'scroll', scroll));
    }
    if (searchType != null) {
      queryParams.addAll(_queryParams('', 'search_type', searchType));
    }
    if (explain != null) {
      queryParams.addAll(_queryParams('', 'explain', explain));
    }
    if (profile != null) {
      queryParams.addAll(_queryParams('', 'profile', profile));
    }
    if (typedKeys != null) {
      queryParams.addAll(_queryParams('', 'typed_keys', typedKeys));
    }
    if (restTotalHitsAsInt != null) {
      queryParams.addAll(
          _queryParams('', 'rest_total_hits_as_int', restTotalHitsAsInt));
    }
    if (ccsMinimizeRoundtrips != null) {
      queryParams.addAll(
          _queryParams('', 'ccs_minimize_roundtrips', ccsMinimizeRoundtrips));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to use the Mustache language to pre-render a search definition.
  ///
  /// Parameters:
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] ignoreThrottled:
  ///   Whether specified concrete, expanded or aliased indices should be ignored when throttled.
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [List<String>] routing:
  ///   Comma-separated list of specific routing values.
  ///
  /// * [String] scroll:
  ///   Specify how long a consistent view of the index should be maintained for scrolled search.
  ///
  /// * [SearchTypeMulti] searchType:
  ///   Search operation type.
  ///
  /// * [bool] explain:
  ///   Specify whether to return detailed information about score computation as part of a hit.
  ///
  /// * [bool] profile:
  ///   Specify whether to profile the query execution.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  Future<void> searchTemplateGet({
    bool? ignoreUnavailable,
    bool? ignoreThrottled,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    String? preference,
    List<String>? routing,
    String? scroll,
    SearchTypeMulti? searchType,
    bool? explain,
    bool? profile,
    bool? typedKeys,
    bool? restTotalHitsAsInt,
    bool? ccsMinimizeRoundtrips,
  }) async {
    final response = await searchTemplateGetWithHttpInfo(
      ignoreUnavailable: ignoreUnavailable,
      ignoreThrottled: ignoreThrottled,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      preference: preference,
      routing: routing,
      scroll: scroll,
      searchType: searchType,
      explain: explain,
      profile: profile,
      typedKeys: typedKeys,
      restTotalHitsAsInt: restTotalHitsAsInt,
      ccsMinimizeRoundtrips: ccsMinimizeRoundtrips,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to use the Mustache language to pre-render a search definition.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] ignoreThrottled:
  ///   Whether specified concrete, expanded or aliased indices should be ignored when throttled.
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [List<String>] routing:
  ///   Comma-separated list of specific routing values.
  ///
  /// * [String] scroll:
  ///   Specify how long a consistent view of the index should be maintained for scrolled search.
  ///
  /// * [SearchTypeMulti] searchType:
  ///   Search operation type.
  ///
  /// * [bool] explain:
  ///   Specify whether to return detailed information about score computation as part of a hit.
  ///
  /// * [bool] profile:
  ///   Specify whether to profile the query execution.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  Future<Response> searchTemplateGetWithIndexWithHttpInfo(
    String index, {
    bool? ignoreUnavailable,
    bool? ignoreThrottled,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    String? preference,
    List<String>? routing,
    String? scroll,
    SearchTypeMulti? searchType,
    bool? explain,
    bool? profile,
    bool? typedKeys,
    bool? restTotalHitsAsInt,
    bool? ccsMinimizeRoundtrips,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_search/template'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (ignoreThrottled != null) {
      queryParams.addAll(_queryParams('', 'ignore_throttled', ignoreThrottled));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('multi', 'routing', routing));
    }
    if (scroll != null) {
      queryParams.addAll(_queryParams('', 'scroll', scroll));
    }
    if (searchType != null) {
      queryParams.addAll(_queryParams('', 'search_type', searchType));
    }
    if (explain != null) {
      queryParams.addAll(_queryParams('', 'explain', explain));
    }
    if (profile != null) {
      queryParams.addAll(_queryParams('', 'profile', profile));
    }
    if (typedKeys != null) {
      queryParams.addAll(_queryParams('', 'typed_keys', typedKeys));
    }
    if (restTotalHitsAsInt != null) {
      queryParams.addAll(
          _queryParams('', 'rest_total_hits_as_int', restTotalHitsAsInt));
    }
    if (ccsMinimizeRoundtrips != null) {
      queryParams.addAll(
          _queryParams('', 'ccs_minimize_roundtrips', ccsMinimizeRoundtrips));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to use the Mustache language to pre-render a search definition.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] ignoreThrottled:
  ///   Whether specified concrete, expanded or aliased indices should be ignored when throttled.
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [List<String>] routing:
  ///   Comma-separated list of specific routing values.
  ///
  /// * [String] scroll:
  ///   Specify how long a consistent view of the index should be maintained for scrolled search.
  ///
  /// * [SearchTypeMulti] searchType:
  ///   Search operation type.
  ///
  /// * [bool] explain:
  ///   Specify whether to return detailed information about score computation as part of a hit.
  ///
  /// * [bool] profile:
  ///   Specify whether to profile the query execution.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  Future<void> searchTemplateGetWithIndex(
    String index, {
    bool? ignoreUnavailable,
    bool? ignoreThrottled,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    String? preference,
    List<String>? routing,
    String? scroll,
    SearchTypeMulti? searchType,
    bool? explain,
    bool? profile,
    bool? typedKeys,
    bool? restTotalHitsAsInt,
    bool? ccsMinimizeRoundtrips,
  }) async {
    final response = await searchTemplateGetWithIndexWithHttpInfo(
      index,
      ignoreUnavailable: ignoreUnavailable,
      ignoreThrottled: ignoreThrottled,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      preference: preference,
      routing: routing,
      scroll: scroll,
      searchType: searchType,
      explain: explain,
      profile: profile,
      typedKeys: typedKeys,
      restTotalHitsAsInt: restTotalHitsAsInt,
      ccsMinimizeRoundtrips: ccsMinimizeRoundtrips,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to use the Mustache language to pre-render a search definition.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [Object] body (required):
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] ignoreThrottled:
  ///   Whether specified concrete, expanded or aliased indices should be ignored when throttled.
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [List<String>] routing:
  ///   Comma-separated list of specific routing values.
  ///
  /// * [String] scroll:
  ///   Specify how long a consistent view of the index should be maintained for scrolled search.
  ///
  /// * [SearchTypeMulti] searchType:
  ///   Search operation type.
  ///
  /// * [bool] explain:
  ///   Specify whether to return detailed information about score computation as part of a hit.
  ///
  /// * [bool] profile:
  ///   Specify whether to profile the query execution.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  Future<Response> searchTemplatePostWithHttpInfo(
    Object body, {
    bool? ignoreUnavailable,
    bool? ignoreThrottled,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    String? preference,
    List<String>? routing,
    String? scroll,
    SearchTypeMulti? searchType,
    bool? explain,
    bool? profile,
    bool? typedKeys,
    bool? restTotalHitsAsInt,
    bool? ccsMinimizeRoundtrips,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_search/template';

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (ignoreThrottled != null) {
      queryParams.addAll(_queryParams('', 'ignore_throttled', ignoreThrottled));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('multi', 'routing', routing));
    }
    if (scroll != null) {
      queryParams.addAll(_queryParams('', 'scroll', scroll));
    }
    if (searchType != null) {
      queryParams.addAll(_queryParams('', 'search_type', searchType));
    }
    if (explain != null) {
      queryParams.addAll(_queryParams('', 'explain', explain));
    }
    if (profile != null) {
      queryParams.addAll(_queryParams('', 'profile', profile));
    }
    if (typedKeys != null) {
      queryParams.addAll(_queryParams('', 'typed_keys', typedKeys));
    }
    if (restTotalHitsAsInt != null) {
      queryParams.addAll(
          _queryParams('', 'rest_total_hits_as_int', restTotalHitsAsInt));
    }
    if (ccsMinimizeRoundtrips != null) {
      queryParams.addAll(
          _queryParams('', 'ccs_minimize_roundtrips', ccsMinimizeRoundtrips));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to use the Mustache language to pre-render a search definition.
  ///
  /// Parameters:
  ///
  /// * [Object] body (required):
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] ignoreThrottled:
  ///   Whether specified concrete, expanded or aliased indices should be ignored when throttled.
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [List<String>] routing:
  ///   Comma-separated list of specific routing values.
  ///
  /// * [String] scroll:
  ///   Specify how long a consistent view of the index should be maintained for scrolled search.
  ///
  /// * [SearchTypeMulti] searchType:
  ///   Search operation type.
  ///
  /// * [bool] explain:
  ///   Specify whether to return detailed information about score computation as part of a hit.
  ///
  /// * [bool] profile:
  ///   Specify whether to profile the query execution.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  Future<void> searchTemplatePost(
    Object body, {
    bool? ignoreUnavailable,
    bool? ignoreThrottled,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    String? preference,
    List<String>? routing,
    String? scroll,
    SearchTypeMulti? searchType,
    bool? explain,
    bool? profile,
    bool? typedKeys,
    bool? restTotalHitsAsInt,
    bool? ccsMinimizeRoundtrips,
  }) async {
    final response = await searchTemplatePostWithHttpInfo(
      body,
      ignoreUnavailable: ignoreUnavailable,
      ignoreThrottled: ignoreThrottled,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      preference: preference,
      routing: routing,
      scroll: scroll,
      searchType: searchType,
      explain: explain,
      profile: profile,
      typedKeys: typedKeys,
      restTotalHitsAsInt: restTotalHitsAsInt,
      ccsMinimizeRoundtrips: ccsMinimizeRoundtrips,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Allows to use the Mustache language to pre-render a search definition.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [Object] body (required):
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] ignoreThrottled:
  ///   Whether specified concrete, expanded or aliased indices should be ignored when throttled.
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [List<String>] routing:
  ///   Comma-separated list of specific routing values.
  ///
  /// * [String] scroll:
  ///   Specify how long a consistent view of the index should be maintained for scrolled search.
  ///
  /// * [SearchTypeMulti] searchType:
  ///   Search operation type.
  ///
  /// * [bool] explain:
  ///   Specify whether to return detailed information about score computation as part of a hit.
  ///
  /// * [bool] profile:
  ///   Specify whether to profile the query execution.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  Future<Response> searchTemplatePostWithIndexWithHttpInfo(
    String index,
    Object body, {
    bool? ignoreUnavailable,
    bool? ignoreThrottled,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    String? preference,
    List<String>? routing,
    String? scroll,
    SearchTypeMulti? searchType,
    bool? explain,
    bool? profile,
    bool? typedKeys,
    bool? restTotalHitsAsInt,
    bool? ccsMinimizeRoundtrips,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_search/template'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (ignoreThrottled != null) {
      queryParams.addAll(_queryParams('', 'ignore_throttled', ignoreThrottled));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('multi', 'routing', routing));
    }
    if (scroll != null) {
      queryParams.addAll(_queryParams('', 'scroll', scroll));
    }
    if (searchType != null) {
      queryParams.addAll(_queryParams('', 'search_type', searchType));
    }
    if (explain != null) {
      queryParams.addAll(_queryParams('', 'explain', explain));
    }
    if (profile != null) {
      queryParams.addAll(_queryParams('', 'profile', profile));
    }
    if (typedKeys != null) {
      queryParams.addAll(_queryParams('', 'typed_keys', typedKeys));
    }
    if (restTotalHitsAsInt != null) {
      queryParams.addAll(
          _queryParams('', 'rest_total_hits_as_int', restTotalHitsAsInt));
    }
    if (ccsMinimizeRoundtrips != null) {
      queryParams.addAll(
          _queryParams('', 'ccs_minimize_roundtrips', ccsMinimizeRoundtrips));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Allows to use the Mustache language to pre-render a search definition.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [Object] body (required):
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] ignoreThrottled:
  ///   Whether specified concrete, expanded or aliased indices should be ignored when throttled.
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [List<String>] routing:
  ///   Comma-separated list of specific routing values.
  ///
  /// * [String] scroll:
  ///   Specify how long a consistent view of the index should be maintained for scrolled search.
  ///
  /// * [SearchTypeMulti] searchType:
  ///   Search operation type.
  ///
  /// * [bool] explain:
  ///   Specify whether to return detailed information about score computation as part of a hit.
  ///
  /// * [bool] profile:
  ///   Specify whether to profile the query execution.
  ///
  /// * [bool] typedKeys:
  ///   Specify whether aggregation and suggester names should be prefixed by their respective types in the response.
  ///
  /// * [bool] restTotalHitsAsInt:
  ///   Indicates whether hits.total should be rendered as an integer or an object in the rest search response.
  ///
  /// * [bool] ccsMinimizeRoundtrips:
  ///   Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution.
  Future<void> searchTemplatePostWithIndex(
    String index,
    Object body, {
    bool? ignoreUnavailable,
    bool? ignoreThrottled,
    bool? allowNoIndices,
    ExpandWildcards? expandWildcards,
    String? preference,
    List<String>? routing,
    String? scroll,
    SearchTypeMulti? searchType,
    bool? explain,
    bool? profile,
    bool? typedKeys,
    bool? restTotalHitsAsInt,
    bool? ccsMinimizeRoundtrips,
  }) async {
    final response = await searchTemplatePostWithIndexWithHttpInfo(
      index,
      body,
      ignoreUnavailable: ignoreUnavailable,
      ignoreThrottled: ignoreThrottled,
      allowNoIndices: allowNoIndices,
      expandWildcards: expandWildcards,
      preference: preference,
      routing: routing,
      scroll: scroll,
      searchType: searchType,
      explain: explain,
      profile: profile,
      typedKeys: typedKeys,
      restTotalHitsAsInt: restTotalHitsAsInt,
      ccsMinimizeRoundtrips: ccsMinimizeRoundtrips,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Checks to see if the Security plugin is up and running.
  ///
  /// Note: This method returns the HTTP [Response].
  Future<Response> securityHealthWithHttpInfo() async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/health';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Checks to see if the Security plugin is up and running.
  Future<SecurityHealthResponseContent?> securityHealth() async {
    final response = await securityHealthWithHttpInfo();
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'SecurityHealthResponseContent',
      ) as SecurityHealthResponseContent;
    }
    return null;
  }

  /// Removes stale data from repository.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] repository (required):
  ///   Repository name.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<Response> snapshotCleanupRepositoryWithHttpInfo(
    String repository, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? timeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_snapshot/{repository}/_cleanup'
        .replaceAll('{repository}', repository);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Removes stale data from repository.
  ///
  /// Parameters:
  ///
  /// * [String] repository (required):
  ///   Repository name.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<void> snapshotCleanupRepository(
    String repository, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? timeout,
  }) async {
    final response = await snapshotCleanupRepositoryWithHttpInfo(
      repository,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      timeout: timeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Clones indices from one snapshot into another snapshot in the same repository.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] repository (required):
  ///   Repository name.
  ///
  /// * [String] snapshot (required):
  ///   Snapshot name.
  ///
  /// * [String] targetSnapshot (required):
  ///   The name of the cloned snapshot to create.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<Response> snapshotCloneWithHttpInfo(
    String repository,
    String snapshot,
    String targetSnapshot,
    Object body, {
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_snapshot/{repository}/{snapshot}/_clone/{target_snapshot}'
        .replaceAll('{repository}', repository)
        .replaceAll('{snapshot}', snapshot)
        .replaceAll('{target_snapshot}', targetSnapshot);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Clones indices from one snapshot into another snapshot in the same repository.
  ///
  /// Parameters:
  ///
  /// * [String] repository (required):
  ///   Repository name.
  ///
  /// * [String] snapshot (required):
  ///   Snapshot name.
  ///
  /// * [String] targetSnapshot (required):
  ///   The name of the cloned snapshot to create.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<void> snapshotClone(
    String repository,
    String snapshot,
    String targetSnapshot,
    Object body, {
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    final response = await snapshotCloneWithHttpInfo(
      repository,
      snapshot,
      targetSnapshot,
      body,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Creates a snapshot in a repository.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] repository (required):
  ///   Repository name.
  ///
  /// * [String] snapshot (required):
  ///   Snapshot name.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] waitForCompletion:
  ///   Should this request wait until the operation has completed before returning.
  ///
  /// * [Object] body:
  Future<Response> snapshotCreatePostWithHttpInfo(
    String repository,
    String snapshot, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? waitForCompletion,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_snapshot/{repository}/{snapshot}'
        .replaceAll('{repository}', repository)
        .replaceAll('{snapshot}', snapshot);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (waitForCompletion != null) {
      queryParams
          .addAll(_queryParams('', 'wait_for_completion', waitForCompletion));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates a snapshot in a repository.
  ///
  /// Parameters:
  ///
  /// * [String] repository (required):
  ///   Repository name.
  ///
  /// * [String] snapshot (required):
  ///   Snapshot name.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] waitForCompletion:
  ///   Should this request wait until the operation has completed before returning.
  ///
  /// * [Object] body:
  Future<void> snapshotCreatePost(
    String repository,
    String snapshot, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? waitForCompletion,
    Object? body,
  }) async {
    final response = await snapshotCreatePostWithHttpInfo(
      repository,
      snapshot,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      waitForCompletion: waitForCompletion,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Creates a snapshot in a repository.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] repository (required):
  ///   Repository name.
  ///
  /// * [String] snapshot (required):
  ///   Snapshot name.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] waitForCompletion:
  ///   Should this request wait until the operation has completed before returning.
  ///
  /// * [Object] body:
  Future<Response> snapshotCreatePutWithHttpInfo(
    String repository,
    String snapshot, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? waitForCompletion,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_snapshot/{repository}/{snapshot}'
        .replaceAll('{repository}', repository)
        .replaceAll('{snapshot}', snapshot);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (waitForCompletion != null) {
      queryParams
          .addAll(_queryParams('', 'wait_for_completion', waitForCompletion));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates a snapshot in a repository.
  ///
  /// Parameters:
  ///
  /// * [String] repository (required):
  ///   Repository name.
  ///
  /// * [String] snapshot (required):
  ///   Snapshot name.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] waitForCompletion:
  ///   Should this request wait until the operation has completed before returning.
  ///
  /// * [Object] body:
  Future<void> snapshotCreatePut(
    String repository,
    String snapshot, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? waitForCompletion,
    Object? body,
  }) async {
    final response = await snapshotCreatePutWithHttpInfo(
      repository,
      snapshot,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      waitForCompletion: waitForCompletion,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Creates a repository.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] repository (required):
  ///   Repository name.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] verify:
  ///   Whether to verify the repository after creation.
  Future<Response> snapshotCreateRepositoryPostWithHttpInfo(
    String repository,
    Object body, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? timeout,
    bool? verify,
  }) async {
    // ignore: prefer_const_declarations
    final path =
        r'/_snapshot/{repository}'.replaceAll('{repository}', repository);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (verify != null) {
      queryParams.addAll(_queryParams('', 'verify', verify));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates a repository.
  ///
  /// Parameters:
  ///
  /// * [String] repository (required):
  ///   Repository name.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] verify:
  ///   Whether to verify the repository after creation.
  Future<void> snapshotCreateRepositoryPost(
    String repository,
    Object body, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? timeout,
    bool? verify,
  }) async {
    final response = await snapshotCreateRepositoryPostWithHttpInfo(
      repository,
      body,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      timeout: timeout,
      verify: verify,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Creates a repository.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] repository (required):
  ///   Repository name.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] verify:
  ///   Whether to verify the repository after creation.
  Future<Response> snapshotCreateRepositoryPutWithHttpInfo(
    String repository,
    Object body, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? timeout,
    bool? verify,
  }) async {
    // ignore: prefer_const_declarations
    final path =
        r'/_snapshot/{repository}'.replaceAll('{repository}', repository);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (verify != null) {
      queryParams.addAll(_queryParams('', 'verify', verify));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Creates a repository.
  ///
  /// Parameters:
  ///
  /// * [String] repository (required):
  ///   Repository name.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [bool] verify:
  ///   Whether to verify the repository after creation.
  Future<void> snapshotCreateRepositoryPut(
    String repository,
    Object body, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? timeout,
    bool? verify,
  }) async {
    final response = await snapshotCreateRepositoryPutWithHttpInfo(
      repository,
      body,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      timeout: timeout,
      verify: verify,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Deletes a snapshot.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] repository (required):
  ///   Repository name.
  ///
  /// * [String] snapshot (required):
  ///   Snapshot name.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<Response> snapshotDeleteWithHttpInfo(
    String repository,
    String snapshot, {
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_snapshot/{repository}/{snapshot}'
        .replaceAll('{repository}', repository)
        .replaceAll('{snapshot}', snapshot);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'DELETE',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Deletes a snapshot.
  ///
  /// Parameters:
  ///
  /// * [String] repository (required):
  ///   Repository name.
  ///
  /// * [String] snapshot (required):
  ///   Snapshot name.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  Future<void> snapshotDelete(
    String repository,
    String snapshot, {
    String? masterTimeout,
    String? clusterManagerTimeout,
  }) async {
    final response = await snapshotDeleteWithHttpInfo(
      repository,
      snapshot,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Deletes a repository.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] repository (required):
  ///   Name of the snapshot repository to unregister. Wildcard (`*`) patterns are supported.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<Response> snapshotDeleteRepositoryWithHttpInfo(
    String repository, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? timeout,
  }) async {
    // ignore: prefer_const_declarations
    final path =
        r'/_snapshot/{repository}'.replaceAll('{repository}', repository);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'DELETE',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Deletes a repository.
  ///
  /// Parameters:
  ///
  /// * [String] repository (required):
  ///   Name of the snapshot repository to unregister. Wildcard (`*`) patterns are supported.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<void> snapshotDeleteRepository(
    String repository, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? timeout,
  }) async {
    final response = await snapshotDeleteRepositoryWithHttpInfo(
      repository,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      timeout: timeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about a snapshot.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] repository (required):
  ///   Repository name.
  ///
  /// * [String] snapshot (required):
  ///   Comma-separated list of snapshot names.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown.
  ///
  /// * [bool] verbose:
  ///   Whether to show verbose snapshot info or only show the basic info found in the repository index blob.
  Future<Response> snapshotGetWithHttpInfo(
    String repository,
    String snapshot, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? ignoreUnavailable,
    bool? verbose,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_snapshot/{repository}/{snapshot}'
        .replaceAll('{repository}', repository)
        .replaceAll('{snapshot}', snapshot);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (verbose != null) {
      queryParams.addAll(_queryParams('', 'verbose', verbose));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about a snapshot.
  ///
  /// Parameters:
  ///
  /// * [String] repository (required):
  ///   Repository name.
  ///
  /// * [String] snapshot (required):
  ///   Comma-separated list of snapshot names.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown.
  ///
  /// * [bool] verbose:
  ///   Whether to show verbose snapshot info or only show the basic info found in the repository index blob.
  Future<void> snapshotGet(
    String repository,
    String snapshot, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? ignoreUnavailable,
    bool? verbose,
  }) async {
    final response = await snapshotGetWithHttpInfo(
      repository,
      snapshot,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      ignoreUnavailable: ignoreUnavailable,
      verbose: verbose,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about a repository.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<Response> snapshotGetRepositoryWithHttpInfo({
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? local,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_snapshot';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about a repository.
  ///
  /// Parameters:
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<void> snapshotGetRepository({
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? local,
  }) async {
    final response = await snapshotGetRepositoryWithHttpInfo(
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      local: local,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about a repository.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] repository (required):
  ///   Comma-separated list of repository names.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<Response> snapshotGetRepositoryWithRepositoryWithHttpInfo(
    String repository, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? local,
  }) async {
    // ignore: prefer_const_declarations
    final path =
        r'/_snapshot/{repository}'.replaceAll('{repository}', repository);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (local != null) {
      queryParams.addAll(_queryParams('', 'local', local));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about a repository.
  ///
  /// Parameters:
  ///
  /// * [String] repository (required):
  ///   Comma-separated list of repository names.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] local:
  ///   Return local information, do not retrieve the state from cluster-manager node.
  Future<void> snapshotGetRepositoryWithRepository(
    String repository, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? local,
  }) async {
    final response = await snapshotGetRepositoryWithRepositoryWithHttpInfo(
      repository,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      local: local,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Restores a snapshot.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] repository (required):
  ///   Repository name.
  ///
  /// * [String] snapshot (required):
  ///   Snapshot name.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] waitForCompletion:
  ///   Should this request wait until the operation has completed before returning.
  ///
  /// * [Object] body:
  Future<Response> snapshotRestoreWithHttpInfo(
    String repository,
    String snapshot, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? waitForCompletion,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_snapshot/{repository}/{snapshot}/_restore'
        .replaceAll('{repository}', repository)
        .replaceAll('{snapshot}', snapshot);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (waitForCompletion != null) {
      queryParams
          .addAll(_queryParams('', 'wait_for_completion', waitForCompletion));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Restores a snapshot.
  ///
  /// Parameters:
  ///
  /// * [String] repository (required):
  ///   Repository name.
  ///
  /// * [String] snapshot (required):
  ///   Snapshot name.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] waitForCompletion:
  ///   Should this request wait until the operation has completed before returning.
  ///
  /// * [Object] body:
  Future<void> snapshotRestore(
    String repository,
    String snapshot, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? waitForCompletion,
    Object? body,
  }) async {
    final response = await snapshotRestoreWithHttpInfo(
      repository,
      snapshot,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      waitForCompletion: waitForCompletion,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about the status of a snapshot.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown.
  Future<Response> snapshotStatusWithHttpInfo({
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? ignoreUnavailable,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_snapshot/_status';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about the status of a snapshot.
  ///
  /// Parameters:
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown.
  Future<void> snapshotStatus({
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? ignoreUnavailable,
  }) async {
    final response = await snapshotStatusWithHttpInfo(
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      ignoreUnavailable: ignoreUnavailable,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about the status of a snapshot.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] repository (required):
  ///   Repository name.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown.
  Future<Response> snapshotStatusWithRepositoryWithHttpInfo(
    String repository, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? ignoreUnavailable,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_snapshot/{repository}/_status'
        .replaceAll('{repository}', repository);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about the status of a snapshot.
  ///
  /// Parameters:
  ///
  /// * [String] repository (required):
  ///   Repository name.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown.
  Future<void> snapshotStatusWithRepository(
    String repository, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? ignoreUnavailable,
  }) async {
    final response = await snapshotStatusWithRepositoryWithHttpInfo(
      repository,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      ignoreUnavailable: ignoreUnavailable,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about the status of a snapshot.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] repository (required):
  ///   Repository name.
  ///
  /// * [String] snapshot (required):
  ///   Comma-separated list of snapshot names.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown.
  Future<Response> snapshotStatusWithRepositorySnapshotWithHttpInfo(
    String repository,
    String snapshot, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? ignoreUnavailable,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_snapshot/{repository}/{snapshot}/_status'
        .replaceAll('{repository}', repository)
        .replaceAll('{snapshot}', snapshot);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about the status of a snapshot.
  ///
  /// Parameters:
  ///
  /// * [String] repository (required):
  ///   Repository name.
  ///
  /// * [String] snapshot (required):
  ///   Comma-separated list of snapshot names.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown.
  Future<void> snapshotStatusWithRepositorySnapshot(
    String repository,
    String snapshot, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    bool? ignoreUnavailable,
  }) async {
    final response = await snapshotStatusWithRepositorySnapshotWithHttpInfo(
      repository,
      snapshot,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      ignoreUnavailable: ignoreUnavailable,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Verifies a repository.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] repository (required):
  ///   Repository name.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<Response> snapshotVerifyRepositoryWithHttpInfo(
    String repository, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? timeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_snapshot/{repository}/_verify'
        .replaceAll('{repository}', repository);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (masterTimeout != null) {
      queryParams.addAll(_queryParams('', 'master_timeout', masterTimeout));
    }
    if (clusterManagerTimeout != null) {
      queryParams.addAll(
          _queryParams('', 'cluster_manager_timeout', clusterManagerTimeout));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Verifies a repository.
  ///
  /// Parameters:
  ///
  /// * [String] repository (required):
  ///   Repository name.
  ///
  /// * [String] masterTimeout:
  ///   Operation timeout for connection to master node.
  ///
  /// * [String] clusterManagerTimeout:
  ///   Operation timeout for connection to cluster-manager node.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<void> snapshotVerifyRepository(
    String repository, {
    String? masterTimeout,
    String? clusterManagerTimeout,
    String? timeout,
  }) async {
    final response = await snapshotVerifyRepositoryWithHttpInfo(
      repository,
      masterTimeout: masterTimeout,
      clusterManagerTimeout: clusterManagerTimeout,
      timeout: timeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Cancels a task, if it can be cancelled through an API.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [List<String>] nodes:
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [List<String>] actions:
  ///   Comma-separated list of actions that should be cancelled. Leave empty to cancel all.
  ///
  /// * [String] parentTaskId:
  ///   Cancel tasks with specified parent task id (node_id:task_number). Set to -1 to cancel all.
  ///
  /// * [bool] waitForCompletion:
  ///   Should this request wait until the operation has completed before returning.
  Future<Response> tasksCancelWithHttpInfo({
    List<String>? nodes,
    List<String>? actions,
    String? parentTaskId,
    bool? waitForCompletion,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_tasks/_cancel';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (nodes != null) {
      queryParams.addAll(_queryParams('multi', 'nodes', nodes));
    }
    if (actions != null) {
      queryParams.addAll(_queryParams('multi', 'actions', actions));
    }
    if (parentTaskId != null) {
      queryParams.addAll(_queryParams('', 'parent_task_id', parentTaskId));
    }
    if (waitForCompletion != null) {
      queryParams
          .addAll(_queryParams('', 'wait_for_completion', waitForCompletion));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Cancels a task, if it can be cancelled through an API.
  ///
  /// Parameters:
  ///
  /// * [List<String>] nodes:
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [List<String>] actions:
  ///   Comma-separated list of actions that should be cancelled. Leave empty to cancel all.
  ///
  /// * [String] parentTaskId:
  ///   Cancel tasks with specified parent task id (node_id:task_number). Set to -1 to cancel all.
  ///
  /// * [bool] waitForCompletion:
  ///   Should this request wait until the operation has completed before returning.
  Future<void> tasksCancel({
    List<String>? nodes,
    List<String>? actions,
    String? parentTaskId,
    bool? waitForCompletion,
  }) async {
    final response = await tasksCancelWithHttpInfo(
      nodes: nodes,
      actions: actions,
      parentTaskId: parentTaskId,
      waitForCompletion: waitForCompletion,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Cancels a task, if it can be cancelled through an API.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] taskId (required):
  ///   Cancel the task with specified task id (node_id:task_number).
  ///
  /// * [List<String>] nodes:
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [List<String>] actions:
  ///   Comma-separated list of actions that should be cancelled. Leave empty to cancel all.
  ///
  /// * [String] parentTaskId:
  ///   Cancel tasks with specified parent task id (node_id:task_number). Set to -1 to cancel all.
  ///
  /// * [bool] waitForCompletion:
  ///   Should this request wait until the operation has completed before returning.
  Future<Response> tasksCancelWithTaskIdWithHttpInfo(
    String taskId, {
    List<String>? nodes,
    List<String>? actions,
    String? parentTaskId,
    bool? waitForCompletion,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_tasks/{task_id}/_cancel'.replaceAll('{task_id}', taskId);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (nodes != null) {
      queryParams.addAll(_queryParams('multi', 'nodes', nodes));
    }
    if (actions != null) {
      queryParams.addAll(_queryParams('multi', 'actions', actions));
    }
    if (parentTaskId != null) {
      queryParams.addAll(_queryParams('', 'parent_task_id', parentTaskId));
    }
    if (waitForCompletion != null) {
      queryParams
          .addAll(_queryParams('', 'wait_for_completion', waitForCompletion));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Cancels a task, if it can be cancelled through an API.
  ///
  /// Parameters:
  ///
  /// * [String] taskId (required):
  ///   Cancel the task with specified task id (node_id:task_number).
  ///
  /// * [List<String>] nodes:
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [List<String>] actions:
  ///   Comma-separated list of actions that should be cancelled. Leave empty to cancel all.
  ///
  /// * [String] parentTaskId:
  ///   Cancel tasks with specified parent task id (node_id:task_number). Set to -1 to cancel all.
  ///
  /// * [bool] waitForCompletion:
  ///   Should this request wait until the operation has completed before returning.
  Future<void> tasksCancelWithTaskId(
    String taskId, {
    List<String>? nodes,
    List<String>? actions,
    String? parentTaskId,
    bool? waitForCompletion,
  }) async {
    final response = await tasksCancelWithTaskIdWithHttpInfo(
      taskId,
      nodes: nodes,
      actions: actions,
      parentTaskId: parentTaskId,
      waitForCompletion: waitForCompletion,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information about a task.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] taskId (required):
  ///   Return the task with specified id (node_id:task_number).
  ///
  /// * [bool] waitForCompletion:
  ///   Should this request wait until the operation has completed before returning.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<Response> tasksGetWithHttpInfo(
    String taskId, {
    bool? waitForCompletion,
    String? timeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_tasks/{task_id}'.replaceAll('{task_id}', taskId);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (waitForCompletion != null) {
      queryParams
          .addAll(_queryParams('', 'wait_for_completion', waitForCompletion));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information about a task.
  ///
  /// Parameters:
  ///
  /// * [String] taskId (required):
  ///   Return the task with specified id (node_id:task_number).
  ///
  /// * [bool] waitForCompletion:
  ///   Should this request wait until the operation has completed before returning.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<void> tasksGet(
    String taskId, {
    bool? waitForCompletion,
    String? timeout,
  }) async {
    final response = await tasksGetWithHttpInfo(
      taskId,
      waitForCompletion: waitForCompletion,
      timeout: timeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns a list of tasks.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [List<String>] nodes:
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [List<String>] actions:
  ///   Comma-separated list of actions that should be returned. Leave empty to return all.
  ///
  /// * [bool] detailed:
  ///   Return detailed task information.
  ///
  /// * [String] parentTaskId:
  ///   Return tasks with specified parent task id (node_id:task_number). Set to -1 to return all.
  ///
  /// * [bool] waitForCompletion:
  ///   Should this request wait until the operation has completed before returning.
  ///
  /// * [GroupBy] groupBy:
  ///   Group tasks by nodes or parent/child relationships.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<Response> tasksListWithHttpInfo({
    List<String>? nodes,
    List<String>? actions,
    bool? detailed,
    String? parentTaskId,
    bool? waitForCompletion,
    GroupBy? groupBy,
    String? timeout,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_tasks';

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (nodes != null) {
      queryParams.addAll(_queryParams('multi', 'nodes', nodes));
    }
    if (actions != null) {
      queryParams.addAll(_queryParams('multi', 'actions', actions));
    }
    if (detailed != null) {
      queryParams.addAll(_queryParams('', 'detailed', detailed));
    }
    if (parentTaskId != null) {
      queryParams.addAll(_queryParams('', 'parent_task_id', parentTaskId));
    }
    if (waitForCompletion != null) {
      queryParams
          .addAll(_queryParams('', 'wait_for_completion', waitForCompletion));
    }
    if (groupBy != null) {
      queryParams.addAll(_queryParams('', 'group_by', groupBy));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns a list of tasks.
  ///
  /// Parameters:
  ///
  /// * [List<String>] nodes:
  ///   Comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes.
  ///
  /// * [List<String>] actions:
  ///   Comma-separated list of actions that should be returned. Leave empty to return all.
  ///
  /// * [bool] detailed:
  ///   Return detailed task information.
  ///
  /// * [String] parentTaskId:
  ///   Return tasks with specified parent task id (node_id:task_number). Set to -1 to return all.
  ///
  /// * [bool] waitForCompletion:
  ///   Should this request wait until the operation has completed before returning.
  ///
  /// * [GroupBy] groupBy:
  ///   Group tasks by nodes or parent/child relationships.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  Future<void> tasksList({
    List<String>? nodes,
    List<String>? actions,
    bool? detailed,
    String? parentTaskId,
    bool? waitForCompletion,
    GroupBy? groupBy,
    String? timeout,
  }) async {
    final response = await tasksListWithHttpInfo(
      nodes: nodes,
      actions: actions,
      detailed: detailed,
      parentTaskId: parentTaskId,
      waitForCompletion: waitForCompletion,
      groupBy: groupBy,
      timeout: timeout,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information and statistics about terms in the fields of a particular document.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   The index in which the document resides.
  ///
  /// * [bool] termStatistics:
  ///   Specifies if total term frequency and document frequency should be returned.
  ///
  /// * [bool] fieldStatistics:
  ///   Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields to return.
  ///
  /// * [bool] offsets:
  ///   Specifies if term offsets should be returned.
  ///
  /// * [bool] positions:
  ///   Specifies if term positions should be returned.
  ///
  /// * [bool] payloads:
  ///   Specifies if term payloads should be returned.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [bool] realtime:
  ///   Specifies if request is real-time as opposed to near-real-time.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  Future<Response> termvectorsGetWithHttpInfo(
    String index, {
    bool? termStatistics,
    bool? fieldStatistics,
    List<String>? fields,
    bool? offsets,
    bool? positions,
    bool? payloads,
    String? preference,
    String? routing,
    bool? realtime,
    int? version,
    VersionType? versionType,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_termvectors'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (termStatistics != null) {
      queryParams.addAll(_queryParams('', 'term_statistics', termStatistics));
    }
    if (fieldStatistics != null) {
      queryParams.addAll(_queryParams('', 'field_statistics', fieldStatistics));
    }
    if (fields != null) {
      queryParams.addAll(_queryParams('multi', 'fields', fields));
    }
    if (offsets != null) {
      queryParams.addAll(_queryParams('', 'offsets', offsets));
    }
    if (positions != null) {
      queryParams.addAll(_queryParams('', 'positions', positions));
    }
    if (payloads != null) {
      queryParams.addAll(_queryParams('', 'payloads', payloads));
    }
    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (realtime != null) {
      queryParams.addAll(_queryParams('', 'realtime', realtime));
    }
    if (version != null) {
      queryParams.addAll(_queryParams('', 'version', version));
    }
    if (versionType != null) {
      queryParams.addAll(_queryParams('', 'version_type', versionType));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information and statistics about terms in the fields of a particular document.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   The index in which the document resides.
  ///
  /// * [bool] termStatistics:
  ///   Specifies if total term frequency and document frequency should be returned.
  ///
  /// * [bool] fieldStatistics:
  ///   Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields to return.
  ///
  /// * [bool] offsets:
  ///   Specifies if term offsets should be returned.
  ///
  /// * [bool] positions:
  ///   Specifies if term positions should be returned.
  ///
  /// * [bool] payloads:
  ///   Specifies if term payloads should be returned.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [bool] realtime:
  ///   Specifies if request is real-time as opposed to near-real-time.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  Future<void> termvectorsGet(
    String index, {
    bool? termStatistics,
    bool? fieldStatistics,
    List<String>? fields,
    bool? offsets,
    bool? positions,
    bool? payloads,
    String? preference,
    String? routing,
    bool? realtime,
    int? version,
    VersionType? versionType,
  }) async {
    final response = await termvectorsGetWithHttpInfo(
      index,
      termStatistics: termStatistics,
      fieldStatistics: fieldStatistics,
      fields: fields,
      offsets: offsets,
      positions: positions,
      payloads: payloads,
      preference: preference,
      routing: routing,
      realtime: realtime,
      version: version,
      versionType: versionType,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information and statistics about terms in the fields of a particular document.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   The index in which the document resides.
  ///
  /// * [String] id (required):
  ///   Document ID. When not specified a doc param should be supplied.
  ///
  /// * [bool] termStatistics:
  ///   Specifies if total term frequency and document frequency should be returned.
  ///
  /// * [bool] fieldStatistics:
  ///   Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields to return.
  ///
  /// * [bool] offsets:
  ///   Specifies if term offsets should be returned.
  ///
  /// * [bool] positions:
  ///   Specifies if term positions should be returned.
  ///
  /// * [bool] payloads:
  ///   Specifies if term payloads should be returned.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [bool] realtime:
  ///   Specifies if request is real-time as opposed to near-real-time.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  Future<Response> termvectorsGetWithIdWithHttpInfo(
    String index,
    String id, {
    bool? termStatistics,
    bool? fieldStatistics,
    List<String>? fields,
    bool? offsets,
    bool? positions,
    bool? payloads,
    String? preference,
    String? routing,
    bool? realtime,
    int? version,
    VersionType? versionType,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_termvectors/{id}'
        .replaceAll('{index}', index)
        .replaceAll('{id}', id);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (termStatistics != null) {
      queryParams.addAll(_queryParams('', 'term_statistics', termStatistics));
    }
    if (fieldStatistics != null) {
      queryParams.addAll(_queryParams('', 'field_statistics', fieldStatistics));
    }
    if (fields != null) {
      queryParams.addAll(_queryParams('multi', 'fields', fields));
    }
    if (offsets != null) {
      queryParams.addAll(_queryParams('', 'offsets', offsets));
    }
    if (positions != null) {
      queryParams.addAll(_queryParams('', 'positions', positions));
    }
    if (payloads != null) {
      queryParams.addAll(_queryParams('', 'payloads', payloads));
    }
    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (realtime != null) {
      queryParams.addAll(_queryParams('', 'realtime', realtime));
    }
    if (version != null) {
      queryParams.addAll(_queryParams('', 'version', version));
    }
    if (versionType != null) {
      queryParams.addAll(_queryParams('', 'version_type', versionType));
    }

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'GET',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information and statistics about terms in the fields of a particular document.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   The index in which the document resides.
  ///
  /// * [String] id (required):
  ///   Document ID. When not specified a doc param should be supplied.
  ///
  /// * [bool] termStatistics:
  ///   Specifies if total term frequency and document frequency should be returned.
  ///
  /// * [bool] fieldStatistics:
  ///   Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields to return.
  ///
  /// * [bool] offsets:
  ///   Specifies if term offsets should be returned.
  ///
  /// * [bool] positions:
  ///   Specifies if term positions should be returned.
  ///
  /// * [bool] payloads:
  ///   Specifies if term payloads should be returned.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [bool] realtime:
  ///   Specifies if request is real-time as opposed to near-real-time.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  Future<void> termvectorsGetWithId(
    String index,
    String id, {
    bool? termStatistics,
    bool? fieldStatistics,
    List<String>? fields,
    bool? offsets,
    bool? positions,
    bool? payloads,
    String? preference,
    String? routing,
    bool? realtime,
    int? version,
    VersionType? versionType,
  }) async {
    final response = await termvectorsGetWithIdWithHttpInfo(
      index,
      id,
      termStatistics: termStatistics,
      fieldStatistics: fieldStatistics,
      fields: fields,
      offsets: offsets,
      positions: positions,
      payloads: payloads,
      preference: preference,
      routing: routing,
      realtime: realtime,
      version: version,
      versionType: versionType,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information and statistics about terms in the fields of a particular document.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   The index in which the document resides.
  ///
  /// * [bool] termStatistics:
  ///   Specifies if total term frequency and document frequency should be returned.
  ///
  /// * [bool] fieldStatistics:
  ///   Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields to return.
  ///
  /// * [bool] offsets:
  ///   Specifies if term offsets should be returned.
  ///
  /// * [bool] positions:
  ///   Specifies if term positions should be returned.
  ///
  /// * [bool] payloads:
  ///   Specifies if term payloads should be returned.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [bool] realtime:
  ///   Specifies if request is real-time as opposed to near-real-time.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  ///
  /// * [Object] body:
  Future<Response> termvectorsPostWithHttpInfo(
    String index, {
    bool? termStatistics,
    bool? fieldStatistics,
    List<String>? fields,
    bool? offsets,
    bool? positions,
    bool? payloads,
    String? preference,
    String? routing,
    bool? realtime,
    int? version,
    VersionType? versionType,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_termvectors'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (termStatistics != null) {
      queryParams.addAll(_queryParams('', 'term_statistics', termStatistics));
    }
    if (fieldStatistics != null) {
      queryParams.addAll(_queryParams('', 'field_statistics', fieldStatistics));
    }
    if (fields != null) {
      queryParams.addAll(_queryParams('multi', 'fields', fields));
    }
    if (offsets != null) {
      queryParams.addAll(_queryParams('', 'offsets', offsets));
    }
    if (positions != null) {
      queryParams.addAll(_queryParams('', 'positions', positions));
    }
    if (payloads != null) {
      queryParams.addAll(_queryParams('', 'payloads', payloads));
    }
    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (realtime != null) {
      queryParams.addAll(_queryParams('', 'realtime', realtime));
    }
    if (version != null) {
      queryParams.addAll(_queryParams('', 'version', version));
    }
    if (versionType != null) {
      queryParams.addAll(_queryParams('', 'version_type', versionType));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information and statistics about terms in the fields of a particular document.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   The index in which the document resides.
  ///
  /// * [bool] termStatistics:
  ///   Specifies if total term frequency and document frequency should be returned.
  ///
  /// * [bool] fieldStatistics:
  ///   Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields to return.
  ///
  /// * [bool] offsets:
  ///   Specifies if term offsets should be returned.
  ///
  /// * [bool] positions:
  ///   Specifies if term positions should be returned.
  ///
  /// * [bool] payloads:
  ///   Specifies if term payloads should be returned.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [bool] realtime:
  ///   Specifies if request is real-time as opposed to near-real-time.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  ///
  /// * [Object] body:
  Future<void> termvectorsPost(
    String index, {
    bool? termStatistics,
    bool? fieldStatistics,
    List<String>? fields,
    bool? offsets,
    bool? positions,
    bool? payloads,
    String? preference,
    String? routing,
    bool? realtime,
    int? version,
    VersionType? versionType,
    Object? body,
  }) async {
    final response = await termvectorsPostWithHttpInfo(
      index,
      termStatistics: termStatistics,
      fieldStatistics: fieldStatistics,
      fields: fields,
      offsets: offsets,
      positions: positions,
      payloads: payloads,
      preference: preference,
      routing: routing,
      realtime: realtime,
      version: version,
      versionType: versionType,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Returns information and statistics about terms in the fields of a particular document.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   The index in which the document resides.
  ///
  /// * [String] id (required):
  ///   Document ID. When not specified a doc param should be supplied.
  ///
  /// * [bool] termStatistics:
  ///   Specifies if total term frequency and document frequency should be returned.
  ///
  /// * [bool] fieldStatistics:
  ///   Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields to return.
  ///
  /// * [bool] offsets:
  ///   Specifies if term offsets should be returned.
  ///
  /// * [bool] positions:
  ///   Specifies if term positions should be returned.
  ///
  /// * [bool] payloads:
  ///   Specifies if term payloads should be returned.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [bool] realtime:
  ///   Specifies if request is real-time as opposed to near-real-time.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  ///
  /// * [Object] body:
  Future<Response> termvectorsPostWithIdWithHttpInfo(
    String index,
    String id, {
    bool? termStatistics,
    bool? fieldStatistics,
    List<String>? fields,
    bool? offsets,
    bool? positions,
    bool? payloads,
    String? preference,
    String? routing,
    bool? realtime,
    int? version,
    VersionType? versionType,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_termvectors/{id}'
        .replaceAll('{index}', index)
        .replaceAll('{id}', id);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (termStatistics != null) {
      queryParams.addAll(_queryParams('', 'term_statistics', termStatistics));
    }
    if (fieldStatistics != null) {
      queryParams.addAll(_queryParams('', 'field_statistics', fieldStatistics));
    }
    if (fields != null) {
      queryParams.addAll(_queryParams('multi', 'fields', fields));
    }
    if (offsets != null) {
      queryParams.addAll(_queryParams('', 'offsets', offsets));
    }
    if (positions != null) {
      queryParams.addAll(_queryParams('', 'positions', positions));
    }
    if (payloads != null) {
      queryParams.addAll(_queryParams('', 'payloads', payloads));
    }
    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (realtime != null) {
      queryParams.addAll(_queryParams('', 'realtime', realtime));
    }
    if (version != null) {
      queryParams.addAll(_queryParams('', 'version', version));
    }
    if (versionType != null) {
      queryParams.addAll(_queryParams('', 'version_type', versionType));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Returns information and statistics about terms in the fields of a particular document.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   The index in which the document resides.
  ///
  /// * [String] id (required):
  ///   Document ID. When not specified a doc param should be supplied.
  ///
  /// * [bool] termStatistics:
  ///   Specifies if total term frequency and document frequency should be returned.
  ///
  /// * [bool] fieldStatistics:
  ///   Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.
  ///
  /// * [List<String>] fields:
  ///   Comma-separated list of fields to return.
  ///
  /// * [bool] offsets:
  ///   Specifies if term offsets should be returned.
  ///
  /// * [bool] positions:
  ///   Specifies if term positions should be returned.
  ///
  /// * [bool] payloads:
  ///   Specifies if term payloads should be returned.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [bool] realtime:
  ///   Specifies if request is real-time as opposed to near-real-time.
  ///
  /// * [int] version:
  ///   Explicit version number for concurrency control.
  ///
  /// * [VersionType] versionType:
  ///   Specific version type.
  ///
  /// * [Object] body:
  Future<void> termvectorsPostWithId(
    String index,
    String id, {
    bool? termStatistics,
    bool? fieldStatistics,
    List<String>? fields,
    bool? offsets,
    bool? positions,
    bool? payloads,
    String? preference,
    String? routing,
    bool? realtime,
    int? version,
    VersionType? versionType,
    Object? body,
  }) async {
    final response = await termvectorsPostWithIdWithHttpInfo(
      index,
      id,
      termStatistics: termStatistics,
      fieldStatistics: fieldStatistics,
      fields: fields,
      offsets: offsets,
      positions: positions,
      payloads: payloads,
      preference: preference,
      routing: routing,
      realtime: realtime,
      version: version,
      versionType: versionType,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Updates a document with a script or partial document.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Document ID.
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  ///
  /// * [String] lang:
  ///   The script language.
  ///
  /// * [RefreshEnum] refresh:
  ///   If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
  ///
  /// * [int] retryOnConflict:
  ///   Specify how many times should the operation be retried when a conflict occurs.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [int] ifSeqNo:
  ///   only perform the operation if the last operation that has changed the document has the specified sequence number.
  ///
  /// * [int] ifPrimaryTerm:
  ///   only perform the operation if the last operation that has changed the document has the specified primary term.
  ///
  /// * [bool] requireAlias:
  ///   When true, requires destination to be an alias.
  Future<Response> updateWithHttpInfo(
    String id,
    String index,
    Object body, {
    String? waitForActiveShards,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    String? lang,
    RefreshEnum? refresh,
    int? retryOnConflict,
    String? routing,
    String? timeout,
    int? ifSeqNo,
    int? ifPrimaryTerm,
    bool? requireAlias,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_update/{id}'
        .replaceAll('{id}', id)
        .replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (waitForActiveShards != null) {
      queryParams.addAll(
          _queryParams('', 'wait_for_active_shards', waitForActiveShards));
    }
    if (source_ != null) {
      queryParams.addAll(_queryParams('multi', '_source', source_));
    }
    if (sourceExcludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_excludes', sourceExcludes));
    }
    if (sourceIncludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_includes', sourceIncludes));
    }
    if (lang != null) {
      queryParams.addAll(_queryParams('', 'lang', lang));
    }
    if (refresh != null) {
      queryParams.addAll(_queryParams('', 'refresh', refresh));
    }
    if (retryOnConflict != null) {
      queryParams
          .addAll(_queryParams('', 'retry_on_conflict', retryOnConflict));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('', 'routing', routing));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (ifSeqNo != null) {
      queryParams.addAll(_queryParams('', 'if_seq_no', ifSeqNo));
    }
    if (ifPrimaryTerm != null) {
      queryParams.addAll(_queryParams('', 'if_primary_term', ifPrimaryTerm));
    }
    if (requireAlias != null) {
      queryParams.addAll(_queryParams('', 'require_alias', requireAlias));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Updates a document with a script or partial document.
  ///
  /// Parameters:
  ///
  /// * [String] id (required):
  ///   Document ID.
  ///
  /// * [String] index (required):
  ///   Index name.
  ///
  /// * [Object] body (required):
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  ///
  /// * [String] lang:
  ///   The script language.
  ///
  /// * [RefreshEnum] refresh:
  ///   If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.
  ///
  /// * [int] retryOnConflict:
  ///   Specify how many times should the operation be retried when a conflict occurs.
  ///
  /// * [String] routing:
  ///   Routing value.
  ///
  /// * [String] timeout:
  ///   Operation timeout.
  ///
  /// * [int] ifSeqNo:
  ///   only perform the operation if the last operation that has changed the document has the specified sequence number.
  ///
  /// * [int] ifPrimaryTerm:
  ///   only perform the operation if the last operation that has changed the document has the specified primary term.
  ///
  /// * [bool] requireAlias:
  ///   When true, requires destination to be an alias.
  Future<void> update(
    String id,
    String index,
    Object body, {
    String? waitForActiveShards,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    String? lang,
    RefreshEnum? refresh,
    int? retryOnConflict,
    String? routing,
    String? timeout,
    int? ifSeqNo,
    int? ifPrimaryTerm,
    bool? requireAlias,
  }) async {
    final response = await updateWithHttpInfo(
      id,
      index,
      body,
      waitForActiveShards: waitForActiveShards,
      source_: source_,
      sourceExcludes: sourceExcludes,
      sourceIncludes: sourceIncludes,
      lang: lang,
      refresh: refresh,
      retryOnConflict: retryOnConflict,
      routing: routing,
      timeout: timeout,
      ifSeqNo: ifSeqNo,
      ifPrimaryTerm: ifPrimaryTerm,
      requireAlias: requireAlias,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Updates the audit configuration.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [AuditConfig] auditConfig (required):
  Future<Response> updateAuditConfigurationWithHttpInfo(
    AuditConfig auditConfig,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/audit/config';

    // ignore: prefer_final_locals
    Object? postBody = auditConfig;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Updates the audit configuration.
  ///
  /// Parameters:
  ///
  /// * [AuditConfig] auditConfig (required):
  Future<UpdateAuditConfigurationResponseContent?> updateAuditConfiguration(
    AuditConfig auditConfig,
  ) async {
    final response = await updateAuditConfigurationWithHttpInfo(
      auditConfig,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'UpdateAuditConfigurationResponseContent',
      ) as UpdateAuditConfigurationResponseContent;
    }
    return null;
  }

  /// Performs an update on every document in the index without changing the source, for example to pick up a mapping change.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcard and prefix queries should be analyzed.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The field to use as default where no field prefix is given in the query string.
  ///
  /// * [int] from:
  ///   Starting offset.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [Conflicts] conflicts:
  ///   What to do when the operation encounters version conflicts?.
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [String] pipeline:
  ///   The pipeline id to preprocess incoming documents with.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [List<String>] routing:
  ///   Comma-separated list of specific routing values.
  ///
  /// * [String] scroll:
  ///   Specify how long a consistent view of the index should be maintained for scrolled search.
  ///
  /// * [SearchType] searchType:
  ///   Search operation type.
  ///
  /// * [String] searchTimeout:
  ///   Explicit timeout for each search request. Defaults to no timeout.
  ///
  /// * [int] size:
  ///   Deprecated, please use `max_docs` instead.
  ///
  /// * [int] maxDocs:
  ///   Maximum number of documents to process (default: all documents).
  ///
  /// * [List<String>] sort:
  ///   Comma-separated list of <field>:<direction> pairs.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  ///
  /// * [int] terminateAfter:
  ///   The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
  ///
  /// * [List<String>] stats:
  ///   Specific 'tag' of the request for logging and statistical purposes.
  ///
  /// * [bool] version:
  ///   Whether to return document version as part of a hit.
  ///
  /// * [bool] requestCache:
  ///   Specify if request cache should be used for this request or not, defaults to index level setting.
  ///
  /// * [bool] refresh:
  ///   Should the affected indexes be refreshed?.
  ///
  /// * [String] timeout:
  ///   Time each individual bulk request should wait for shards that are unavailable.
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
  ///
  /// * [int] scrollSize:
  ///   Size on the scroll request powering the operation.
  ///
  /// * [bool] waitForCompletion:
  ///   Should this request wait until the operation has completed before returning.
  ///
  /// * [int] requestsPerSecond:
  ///   The throttle for this request in sub-requests per second. -1 means no throttle.
  ///
  /// * [String] slices:
  ///   The number of slices this task should be divided into. Defaults to 1, meaning the task isn't sliced into subtasks. Can be set to `auto`.
  ///
  /// * [Object] body:
  Future<Response> updateByQueryWithHttpInfo(
    String index, {
    String? analyzer,
    bool? analyzeWildcard,
    DefaultOperator? defaultOperator,
    String? df,
    int? from,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    Conflicts? conflicts,
    ExpandWildcards? expandWildcards,
    bool? lenient,
    String? pipeline,
    String? preference,
    String? q,
    List<String>? routing,
    String? scroll,
    SearchType? searchType,
    String? searchTimeout,
    int? size,
    int? maxDocs,
    List<String>? sort,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    int? terminateAfter,
    List<String>? stats,
    bool? version,
    bool? requestCache,
    bool? refresh,
    String? timeout,
    String? waitForActiveShards,
    int? scrollSize,
    bool? waitForCompletion,
    int? requestsPerSecond,
    String? slices,
    Object? body,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/{index}/_update_by_query'.replaceAll('{index}', index);

    // ignore: prefer_final_locals
    Object? postBody = body;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    if (analyzer != null) {
      queryParams.addAll(_queryParams('', 'analyzer', analyzer));
    }
    if (analyzeWildcard != null) {
      queryParams.addAll(_queryParams('', 'analyze_wildcard', analyzeWildcard));
    }
    if (defaultOperator != null) {
      queryParams.addAll(_queryParams('', 'default_operator', defaultOperator));
    }
    if (df != null) {
      queryParams.addAll(_queryParams('', 'df', df));
    }
    if (from != null) {
      queryParams.addAll(_queryParams('', 'from', from));
    }
    if (ignoreUnavailable != null) {
      queryParams
          .addAll(_queryParams('', 'ignore_unavailable', ignoreUnavailable));
    }
    if (allowNoIndices != null) {
      queryParams.addAll(_queryParams('', 'allow_no_indices', allowNoIndices));
    }
    if (conflicts != null) {
      queryParams.addAll(_queryParams('', 'conflicts', conflicts));
    }
    if (expandWildcards != null) {
      queryParams.addAll(_queryParams('', 'expand_wildcards', expandWildcards));
    }
    if (lenient != null) {
      queryParams.addAll(_queryParams('', 'lenient', lenient));
    }
    if (pipeline != null) {
      queryParams.addAll(_queryParams('', 'pipeline', pipeline));
    }
    if (preference != null) {
      queryParams.addAll(_queryParams('', 'preference', preference));
    }
    if (q != null) {
      queryParams.addAll(_queryParams('', 'q', q));
    }
    if (routing != null) {
      queryParams.addAll(_queryParams('multi', 'routing', routing));
    }
    if (scroll != null) {
      queryParams.addAll(_queryParams('', 'scroll', scroll));
    }
    if (searchType != null) {
      queryParams.addAll(_queryParams('', 'search_type', searchType));
    }
    if (searchTimeout != null) {
      queryParams.addAll(_queryParams('', 'search_timeout', searchTimeout));
    }
    if (size != null) {
      queryParams.addAll(_queryParams('', 'size', size));
    }
    if (maxDocs != null) {
      queryParams.addAll(_queryParams('', 'max_docs', maxDocs));
    }
    if (sort != null) {
      queryParams.addAll(_queryParams('multi', 'sort', sort));
    }
    if (source_ != null) {
      queryParams.addAll(_queryParams('multi', '_source', source_));
    }
    if (sourceExcludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_excludes', sourceExcludes));
    }
    if (sourceIncludes != null) {
      queryParams
          .addAll(_queryParams('multi', '_source_includes', sourceIncludes));
    }
    if (terminateAfter != null) {
      queryParams.addAll(_queryParams('', 'terminate_after', terminateAfter));
    }
    if (stats != null) {
      queryParams.addAll(_queryParams('multi', 'stats', stats));
    }
    if (version != null) {
      queryParams.addAll(_queryParams('', 'version', version));
    }
    if (requestCache != null) {
      queryParams.addAll(_queryParams('', 'request_cache', requestCache));
    }
    if (refresh != null) {
      queryParams.addAll(_queryParams('', 'refresh', refresh));
    }
    if (timeout != null) {
      queryParams.addAll(_queryParams('', 'timeout', timeout));
    }
    if (waitForActiveShards != null) {
      queryParams.addAll(
          _queryParams('', 'wait_for_active_shards', waitForActiveShards));
    }
    if (scrollSize != null) {
      queryParams.addAll(_queryParams('', 'scroll_size', scrollSize));
    }
    if (waitForCompletion != null) {
      queryParams
          .addAll(_queryParams('', 'wait_for_completion', waitForCompletion));
    }
    if (requestsPerSecond != null) {
      queryParams
          .addAll(_queryParams('', 'requests_per_second', requestsPerSecond));
    }
    if (slices != null) {
      queryParams.addAll(_queryParams('', 'slices', slices));
    }

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Performs an update on every document in the index without changing the source, for example to pick up a mapping change.
  ///
  /// Parameters:
  ///
  /// * [String] index (required):
  ///   Comma-separated list of indices; use `_all` or empty string to perform the operation on all indices.
  ///
  /// * [String] analyzer:
  ///   The analyzer to use for the query string.
  ///
  /// * [bool] analyzeWildcard:
  ///   Specify whether wildcard and prefix queries should be analyzed.
  ///
  /// * [DefaultOperator] defaultOperator:
  ///   The default operator for query string query (AND or OR).
  ///
  /// * [String] df:
  ///   The field to use as default where no field prefix is given in the query string.
  ///
  /// * [int] from:
  ///   Starting offset.
  ///
  /// * [bool] ignoreUnavailable:
  ///   Whether specified concrete indices should be ignored when unavailable (missing or closed).
  ///
  /// * [bool] allowNoIndices:
  ///   Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified).
  ///
  /// * [Conflicts] conflicts:
  ///   What to do when the operation encounters version conflicts?.
  ///
  /// * [ExpandWildcards] expandWildcards:
  ///   Whether to expand wildcard expression to concrete indices that are open, closed or both.
  ///
  /// * [bool] lenient:
  ///   Specify whether format-based query failures (such as providing text to a numeric field) should be ignored.
  ///
  /// * [String] pipeline:
  ///   The pipeline id to preprocess incoming documents with.
  ///
  /// * [String] preference:
  ///   Specify the node or shard the operation should be performed on.
  ///
  /// * [String] q:
  ///   Query in the Lucene query string syntax.
  ///
  /// * [List<String>] routing:
  ///   Comma-separated list of specific routing values.
  ///
  /// * [String] scroll:
  ///   Specify how long a consistent view of the index should be maintained for scrolled search.
  ///
  /// * [SearchType] searchType:
  ///   Search operation type.
  ///
  /// * [String] searchTimeout:
  ///   Explicit timeout for each search request. Defaults to no timeout.
  ///
  /// * [int] size:
  ///   Deprecated, please use `max_docs` instead.
  ///
  /// * [int] maxDocs:
  ///   Maximum number of documents to process (default: all documents).
  ///
  /// * [List<String>] sort:
  ///   Comma-separated list of <field>:<direction> pairs.
  ///
  /// * [List<String>] source_:
  ///   True or false to return the _source field or not, or a list of fields to return.
  ///
  /// * [List<String>] sourceExcludes:
  ///   List of fields to exclude from the returned _source field.
  ///
  /// * [List<String>] sourceIncludes:
  ///   List of fields to extract and return from the _source field.
  ///
  /// * [int] terminateAfter:
  ///   The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
  ///
  /// * [List<String>] stats:
  ///   Specific 'tag' of the request for logging and statistical purposes.
  ///
  /// * [bool] version:
  ///   Whether to return document version as part of a hit.
  ///
  /// * [bool] requestCache:
  ///   Specify if request cache should be used for this request or not, defaults to index level setting.
  ///
  /// * [bool] refresh:
  ///   Should the affected indexes be refreshed?.
  ///
  /// * [String] timeout:
  ///   Time each individual bulk request should wait for shards that are unavailable.
  ///
  /// * [String] waitForActiveShards:
  ///   Sets the number of shard copies that must be active before proceeding with the operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1).
  ///
  /// * [int] scrollSize:
  ///   Size on the scroll request powering the operation.
  ///
  /// * [bool] waitForCompletion:
  ///   Should this request wait until the operation has completed before returning.
  ///
  /// * [int] requestsPerSecond:
  ///   The throttle for this request in sub-requests per second. -1 means no throttle.
  ///
  /// * [String] slices:
  ///   The number of slices this task should be divided into. Defaults to 1, meaning the task isn't sliced into subtasks. Can be set to `auto`.
  ///
  /// * [Object] body:
  Future<void> updateByQuery(
    String index, {
    String? analyzer,
    bool? analyzeWildcard,
    DefaultOperator? defaultOperator,
    String? df,
    int? from,
    bool? ignoreUnavailable,
    bool? allowNoIndices,
    Conflicts? conflicts,
    ExpandWildcards? expandWildcards,
    bool? lenient,
    String? pipeline,
    String? preference,
    String? q,
    List<String>? routing,
    String? scroll,
    SearchType? searchType,
    String? searchTimeout,
    int? size,
    int? maxDocs,
    List<String>? sort,
    List<String>? source_,
    List<String>? sourceExcludes,
    List<String>? sourceIncludes,
    int? terminateAfter,
    List<String>? stats,
    bool? version,
    bool? requestCache,
    bool? refresh,
    String? timeout,
    String? waitForActiveShards,
    int? scrollSize,
    bool? waitForCompletion,
    int? requestsPerSecond,
    String? slices,
    Object? body,
  }) async {
    final response = await updateByQueryWithHttpInfo(
      index,
      analyzer: analyzer,
      analyzeWildcard: analyzeWildcard,
      defaultOperator: defaultOperator,
      df: df,
      from: from,
      ignoreUnavailable: ignoreUnavailable,
      allowNoIndices: allowNoIndices,
      conflicts: conflicts,
      expandWildcards: expandWildcards,
      lenient: lenient,
      pipeline: pipeline,
      preference: preference,
      q: q,
      routing: routing,
      scroll: scroll,
      searchType: searchType,
      searchTimeout: searchTimeout,
      size: size,
      maxDocs: maxDocs,
      sort: sort,
      source_: source_,
      sourceExcludes: sourceExcludes,
      sourceIncludes: sourceIncludes,
      terminateAfter: terminateAfter,
      stats: stats,
      version: version,
      requestCache: requestCache,
      refresh: refresh,
      timeout: timeout,
      waitForActiveShards: waitForActiveShards,
      scrollSize: scrollSize,
      waitForCompletion: waitForCompletion,
      requestsPerSecond: requestsPerSecond,
      slices: slices,
      body: body,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Changes the number of requests per second for a particular Update By Query operation.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] taskId (required):
  ///   The task id to rethrottle.
  ///
  /// * [int] requestsPerSecond (required):
  ///   The throttle for this request in sub-requests per second. -1 means no throttle.
  Future<Response> updateByQueryRethrottleWithHttpInfo(
    String taskId,
    int requestsPerSecond,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_update_by_query/{task_id}/_rethrottle'
        .replaceAll('{task_id}', taskId);

    // ignore: prefer_final_locals
    Object? postBody;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    queryParams
        .addAll(_queryParams('', 'requests_per_second', requestsPerSecond));

    const contentTypes = <String>[];

    return apiClient.invokeAPI(
      path,
      'POST',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Changes the number of requests per second for a particular Update By Query operation.
  ///
  /// Parameters:
  ///
  /// * [String] taskId (required):
  ///   The task id to rethrottle.
  ///
  /// * [int] requestsPerSecond (required):
  ///   The throttle for this request in sub-requests per second. -1 means no throttle.
  Future<void> updateByQueryRethrottle(
    String taskId,
    int requestsPerSecond,
  ) async {
    final response = await updateByQueryRethrottleWithHttpInfo(
      taskId,
      requestsPerSecond,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
  }

  /// Adds or updates the existing configuration using the REST API.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [DynamicConfig] dynamicConfig (required):
  Future<Response> updateConfigurationWithHttpInfo(
    DynamicConfig dynamicConfig,
  ) async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/securityconfig/config';

    // ignore: prefer_final_locals
    Object? postBody = dynamicConfig;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Adds or updates the existing configuration using the REST API.
  ///
  /// Parameters:
  ///
  /// * [DynamicConfig] dynamicConfig (required):
  Future<UpdateConfigurationResponseContent?> updateConfiguration(
    DynamicConfig dynamicConfig,
  ) async {
    final response = await updateConfigurationWithHttpInfo(
      dynamicConfig,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'UpdateConfigurationResponseContent',
      ) as UpdateConfigurationResponseContent;
    }
    return null;
  }

  /// Adds or updates the specified distinguished names in the clusters or nodes allow list.
  ///
  /// Note: This method returns the HTTP [Response].
  ///
  /// Parameters:
  ///
  /// * [String] clusterName (required):
  ///
  /// * [DistinguishedNames] distinguishedNames:
  Future<Response> updateDistinguishedNamesWithHttpInfo(
    String clusterName, {
    DistinguishedNames? distinguishedNames,
  }) async {
    // ignore: prefer_const_declarations
    final path = r'/_plugins/_security/api/nodesdn/{cluster_name}'
        .replaceAll('{cluster_name}', clusterName);

    // ignore: prefer_final_locals
    Object? postBody = distinguishedNames;

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    const contentTypes = <String>['application/json'];

    return apiClient.invokeAPI(
      path,
      'PUT',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  /// Adds or updates the specified distinguished names in the clusters or nodes allow list.
  ///
  /// Parameters:
  ///
  /// * [String] clusterName (required):
  ///
  /// * [DistinguishedNames] distinguishedNames:
  Future<UpdateDistinguishedNamesResponseContent?> updateDistinguishedNames(
    String clusterName, {
    DistinguishedNames? distinguishedNames,
  }) async {
    final response = await updateDistinguishedNamesWithHttpInfo(
      clusterName,
      distinguishedNames: distinguishedNames,
    );
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, await _decodeBodyBytes(response));
    }
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty &&
        response.statusCode != HttpStatus.noContent) {
      return await apiClient.deserializeAsync(
        await _decodeBodyBytes(response),
        'UpdateDistinguishedNamesResponseContent',
      ) as UpdateDistinguishedNamesResponseContent;
    }
    return null;
  }
}
